

// begin --- .gitignore --- 

vc120.pdb
4ed_data.ctm
.DS_Store
*.dSYM

// end --- .gitignore --- 



// begin --- generated --- 



// end --- generated --- 



// begin --- metal --- 



// end --- metal --- 



// begin --- opengl --- 



// end --- opengl --- 



// begin --- platform_linux --- 



// end --- platform_linux --- 



// begin --- platform_mac --- 



// end --- platform_mac --- 



// begin --- platform_unix --- 



// end --- platform_unix --- 



// begin --- platform_win32 --- 



// end --- platform_win32 --- 



// begin --- gen_linux_icon.c --- 

// NOTE(inso): how to use:
//
// load up the icon in gimp and choose export, select "c source code (*.c)" as the format
// call the file gimp_icon.c, then include it by uncommenting line below.
//
// make sure the struct in the .c file is called gimp_image (the default).
//
// then just compile and run this program and it'll create linux_icon.h
//

#define OUTPUT_FILE "linux_icon.h"

int main(void){
    
	FILE* f = fopen(OUTPUT_FILE, "w");
    
	fputs("/* Generated by gen_linux_icon.c */\n", f);
    
	int w = gimp_image.width, h = gimp_image.height;
	fprintf(f, "static const unsigned long linux_icon[] = {\n    %d, %d,", w, h);
    
	const unsigned char* p = gimp_image.pixel_data;
    
	int i;
	for(i = 0; i < (w*h); ++i){
        
		if((i % 6) == 0){
			fputs("\n   ", f);
		}
        
		unsigned int pixel = 0;
        
		pixel |= *p++ << 16L;
		pixel |= *p++ << 8L;
		pixel |= *p++;
		pixel |= *p++ << 24L;
        
		fprintf(f, " 0x%08x,", pixel);
	}
    
	fputs("\n};\n", f);
    
	fclose(f);
    
	puts("Generated linux icon in " OUTPUT_FILE);
}


// end --- gen_linux_icon.c --- 



// begin --- linux_release_compat.c --- 

#include <string.h>

// Link to the memcpy symbol with version 2.2.5 instead of the newer 2.14 one
// since they are functionaly equivalent, but using the old one allows 4coder
// to run on older distros without glibc >= 2.14

extern "C" {
    asm (".symver memcpy, memcpy@GLIBC_2.2.5");
    void *__wrap_memcpy(void *dest, const void *src, size_t n){
        return memcpy(dest, src, n);
    }
}


// end --- linux_release_compat.c --- 



// begin --- 4ed.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 12.12.2014
 *
 * Application layer for project codename "4ed"
 *
 */

// TOP

internal void
init_command_line_settings(App_Settings *settings, Plat_Settings *plat_settings, i32 argc, char **argv){
    char *arg = 0;
    Command_Line_Mode mode = CLMode_App;
    Command_Line_Action action = CLAct_Nothing;
    b32 strict = false;
    
    settings->init_files_max = ArrayCount(settings->init_files);
    for (i32 i = 1; i <= argc; ++i){
        if (i == argc){
            arg = "";
        }
        else{
            arg = argv[i];
        }
        
        if (arg[0] == '-' && arg[1] == '-'){
            char *long_arg_name = arg+2;
            if (string_match(SCu8(long_arg_name), string_u8_litexpr("custom"))){
                mode = CLMode_Custom;
                continue;
            }
        }
        
        switch (mode){
            case CLMode_App:
            {
                switch (action){
                    case CLAct_Nothing:
                    {
                        if (arg[0] == '-'){
                            action = CLAct_Ignore;
                            switch (arg[1]){
                                case 'd': action = CLAct_CustomDLL; strict = false; break;
                                case 'D': action = CLAct_CustomDLL; strict = true; break;
                                
                                case 'w': action = CLAct_WindowSize; break;
                                case 'W': action = CLAct_WindowMaximize; break;
                                case 'p': action = CLAct_WindowPosition; break;
                                case 'F': action = CLAct_WindowFullscreen; break;
                                
                                case 'f': action = CLAct_FontSize; break;
                                case 'h': action = CLAct_FontUseHinting; --i; break;
                                case 'U': action = CLAct_UserDirectory; break;
                                
                                case 'L': action = CLAct_Nothing; break;
                                //case 'L': enables log, parsed before this is called (because I'm a dumbass)
                            }
                        }
                        else if (arg[0] != 0){
                            if (settings->init_files_count < settings->init_files_max){
                                i32 index = settings->init_files_count++;
                                settings->init_files[index] = arg;
                            }
                        }
                    }break;
                    
                    case CLAct_CustomDLL:
                    {
                        plat_settings->custom_dll_is_strict = (b8)strict;
                        if (i < argc){
                            plat_settings->custom_dll = argv[i];
                        }
                        action = CLAct_Nothing;
                    }break;
                    
                    case CLAct_WindowSize:
                    {
                        if (i + 1 < argc){
                            plat_settings->set_window_size = true;
                            
                            i32 w = (i32)string_to_integer(SCu8(argv[i]), 10);
                            i32 h = (i32)string_to_integer(SCu8(argv[i + 1]), 10);
                            if (w > 0){
                                plat_settings->window_w = w;
                            }
                            if (h > 0){
                                plat_settings->window_h = h;
                            }
                            
                            ++i;
                        }
                        action = CLAct_Nothing;
                    }break;
                    
                    case CLAct_WindowMaximize:
                    {
                        --i;
                        plat_settings->maximize_window = true;
                        action = CLAct_Nothing;
                    }break;
                    
                    case CLAct_WindowPosition:
                    {
                        if (i + 1 < argc){
                            plat_settings->set_window_pos = true;
                            
                            i32 x = (i32)string_to_integer(SCu8(argv[i]), 10);
                            i32 y = (i32)string_to_integer(SCu8(argv[i + 1]), 10);
                            if (x > 0){
                                plat_settings->window_x = x;
                            }
                            if (y > 0){
                                plat_settings->window_y = y;
                            }
                            
                            ++i;
                        }
                        action = CLAct_Nothing;
                    }break;
                    
                    case CLAct_WindowFullscreen:
                    {
                        --i;
                        plat_settings->fullscreen_window = true;
                        action = CLAct_Nothing;
                    }break;
                    
                    case CLAct_FontSize:
                    {
                        if (i < argc){
                            settings->font_size = (i32)string_to_integer(SCu8(argv[i]), 10);
                        }
                        action = CLAct_Nothing;
                    }break;
                    
                    case CLAct_FontUseHinting:
                    {
                        plat_settings->use_hinting = true;
                        settings->use_hinting = plat_settings->use_hinting;
                        action = CLAct_Nothing;
                    }break;
                    
                    case CLAct_UserDirectory:
                    {
                        if (i < argc){
                            plat_settings->user_directory = argv[i];
                        }
                        action = CLAct_Nothing;
                    }break;
                }
            }break;
            
            case CLMode_Custom:
            {
                settings->custom_flags = argv + i;
                settings->custom_flags_count = argc - i;
                i = argc;
                mode = CLMode_App;
            }break;
        }
    }
}

////////////////////////////////

internal Models*
models_init(void){
    Arena arena = make_arena_system();
    Models *models = push_array_zero(&arena, Models, 1);
    models->arena_ = arena;
    models->arena = &models->arena_;
    heap_init(&models->heap, get_base_allocator_system());
    return(models);
}

internal void
app_load_vtables(API_VTable_system *vtable_system, API_VTable_font *vtable_font, API_VTable_graphics *vtable_graphics){
    system_api_read_vtable(vtable_system);
    font_api_read_vtable(vtable_font);
    graphics_api_read_vtable(vtable_graphics);
}

internal Log_Function*
app_get_logger(void){
    log_init();
    return(log_string);
}

App_Read_Command_Line_Sig(app_read_command_line){
    Models *models = models_init();
    App_Settings *settings = &models->settings;
    block_zero_struct(settings);
    if (argc > 1){
        init_command_line_settings(&models->settings, plat_settings, argc, argv);
    }
    *files = models->settings.init_files;
    *file_count = &models->settings.init_files_count;
    return(models);
}

App_Init_Sig(app_init){
    Models *models = (Models*)base_ptr;
    models->keep_playing = true;
    models->hard_exit = false;
    
    models->config_api = api;
    models->virtual_event_arena = make_arena_system();
    
    profile_init(&models->profile_list);
    
    managed_ids_init(tctx->allocator, &models->managed_id_set);
    
    API_VTable_custom custom_vtable = {};
    custom_api_fill_vtable(&custom_vtable);
    API_VTable_system system_vtable = {};
    system_api_fill_vtable(&system_vtable);
    Custom_Layer_Init_Type *custom_init = api.init_apis(&custom_vtable, &system_vtable);
    Assert(custom_init != 0);
    
    // NOTE(allen): coroutines
    coroutine_system_init(&models->coroutines);
    
    // NOTE(allen): font set
    font_set_init(&models->font_set);
    
    // NOTE(allen): live set
    Arena *arena = models->arena;
    {
        models->view_set.count = 0;
        models->view_set.max = MAX_VIEWS;
        models->view_set.views = push_array(arena, View, models->view_set.max);
        
        //dll_init_sentinel
        models->view_set.free_sentinel.next = &models->view_set.free_sentinel;
        models->view_set.free_sentinel.prev = &models->view_set.free_sentinel;
        
        i32 max = models->view_set.max;
        View *view = models->view_set.views;
        for (i32 i = 0; i < max; ++i, ++view){
            //dll_insert(&models->view_set.free_sentinel, view);
            view->next = models->view_set.free_sentinel.next;
            view->prev = &models->view_set.free_sentinel;
            models->view_set.free_sentinel.next = view;
            view->next->prev = view;
        }
    }
    
    lifetime_allocator_init(tctx->allocator, &models->lifetime_allocator);
    dynamic_workspace_init(&models->lifetime_allocator, DynamicWorkspace_Global, 0, &models->dynamic_workspace);
    
    // NOTE(allen): file setup
    working_set_init(models, &models->working_set);
    Mutex_Lock file_order_lock(models->working_set.mutex);
    
    // NOTE(allen):
    global_history_init(&models->global_history);
    text_layout_init(tctx, &models->text_layouts);
    
    // NOTE(allen): style setup
    {
        Scratch_Block scratch(tctx, arena);
        
        String8 binary_path = system_get_path(scratch, SystemPath_Binary);
        String8 full_path = push_u8_stringf(arena, "%.*sfonts/liberation-mono.ttf", string_expand(binary_path));
        
        Face_Description description = {};
        description.font.file_name = full_path;
        description.parameters.pt_size = 12;
        Face *new_face = font_set_new_face(&models->font_set, &description);
        if (new_face == 0){
            system_error_box("Could not load the required fallback font");
        }
        models->global_face_id = new_face->id;
    }
    
    // NOTE(allen): title space
    models->has_new_title = true;
    models->title_capacity = KB(4);
    models->title_space = push_array(arena, char, models->title_capacity);
    block_copy(models->title_space, WINDOW_NAME, sizeof(WINDOW_NAME));
    
    // NOTE(allen): miscellaneous init
    hot_directory_init(arena, &models->hot_directory, current_directory);
    child_process_container_init(tctx->allocator, &models->child_processes);
    models->period_wakeup_timer = system_wake_up_timer_create();
    
    // NOTE(allen): custom layer init
    Application_Links app = {};
    app.tctx = tctx;
    app.cmd_context = models;
    custom_init(&app);
    
    // NOTE(allen): init baked in buffers
    File_Init init_files[] = {
        { str8_lit("*messages*"), &models->message_buffer , true , },
        { str8_lit("*scratch*") , &models->scratch_buffer , false, },
        { str8_lit("*log*")     , &models->log_buffer     , true , },
        { str8_lit("*keyboard*"), &models->keyboard_buffer, true , },
    };
    
    Buffer_Hook_Function *begin_buffer_func = models->begin_buffer;
    models->begin_buffer = 0;
    
    Heap *heap = &models->heap;
    for (i32 i = 0; i < ArrayCount(init_files); ++i){
        Editing_File *file = working_set_allocate_file(&models->working_set, &models->lifetime_allocator);
        buffer_bind_name(tctx, models, arena, &models->working_set, file, init_files[i].name);
        
        if (init_files[i].ptr != 0){
            *init_files[i].ptr = file;
        }
        
        File_Attributes attributes = {};
        file_create_from_string(tctx, models, file, SCu8(), attributes);
        if (init_files[i].read_only){
            file->settings.read_only = true;
            history_free(tctx, &file->state.history);
        }
        
        file->settings.never_kill = true;
        file_set_unimportant(file, true);
    }
    
    models->begin_buffer = begin_buffer_func;
    
    // NOTE(allen): setup first panel
    {
        Panel *panel = layout_initialize(arena, &models->layout);
        View *new_view = live_set_alloc_view(&models->lifetime_allocator, &models->view_set, panel);
        view_init(tctx, models, new_view, models->scratch_buffer, models->view_event_handler);
    }
}

App_Step_Sig(app_step){
    Models *models = (Models*)base_ptr;
    
    Mutex_Lock file_order_lock(models->working_set.mutex);
    Scratch_Block scratch(tctx);
    
    models->next_animate_delay = max_u32;
    models->animate_next_frame = false;
    
    // NOTE(allen): per-frame update of models state
    begin_frame(target, &models->font_set);
    models->target = target;
    models->input = input;
    
    // NOTE(allen): OS clipboard event handling
    if (input->clipboard.str != 0){
        co_send_core_event(tctx, models, CoreCode_NewClipboardContents, input->clipboard);
    }
    
    // NOTE(allen): reorganizing panels on screen
    Vec2_i32 prev_dim = layout_get_root_size(&models->layout);
    Vec2_i32 current_dim = V2i32(target->width, target->height);
    layout_set_root_size(&models->layout, current_dim);
    
    // NOTE(allen): update child processes
    f32 dt = input->dt;
    if (dt > 0){
        Temp_Memory_Block temp(scratch);
        
        Child_Process_Container *child_processes = &models->child_processes;
        Child_Process **processes_to_free = push_array(scratch, Child_Process*, child_processes->active_child_process_count);
        i32 processes_to_free_count = 0;
        
        u32 max = KB(128);
        char *dest = push_array(scratch, char, max);
        
        for (Node *node = child_processes->child_process_active_list.next;
             node != &child_processes->child_process_active_list;
             node = node->next){
            Child_Process *child_process = CastFromMember(Child_Process, node, node);
            
            Editing_File *file = child_process->out_file;
            CLI_Handles *cli = &child_process->cli;
            
            // TODO(allen): do(call a 'child process updated hook' let that hook populate the buffer if it so chooses)
            
            b32 edited_file = false;
            u32 amount = 0;
            system_cli_begin_update(cli);
            if (system_cli_update_step(cli, dest, max, &amount)){
                if (file != 0 && amount > 0){
                    output_file_append(tctx, models, file, SCu8(dest, amount));
                    edited_file = true;
                }
            }
            
            if (system_cli_end_update(cli)){
                if (file != 0){
                    String_Const_u8 str = push_u8_stringf(scratch, "exited with code %d", cli->exit);
                    output_file_append(tctx, models, file, str);
                    edited_file = true;
                }
                processes_to_free[processes_to_free_count++] = child_process;
                child_process_set_return_code(models, child_processes, child_process->id, cli->exit);
            }
            
            if (child_process->cursor_at_end && file != 0){
                file_cursor_to_end(tctx, models, file);
            }
        }
        
        for (i32 i = 0; i < processes_to_free_count; ++i){
            child_process_free(child_processes, processes_to_free[i]->id);
        }
    }
    
    // NOTE(allen): simulated events
    Input_List input_list = input->events;
    Input_Modifier_Set modifiers = system_get_keyboard_modifiers(scratch);
    if (input->mouse.press_l){
        Input_Event event = {};
        event.kind = InputEventKind_MouseButton;
        event.mouse.code = MouseCode_Left;
        event.mouse.p = input->mouse.p;
        event.mouse.modifiers = copy_modifier_set(scratch, &modifiers);
        push_input_event(scratch, &input_list, &event);
    }
    else if (input->mouse.release_l){
        Input_Event event = {};
        event.kind = InputEventKind_MouseButtonRelease;
        event.mouse.code = MouseCode_Left;
        event.mouse.p = input->mouse.p;
        event.mouse.modifiers = copy_modifier_set(scratch, &modifiers);
        push_input_event(scratch, &input_list, &event);
    }
    if (input->mouse.press_r){
        Input_Event event = {};
        event.kind = InputEventKind_MouseButton;
        event.mouse.code = MouseCode_Right;
        event.mouse.p = input->mouse.p;
        event.mouse.modifiers = copy_modifier_set(scratch, &modifiers);
        push_input_event(scratch, &input_list, &event);
    }
    else if (input->mouse.release_r){
        Input_Event event = {};
        event.kind = InputEventKind_MouseButtonRelease;
        event.mouse.code = MouseCode_Right;
        event.mouse.p = input->mouse.p;
        event.mouse.modifiers = copy_modifier_set(scratch, &modifiers);
        push_input_event(scratch, &input_list, &event);
    }
    if (input->mouse.wheel != 0){
        Input_Event event = {};
        event.kind = InputEventKind_MouseWheel;
        event.mouse_wheel.value = (f32)(input->mouse.wheel);
        event.mouse_wheel.p = input->mouse.p;
        event.mouse_wheel.modifiers = copy_modifier_set(scratch, &modifiers);
        push_input_event(scratch, &input_list, &event);
    }
    if (input->mouse.p != models->prev_p){
        b32 was_in_window = rect_contains_point(Ri32(0, 0, prev_dim.x, prev_dim.y), models->prev_p);
        b32 is_in_window  = rect_contains_point(Ri32(0, 0, current_dim.x, current_dim.y), input->mouse.p);
        if (is_in_window || was_in_window){
            Input_Event event = {};
            event.kind = InputEventKind_MouseMove;
            event.mouse_move.p = input->mouse.p;
            event.mouse_move.modifiers = copy_modifier_set(scratch, &modifiers);
            push_input_event(scratch, &input_list, &event);
        }
    }
    if (models->animated_last_frame){
        Input_Event event = {};
        event.kind = InputEventKind_Core;
        event.core.code = CoreCode_Animate;
        push_input_event(scratch, &input_list, &event);
    }
    
    // NOTE(allen): expose layout
    Layout *layout = &models->layout;
    
    // NOTE(allen): mouse hover status
    Panel *mouse_panel = 0;
    Panel *divider_panel = 0;
    b32 mouse_in_margin = false;
    Vec2_i32 mouse = input->mouse.p;
    {
        for (Panel *panel = layout_get_first_open_panel(layout);
             panel != 0;
             panel = layout_get_next_open_panel(layout, panel)){
            if (rect_contains_point(panel->rect_full, mouse)){
                mouse_panel = panel;
                if (!rect_contains_point(panel->rect_inner, mouse)){
                    mouse_in_margin = true;
                    for (divider_panel = mouse_panel->parent;
                         divider_panel != 0;
                         divider_panel = divider_panel->parent){
                        if (rect_contains_point(divider_panel->rect_inner, mouse)){
                            break;
                        }
                    }
                }
            }
            if (mouse_panel != 0){
                break;
            }
        }
    }
    
    // NOTE(allen): First frame initialization
    if (input->first_step){
        Temp_Memory_Block temp(scratch);
        
        String_Const_u8_Array file_names = {};
        file_names.count = models->settings.init_files_count;
        file_names.vals = push_array(scratch, String_Const_u8, file_names.count);
        for (i32 i = 0; i < file_names.count; i += 1){
            file_names.vals[i] = SCu8(models->settings.init_files[i]);
        }
        
        String_Const_u8_Array flags = {};
        flags.count = models->settings.custom_flags_count;
        flags.vals = push_array(scratch, String_Const_u8, flags.count);
        for (i32 i = 0; i < flags.count; i += 1){
            flags.vals[i] = SCu8(models->settings.custom_flags[i]);
        }
        
        Input_Event event = {};
        event.kind = InputEventKind_Core;
        event.core.code = CoreCode_Startup;
        event.core.flag_strings = flags;
        event.core.file_names = file_names;
        co_send_event(tctx, models, &event);
        
        // NOTE(allen): Actually do the buffer settings for the built ins now.
        Buffer_Hook_Function *begin_buffer_func = models->begin_buffer;
        if (begin_buffer_func != 0){
            Application_Links app = {};
            app.tctx = tctx;
            app.cmd_context = models;
            begin_buffer_func(&app, models->message_buffer->id);
            begin_buffer_func(&app, models->scratch_buffer->id);
            begin_buffer_func(&app, models->log_buffer->id);
            begin_buffer_func(&app, models->keyboard_buffer->id);
        }
    }
    
    // NOTE(allen): consume event stream
    Input_Event_Node *input_node = input_list.first;
    Input_Event_Node *input_node_next = 0;
    for (;; input_node = input_node_next){
        // NOTE(allen): first handle any events coming from the view command
        // function queue
        Model_View_Command_Function cmd_func = models_pop_view_command_function(models);
        if (cmd_func.custom_func != 0){
            View *view = imp_get_view(models, cmd_func.view_id);
            if (view != 0){
                input_node_next = input_node;
                Input_Event cmd_func_event = {};
                cmd_func_event.kind = InputEventKind_CustomFunction;
                cmd_func_event.custom_func = cmd_func.custom_func;
                co_send_event(tctx, models, view, &cmd_func_event);
                continue;
            }
        }
        
        Temp_Memory_Block temp(scratch);
        Input_Event *simulated_input = 0;
        Input_Event virtual_event = models_pop_virtual_event(scratch, models);
        if (virtual_event.kind != InputEventKind_None){
            virtual_event.virtual_event = true;
            simulated_input = &virtual_event;
        }
        else{
            if (input_node == 0){
                break;
            }
            input_node_next = input_node->next;
            simulated_input = &input_node->event;
            
            if (simulated_input->kind == InputEventKind_TextInsert && simulated_input->text.blocked){
                continue;
            }
            
            // NOTE(allen): record to keyboard history
            if (simulated_input->kind == InputEventKind_KeyStroke ||
                simulated_input->kind == InputEventKind_KeyRelease ||
                simulated_input->kind == InputEventKind_TextInsert){
                Temp_Memory_Block temp_key_line(scratch);
                String_Const_u8 key_line = stringize_keyboard_event(scratch, simulated_input);
                output_file_append(tctx, models, models->keyboard_buffer, key_line);
            }
        }
        
        b32 event_was_handled = false;
        Input_Event *event = simulated_input;
        
        Panel *active_panel = layout_get_active_panel(layout);
        View *view = active_panel->view;
        Assert(view != 0);
        
        switch (models->state){
            case APP_STATE_EDIT:
            {
                typedef i32 Event_Consume_Rule;
                enum{
                    EventConsume_None,
                    EventConsume_BeginResize,
                    EventConsume_ClickChangeView,
                    EventConsume_CustomCommand,
                };
                
                Event_Consume_Rule consume_rule = EventConsume_CustomCommand;
                if (match_mouse_code(event, MouseCode_Left) && (divider_panel != 0)){
                    consume_rule = EventConsume_BeginResize;
                }
                else if (match_mouse_code(event, MouseCode_Left) &&
                         mouse_panel != 0 && mouse_panel != active_panel){
                    consume_rule = EventConsume_ClickChangeView;
                }
                
                switch (consume_rule){
                    case EventConsume_BeginResize:
                    {
                        models->state = APP_STATE_RESIZING;
                        models->resizing_intermediate_panel = divider_panel;
                        event_was_handled = true;
                    }break;
                    
                    case EventConsume_ClickChangeView:
                    {
                        // NOTE(allen): run deactivate command
                        co_send_core_event(tctx, models, view, CoreCode_ClickDeactivateView);
                        
                        layout->active_panel = mouse_panel;
                        models->animate_next_frame = true;
                        active_panel = mouse_panel;
                        view = active_panel->view;
                        
                        // NOTE(allen): run activate command
                        co_send_core_event(tctx, models, view, CoreCode_ClickActivateView);
                        
                        event_was_handled = true;
                    }break;
                    
                    case EventConsume_CustomCommand:
                    {
                        event_was_handled = co_send_event(tctx, models, view, event);
                    }break;
                }
            }break;
            
            case APP_STATE_RESIZING:
            {
                Event_Property event_flags = get_event_properties(event);
                if (HasFlag(event_flags, EventProperty_AnyKey) ||
                    match_mouse_code_release(event, MouseCode_Left)){
                    models->state = APP_STATE_EDIT;
                }
                else if (event->kind == InputEventKind_MouseMove){
                    if (input->mouse.l){
                        Panel *split = models->resizing_intermediate_panel;
                        Range_i32 limits = layout_get_limiting_range_on_split(layout, split);
                        i32 mouse_position = (split->vertical_split)?(mouse.x):(mouse.y);
                        mouse_position = clamp(limits.min, mouse_position, limits.max);
                        layout_set_split_absolute_position(layout, split, mouse_position);
                    }
                    else{
                        models->state = APP_STATE_EDIT;
                    }
                }
            }break;
        }
        
        if (event_was_handled && event->kind == InputEventKind_KeyStroke){
            for (Input_Event *dependent_text = event->key.first_dependent_text;
                 dependent_text != 0;
                 dependent_text = dependent_text->text.next_text){
                Assert(dependent_text->kind == InputEventKind_TextInsert);
                dependent_text->text.blocked = true;
            }
        }
    }
    
    linalloc_clear(&models->virtual_event_arena);
    models->free_virtual_event = 0;
    models->first_virtual_event = 0;
    models->last_virtual_event = 0;
    
    // NOTE(allen): send panel size update
    if (models->layout.panel_state_dirty){
        models->layout.panel_state_dirty = false;
        if (models->buffer_viewer_update != 0){
            Application_Links app = {};
            app.tctx = tctx;
            app.cmd_context = models;
            models->buffer_viewer_update(&app);
        }
    }
    
    // NOTE(allen): dt
    f32 literal_dt = 0.f;
    u64 now_usecond_stamp = system_now_time();
    if (!input->first_step){
        u64 elapsed_useconds = now_usecond_stamp - models->last_render_usecond_stamp;
        literal_dt = (f32)((f64)(elapsed_useconds)/1000000.f);
    }
    models->last_render_usecond_stamp = now_usecond_stamp;
    f32 animation_dt = 0.f;
    if (models->animated_last_frame){
        animation_dt = literal_dt;
    }
    
    // NOTE(allen): on the first frame there should be no scrolling
    if (input->first_step){
        for (Panel *panel = layout_get_first_open_panel(layout);
             panel != 0;
             panel = layout_get_next_open_panel(layout, panel)){
            View *view = panel->view;
            File_Edit_Positions edit_pos = view_get_edit_pos(view);
            edit_pos.scroll.position = view_normalize_buffer_point(tctx, models, view, edit_pos.scroll.target);
            block_zero_struct(&edit_pos.scroll.target);
            view_set_edit_pos(view, edit_pos);
        }
    }
    
    // NOTE(allen): hook for files reloaded
    {
        Working_Set *working_set = &models->working_set;
        Assert(working_set->has_external_mod_sentinel.next != 0);
        if (working_set->has_external_mod_sentinel.next != &working_set->has_external_mod_sentinel){
            for (Node *node = working_set->has_external_mod_sentinel.next, *next = 0;
                 node != &working_set->has_external_mod_sentinel;
                 node = next){
                next = node->next;
                Editing_File *file = CastFromMember(Editing_File, external_mod_node, node);
                dll_remove(node);
                block_zero_struct(node);
                co_send_core_event(tctx, models, CoreCode_FileExternallyModified, file->id);
            }
        }
    }
    
    // NOTE(allen): if the exit signal has been sent, run the exit hook.
    if (!models->keep_playing || input->trying_to_kill){
        co_send_core_event(tctx, models, CoreCode_TryExit);
        models->keep_playing = true;
    }
    
    // NOTE(allen): rendering
    {
        Frame_Info frame = {};
        frame.index = models->frame_counter;
        frame.literal_dt = literal_dt;
        frame.animation_dt = animation_dt;
        
        Application_Links app = {};
        app.tctx = tctx;
        app.cmd_context = models;
        
        if (models->tick != 0){
            models->tick(&app, frame);
        }
        
        begin_render_section(target, models->frame_counter, literal_dt, animation_dt);
        models->in_render_mode = true;
        
        Live_Views *live_views = &models->view_set;
        for (Node *node = layout->open_panels.next;
             node != &layout->open_panels;
             node = node->next){
            Panel *panel = CastFromMember(Panel, node, node);
            View *view = panel->view;
            View_Context_Node *ctx = view->ctx;
            if (ctx != 0){
                Render_Caller_Function *render_caller = ctx->ctx.render_caller;
                if (render_caller != 0){
                    render_caller(&app, frame, view_get_id(live_views, view));
                }
            }
        }
        
        if (models->whole_screen_render_caller != 0){
            models->whole_screen_render_caller(&app, frame);
        }
        
        models->in_render_mode = false;
        end_render_section(target);
    }
    
    // TODO(allen): This is dumb. Let's rethink view cleanup strategy.
    // NOTE(allen): wind down coroutines
    for (;;){
        Model_Wind_Down_Co *node = models->wind_down_stack;
        if (node == 0){
            break;
        }
        sll_stack_pop(models->wind_down_stack);
        Coroutine *co = node->co;
        
        for (i32 j = 0; co != 0; j += 1){
            Co_In in = {};
            in.user_input.abort = true;
            Co_Out ignore = {};
            co = co_run(tctx, models, co, &in, &ignore);
            if (j == 100){
                Application_Links app = {};
                app.tctx = tctx;
                app.cmd_context = models;
#define M "SERIOUS ERROR: coroutine wind down did not complete\n"
                print_message(&app, string_u8_litexpr(M));
#undef M
                break;
            }
        }
        
        sll_stack_push(models->free_wind_downs, node);
    }
    
    
    // NOTE(allen): flush the log
    log_flush(tctx, models);
    
    // NOTE(allen): set the app_result
    Application_Step_Result app_result = {};
    app_result.mouse_cursor_type = APP_MOUSE_CURSOR_DEFAULT;
    app_result.lctrl_lalt_is_altgr = models->settings.lctrl_lalt_is_altgr;
    
    // NOTE(allen): get new window title
    if (models->has_new_title){
        models->has_new_title = false;
        app_result.has_new_title = true;
        app_result.title_string = models->title_space;
    }
    
    // NOTE(allen): get cursor type
    if (mouse_panel != 0 && !mouse_in_margin){
        app_result.mouse_cursor_type = APP_MOUSE_CURSOR_ARROW;
    }
    else if (divider_panel != 0){
        if (divider_panel->vertical_split){
            app_result.mouse_cursor_type = APP_MOUSE_CURSOR_LEFTRIGHT;
        }
        else{
            app_result.mouse_cursor_type = APP_MOUSE_CURSOR_UPDOWN;
        }
    }
    else{
        app_result.mouse_cursor_type = APP_MOUSE_CURSOR_ARROW;
    }
    
    models->prev_mouse_panel = mouse_panel;
    app_result.lctrl_lalt_is_altgr = models->settings.lctrl_lalt_is_altgr;
    app_result.perform_kill = models->hard_exit;
    app_result.animating = models->animate_next_frame;
    if (models->animate_next_frame){
        // NOTE(allen): Silence the timer, because we're going to do another frame right away anyways.
        system_wake_up_timer_set(models->period_wakeup_timer, max_u32);
    }
    else{
        // NOTE(allen): Set the timer's wakeup period, possibly to max_u32 thus effectively silencing it.
        system_wake_up_timer_set(models->period_wakeup_timer, models->next_animate_delay);
    }
    
    // NOTE(allen): Update Frame to Frame States
    models->prev_p = input->mouse.p;
    models->animated_last_frame = app_result.animating;
    models->frame_counter += 1;
    
    // end-of-app_step
    return(app_result);
}

extern "C" App_Get_Functions_Sig(app_get_functions){
    App_Functions result = {};
    
    result.load_vtables = app_load_vtables;
    result.get_logger = app_get_logger;
    result.read_command_line = app_read_command_line;
    result.init = app_init;
    result.step = app_step;
    
    return(result);
}

// BOTTOM



// end --- 4ed.cpp --- 



// begin --- 4ed_api_check.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 06.10.2019
 *
 * Type checker that lists errors between two api parses.
 *
 */

// TOP

// begin --- 4ed_api_definition.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 03.10.2019
 *
 * System API definition types.
 *
 */

// TOP

#if !defined(FRED_API_DEFINITION_H)
#define FRED_API_DEFINITION_H

struct API_Param{
    API_Param *next;
    String_Const_u8 type_name;
    String_Const_u8 name;
};

struct API_Param_List{
    API_Param *first;
    API_Param *last;
    i32 count;
};

struct API_Call{
    API_Call *next;
    String_Const_u8 name;
    String_Const_u8 return_type;
    String_Const_u8 location_string;
    API_Param_List params;
};

typedef i32 API_Type_Structure_Kind;
enum{
    APITypeStructureKind_Struct,
    APITypeStructureKind_Union,
};
struct API_Type_Structure{
    API_Type_Structure_Kind kind;
    List_String_Const_u8 member_names;
    String_Const_u8 definition_string;
};

struct API_Enum_Value{
    API_Enum_Value *next;
    String_Const_u8 name;
    String_Const_u8 val;
};
struct API_Type_Enum{
    String_Const_u8 type_name;
    API_Enum_Value *first_val;
    API_Enum_Value *last_val;
    i32 val_count;
};

struct API_Type_Typedef{
    String_Const_u8 name;
    String_Const_u8 definition_text;
};

typedef i32 API_Type_Kind;
enum{
    APITypeKind_Structure,
    APITypeKind_Enum,
    APITypeKind_Typedef,
};
struct API_Type{
    API_Type *next;
    API_Type_Kind kind;
    String_Const_u8 name;
    String_Const_u8 location_string;
    union{
        API_Type_Structure struct_type;
        API_Type_Enum enum_type;
        API_Type_Typedef typedef_type;
    };
};

struct API_Definition{
    API_Definition *next;
    
    API_Call *first_call;
    API_Call *last_call;
    i32 call_count;
    
    API_Type *first_type;
    API_Type *last_type;
    i32 type_count;
    
    String_Const_u8 name;
};

struct API_Definition_List{
    API_Definition *first;
    API_Definition *last;
    i32 count;
};

typedef u32 API_Generation_Flag;
enum{
    APIGeneration_NoAPINameOnCallables = 1,
};

typedef u32 API_Check_Flag;
enum{
    APICheck_ReportMissingAPI = 1,
    APICheck_ReportExtraAPI = 2,
    APICheck_ReportMismatchAPI = 4,
};
enum{
    APICheck_ReportAll = APICheck_ReportMissingAPI|APICheck_ReportExtraAPI|APICheck_ReportMismatchAPI,
};

#endif

// BOTTOM



// end --- 4ed_api_definition.h --- 



// begin --- 4ed_api_definition.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 03.10.2019
 *
 * System API definition program.
 *
 */

// TOP

function API_Definition*
begin_api(Arena *arena, char *name){
    API_Definition *api = push_array_zero(arena, API_Definition, 1);
    api->name = SCu8(name);
    return(api);
}

function API_Call*
api_call_with_location(Arena *arena, API_Definition *api, String_Const_u8 name, String_Const_u8 type, String_Const_u8 location){
    API_Call *call = push_array_zero(arena, API_Call, 1);
    sll_queue_push(api->first_call, api->last_call, call);
    api->call_count += 1;
    call->name = name;
    call->return_type = type;
    call->location_string = location;
    return(call);
}

function API_Call*
api_call_with_location(Arena *arena, API_Definition *api, char *name, char *type, char *location){
    return(api_call_with_location(arena, api, SCu8(name), SCu8(type), SCu8(location)));
}

function API_Type*
api_type_structure_with_location(Arena *arena, API_Definition *api, API_Type_Structure_Kind kind, String_Const_u8 name, List_String_Const_u8 member_list, String_Const_u8 definition, String_Const_u8 location){
    API_Type *type = push_array_zero(arena, API_Type, 1);
    sll_queue_push(api->first_type, api->last_type, type);
    api->type_count += 1;
    type->kind = APITypeKind_Structure;
    type->name = name;
    type->location_string = location;
    type->struct_type.kind = kind;
    type->struct_type.member_names = member_list;
    type->struct_type.definition_string = definition;
    return(type);
}

function API_Type*
api_type_structure_with_location(Arena *arena, API_Definition *api, API_Type_Structure_Kind kind, char *name, List_String_Const_u8 member_list, char *definition, char *location){
    return(api_type_structure_with_location(arena, api, kind, name, member_list, definition, location));
}

#define api_call(arena, api, name, type) \
api_call_with_location((arena), (api), (name), (type), file_name_line_number)

function API_Param*
api_param(Arena *arena, API_Call *call, char *type_name, char *name){
    API_Param *param = push_array_zero(arena, API_Param, 1);
    sll_queue_push(call->params.first, call->params.last, param);
    call->params.count += 1;
    param->type_name = SCu8(type_name);
    param->name = SCu8(name);
    return(param);
}

function void
api_set_param_list(API_Call *call, API_Param_List list){
    call->params = list;
}

function API_Definition*
api_get_api(API_Definition_List *list, String_Const_u8 name){
    API_Definition *result = 0;
    for (API_Definition *node = list->first;
         node != 0;
         node = node->next){
        if (string_match(name, node->name)){
            result = node;
            break;
        }
    }
    return(result);
}

function API_Definition*
api_get_api(Arena *arena, API_Definition_List *list, String_Const_u8 name){
    API_Definition *result = api_get_api(list, name);
    if (result == 0){
        result = push_array_zero(arena, API_Definition, 1);
        sll_queue_push(list->first, list->last, result);
        list->count += 1;
        result->name = name;
    }
    return(result);
}

function API_Call*
api_get_call(API_Definition *api, String_Const_u8 name){
    API_Call *result = 0;
    for (API_Call *call = api->first_call;
         call != 0;
         call = call->next){
        if (string_match(name, call->name)){
            result = call;
            break;
        }
    }
    return(result);
}

function b32
api_call_match_sigs(API_Call *a, API_Call *b){
    b32 result = false;
    if (a->params.count == b->params.count &&
        string_match(a->return_type, b->return_type)){
        result = true;
        for (API_Param *a_param = a->params.first, *b_param = b->params.first;
             a_param != 0 && b_param != 0;
             a_param = a_param->next, b_param = b_param->next){
            if (!string_match(a_param->name, b_param->name) ||
                !string_match(a_param->type_name, b_param->type_name)){
                result = false;
                break;
            }
        }
    }
    return(result);
}

function API_Type*
api_get_type(API_Definition *api, String_Const_u8 name){
    API_Type *result = 0;
    for (API_Type *type = api->first_type;
         type != 0;
         type = type->next){
        if (string_match(type->name, name)){
            result = type;
            break;
        }
    }
    return(result);
}

function b32
api_type_match(API_Type *a, API_Type *b){
    b32 result = false;
    if (a->kind == b->kind && string_match(a->name, b->name)){
        switch (a->kind){
            case APITypeKind_Structure:
            {
                if (a->kind == b->kind &&
                    string_list_match(a->struct_type.member_names, b->struct_type.member_names) &&
                    string_match(a->struct_type.definition_string, b->struct_type.definition_string)){
                    result = true;
                }
            }break;
            
            case APITypeKind_Enum:
            {
                if (a->enum_type.val_count == b->enum_type.val_count &&
                    string_match(a->enum_type.type_name, b->enum_type.type_name)){
                    result = true;
                    for (API_Enum_Value *a_node = a->enum_type.first_val, *b_node = b->enum_type.first_val;
                         a_node != 0 && b_node != 0;
                         a_node = a_node->next, b_node = b_node->next){
                        if (!string_match(a_node->name, b_node->name) ||
                            !string_match(a_node->val, b_node->val)){
                            result = false;
                            break;
                        }
                    }
                }
            }break;
            
            case APITypeKind_Typedef:
            {
                if (string_match(a->typedef_type.name, b->typedef_type.name) &&
                    string_match(a->typedef_type.definition_text, b->typedef_type.definition_text)){
                    result = false;
                }
            }break;
        }
    }
    return(result);
}

////////////////////////////////

#if !defined(SKIP_STDIO)
#include <stdio.h>

function String_Const_u8
api_get_callable_name(Arena *arena, String_Const_u8 api_name, String_Const_u8 name, API_Generation_Flag flags){
    String_Const_u8 result = {};
    if (HasFlag(flags, APIGeneration_NoAPINameOnCallables)){
        result = push_u8_stringf(arena, "%.*s", string_expand(name));
    }
    else{
        result = push_u8_stringf(arena, "%.*s_%.*s",
                                 string_expand(api_name),
                                 string_expand(name));
    }
    return(result);
}

////////////////////////////////

function void
generate_api_master_list(Arena *scratch, API_Definition *api, API_Generation_Flag flags, FILE *out){
    for (API_Call *call = api->first_call;
         call != 0;
         call = call->next){
        fprintf(out, "api(%.*s) function %.*s %.*s(",
                string_expand(api->name),
                string_expand(call->return_type),
                string_expand(call->name));
        if (call->params.count == 0){
            fprintf(out, "void");
        }
        else{
            for (API_Param *param = call->params.first;
                 param != 0;
                 param = param->next){
                fprintf(out, "%.*s %.*s",
                        string_expand(param->type_name),
                        string_expand(param->name));
                if (param->next != 0){
                    fprintf(out, ", ");
                }
            }
        }
        fprintf(out, ");\n");
    }
}

function void
generate_header(Arena *scratch, API_Definition *api, API_Generation_Flag flags, FILE *out){
    for (API_Call *call = api->first_call;
         call != 0;
         call = call->next){
        fprintf(out, "#define %.*s_%.*s_sig() %.*s %.*s_%.*s(",
                string_expand(api->name),
                string_expand(call->name),
                string_expand(call->return_type),
                string_expand(api->name),
                string_expand(call->name));
        if (call->params.count == 0){
            fprintf(out, "void");
        }
        else{
            for (API_Param *param = call->params.first;
                 param != 0;
                 param = param->next){
                fprintf(out, "%.*s %.*s",
                        string_expand(param->type_name),
                        string_expand(param->name));
                if (param->next != 0){
                    fprintf(out, ", ");
                }
            }
        }
        fprintf(out, ")\n");
    }
    
    for (API_Call *call = api->first_call;
         call != 0;
         call = call->next){
        fprintf(out, "typedef %.*s %.*s_%.*s_type(",
                string_expand(call->return_type),
                string_expand(api->name),
                string_expand(call->name));
        if (call->params.count == 0){
            fprintf(out, "void");
        }
        else{
            for (API_Param *param = call->params.first;
                 param != 0;
                 param = param->next){
                fprintf(out, "%.*s %.*s",
                        string_expand(param->type_name),
                        string_expand(param->name));
                if (param->next != 0){
                    fprintf(out, ", ");
                }
            }
        }
        fprintf(out, ");\n");
    }
    
    fprintf(out, "struct API_VTable_%.*s{\n", string_expand(api->name));
    for (API_Call *call = api->first_call;
         call != 0;
         call = call->next){
        fprintf(out, "%.*s_%.*s_type *",
                string_expand(api->name),
                string_expand(call->name));
        fprintf(out, "%.*s",
                string_expand(call->name));
        fprintf(out, ";\n");
    }
    fprintf(out, "};\n");
    
    fprintf(out, "#if defined(STATIC_LINK_API)\n");
    for (API_Call *call = api->first_call;
         call != 0;
         call = call->next){
        String_Const_u8 callable_name = api_get_callable_name(scratch, api->name, call->name, flags);
        fprintf(out, "internal %.*s %.*s(",
                string_expand(call->return_type),
                string_expand(callable_name));
        if (call->params.count == 0){
            fprintf(out, "void");
        }
        else{
            for (API_Param *param = call->params.first;
                 param != 0;
                 param = param->next){
                fprintf(out, "%.*s %.*s",
                        string_expand(param->type_name),
                        string_expand(param->name));
                if (param->next != 0){
                    fprintf(out, ", ");
                }
            }
        }
        fprintf(out, ");\n");
    }
    fprintf(out, "#undef STATIC_LINK_API\n");
    fprintf(out, "#elif defined(DYNAMIC_LINK_API)\n");
    for (API_Call *call = api->first_call;
         call != 0;
         call = call->next){
        String_Const_u8 callable_name = api_get_callable_name(scratch, api->name, call->name, flags);
        fprintf(out, "global %.*s_%.*s_type *%.*s = 0;\n",
                string_expand(api->name),
                string_expand(call->name),
                string_expand(callable_name));
    }
    fprintf(out, "#undef DYNAMIC_LINK_API\n");
    fprintf(out, "#endif\n");
}

function void
generate_cpp(Arena *scratch, API_Definition *api, API_Generation_Flag flags, FILE *out){
    fprintf(out, "function void\n");
    fprintf(out, "%.*s_api_fill_vtable(API_VTable_%.*s *vtable){\n",
            string_expand(api->name),
            string_expand(api->name));
    for (API_Call *call = api->first_call;
         call != 0;
         call = call->next){
        String_Const_u8 callable_name = api_get_callable_name(scratch, api->name, call->name, flags);
        fprintf(out, "vtable->%.*s = %.*s;\n",
                string_expand(call->name),
                string_expand(callable_name));
    }
    fprintf(out, "}\n");
    
    fprintf(out, "#if defined(DYNAMIC_LINK_API)\n");
    fprintf(out, "function void\n");
    fprintf(out, "%.*s_api_read_vtable(API_VTable_%.*s *vtable){\n",
            string_expand(api->name),
            string_expand(api->name));
    for (API_Call *call = api->first_call;
         call != 0;
         call = call->next){
        String_Const_u8 callable_name = api_get_callable_name(scratch, api->name, call->name, flags);
        fprintf(out, "%.*s = vtable->%.*s;\n",
                string_expand(callable_name),
                string_expand(call->name));
    }
    fprintf(out, "}\n");
    fprintf(out, "#undef DYNAMIC_LINK_API\n");
    fprintf(out, "#endif\n");
}

function void
generate_constructor(Arena *scratch, API_Definition *api, API_Generation_Flag flags, FILE *out){
    fprintf(out, "function API_Definition*\n");
    fprintf(out, "%.*s_api_construct(Arena *arena){\n",
            string_expand(api->name));
    fprintf(out, "API_Definition *result = begin_api(arena, \"%.*s\");\n",
            string_expand(api->name));
    
    for (API_Call *call = api->first_call;
         call != 0;
         call = call->next){
        fprintf(out, "{\n");
        fprintf(out, "API_Call *call = api_call_with_location(arena, result, "
                "string_u8_litexpr(\"%.*s\"), "
                "string_u8_litexpr(\"%.*s\"), "
                "string_u8_litexpr(\"\"));\n",
                string_expand(call->name),
                string_expand(call->return_type));
        
        if (call->params.count == 0){
            fprintf(out, "(void)call;\n");
        }
        else{
            for (API_Param *param = call->params.first;
                 param != 0;
                 param = param->next){
                fprintf(out, "api_param(arena, call, \"%.*s\", \"%.*s\");\n",
                        string_expand(param->type_name),
                        string_expand(param->name));
            }
        }
        
        fprintf(out, "}\n");
    }
    
    fprintf(out, "return(result);\n");
    fprintf(out, "}\n");
}

////////////////////////////////

function b32
api_definition_generate_api_includes(Arena *arena, API_Definition *api, Generated_Group group, API_Generation_Flag flags){
    // NOTE(allen): Arrange output files
    
    String_Const_u8 path_to_self = string_u8_litexpr(__FILE__);
    path_to_self = string_remove_last_folder(path_to_self);
    
    String_Const_u8 fname_ml = {};
    String_Const_u8 fname_h = {};
    String_Const_u8 fname_cpp = {};
    String_Const_u8 fname_con = {};
    
    String_Const_u8 root = {};
    switch (group){
        case GeneratedGroup_Core:
        {
            root = string_u8_litexpr("generated/");
        }break;
        case GeneratedGroup_Custom:
        {
            root = string_u8_litexpr("custom/generated/");
        }break;
    }
    
    fname_ml = push_u8_stringf(arena, "%.*s%.*s%.*s_api_master_list.h",
                               string_expand(path_to_self),
                               string_expand(root),
                               string_expand(api->name));
    
    fname_h = push_u8_stringf(arena, "%.*s%.*s%.*s_api.h",
                              string_expand(path_to_self),
                              string_expand(root),
                              string_expand(api->name));
    
    fname_cpp = push_u8_stringf(arena, "%.*s%.*s%.*s_api.cpp",
                                string_expand(path_to_self),
                                string_expand(root),
                                string_expand(api->name));
    
    fname_con = push_u8_stringf(arena, "%.*s%.*s%.*s_api_constructor.cpp",
                                string_expand(path_to_self),
                                string_expand(root),
                                string_expand(api->name));
    
    FILE *out_file_ml = fopen((char*)fname_ml.str, "wb");
    if (out_file_ml == 0){
        printf("could not open output file: '%s'\n", fname_ml.str);
        return(false);
    }
    
    FILE *out_file_h = fopen((char*)fname_h.str, "wb");
    if (out_file_h == 0){
        printf("could not open output file: '%s'\n", fname_h.str);
        return(false);
    }
    
    FILE *out_file_cpp = fopen((char*)fname_cpp.str, "wb");
    if (out_file_cpp == 0){
        printf("could not open output file: '%s'\n", fname_cpp.str);
        return(false);
    }
    
    FILE *out_file_con = fopen((char*)fname_con.str, "wb");
    if (out_file_cpp == 0){
        printf("could not open output file: '%s'\n", fname_con.str);
        return(false);
    }
    
    printf("%s:1:\n", fname_ml.str);
    printf("%s:1:\n", fname_h.str);
    printf("%s:1:\n", fname_cpp.str);
    printf("%s:1:\n", fname_con.str);
    
    ////////////////////////////////
    
    // NOTE(allen): Generate output
    
    generate_api_master_list(arena, api, flags, out_file_ml);
    generate_header(arena, api, flags, out_file_h);
    generate_cpp(arena, api, flags, out_file_cpp);
    generate_constructor(arena, api, flags, out_file_con);
    
    ////////////////////////////////
    
    fclose(out_file_ml);
    fclose(out_file_h);
    fclose(out_file_cpp);
    return(true);
}

////////////////////////////////

function void
api_definition_error(Arena *arena, List_String_Const_u8 *list,
                     char *e1, API_Call *c1, char *e2, API_Call *c2){
    Assert(e1 != 0);
    Assert(c1 != 0);
    string_list_pushf(arena, list,
                      "%.*s error: %s '%.*s'",
                      string_expand(c1->location_string),
                      e1, string_expand(c1->name));
    if (e2 != 0){
        string_list_pushf(arena, list, " %s", e2);
        if (c2 != 0){
            string_list_pushf(arena, list, " '%.*s'", string_expand(c2->name));
        }
    }
    string_list_push(arena, list, string_u8_litexpr("\n"));
    if (c2 != 0){
        string_list_push(arena, list, c2->location_string);
        string_list_pushf(arena, list, " note: see declaration of '%.*s'\n", string_expand(c2->name));
    }
}

function void
api_definition_error(Arena *arena, List_String_Const_u8 *list,
                     char *e1, API_Call *c1, char *e2){
    api_definition_error(arena, list, e1, c1, e2, 0);
}

function void
api_definition_error(Arena *arena, List_String_Const_u8 *list,
                     char *e1, API_Call *c1){
    api_definition_error(arena, list, e1, c1, 0, 0);
}

function void
api_definition_error(Arena *arena, List_String_Const_u8 *list,
                     char *e1, API_Definition *api1, char *e2){
    Assert(e1 != 0);
    Assert(api1 != 0);
    string_list_pushf(arena, list, "error: %s '%.*s'",
                      e1, string_expand(api1->name));
    if (e2 != 0){
        string_list_pushf(arena, list, " %s", e2);
    }
    string_list_push(arena, list, string_u8_litexpr("\n"));
}

function void
api_definition_error(Arena *arena, List_String_Const_u8 *list,
                     char *e1, API_Definition *api1){
    api_definition_error(arena, list, e1, api1, 0);
}

function void
api_definition_check(Arena *arena, API_Definition *correct, API_Definition *remote, API_Check_Flag flags, List_String_Const_u8 *error_list){
    b32 report_missing = HasFlag(flags, APICheck_ReportMissingAPI);
    b32 report_extra = HasFlag(flags, APICheck_ReportExtraAPI);
    b32 report_mismatch = HasFlag(flags, APICheck_ReportMismatchAPI);
    
    b32 iterate_correct = (report_missing || report_mismatch);
    if (iterate_correct){
        for (API_Call *call = correct->first_call;
             call != 0;
             call = call->next){
            API_Call *remote_call = api_get_call(remote, call->name);
            if (remote_call == 0 && report_missing){
                api_definition_error(arena, error_list,
                                     "no remote call for", call);
            }
            if (remote_call != 0 && !api_call_match_sigs(call, remote_call) && report_mismatch){
                api_definition_error(arena, error_list,
                                     "remote call", remote_call,
                                     "does not match signature for", call);
            }
        }
    }
    
    b32 iterate_remote = (report_extra);
    if (iterate_remote){
        for (API_Call *call = remote->first_call;
             call != 0;
             call = call->next){
            API_Call *correct_call = api_get_call(correct, call->name);
            if (correct_call == 0 && report_extra){
                api_definition_error(arena, error_list,
                                     "remote call", call, 
                                     "does not exist in api master");
            }
        }
    }
}

function void
api_list_check(Arena *arena, API_Definition_List *correct, API_Definition_List *remote, API_Check_Flag flags, List_String_Const_u8 *error_list){
    b32 report_missing = HasFlag(flags, APICheck_ReportMissingAPI);
    b32 report_extra = HasFlag(flags, APICheck_ReportExtraAPI);
    
    b32 iterate_correct = (report_missing);
    if (iterate_correct){
        for (API_Definition *api = correct->first;
             api != 0;
             api = api->next){
            API_Definition *remote_api = api_get_api(remote, api->name);
            if (remote_api == 0 && report_missing){
                api_definition_error(arena, error_list,
                                     "no remote api for", api);
            }
        }
    }
    
    b32 iterate_remote = (report_extra);
    if (iterate_remote){
        for (API_Definition *api = remote->first;
             api != 0;
             api = api->next){
            API_Definition *correct_api = api_get_api(correct, api->name);
            if (correct_api == 0 && report_extra){
                api_definition_error(arena, error_list,
                                     "remote api", api,
                                     "does not have a master");
            }
        }
    }
    
    for (API_Definition *api = correct->first;
         api != 0;
         api = api->next){
        API_Definition *remote_api = api_get_api(remote, api->name);
        if (remote_api != 0){
            api_definition_check(arena, api, remote_api, flags, error_list);
        }
    }
}

#endif

// BOTTOM



// end --- 4ed_api_definition.cpp --- 



// begin --- 4ed_api_parser.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 03.10.2019
 *
 * Parser that extracts an API from C++ source code.
 *
 */

// TOP

/*
function:
api ( <identifier> ) function <identifier> {*} <identifier> ( <param_list> )

param_list:
void |
<identifier> {*} <identifier> [, <identifier> {*} <identifier>]

anything_else:
***

api_source:
{function|anything_else} EOF
*/

function Token*
api_parse__token_pos(Token_Iterator *it){
    return(token_it_read(it));
}

function b32
api_parse__match(Token_Iterator *it, Token_Cpp_Kind sub_kind){
    b32 match = false;
    Token *token = token_it_read(it);
    if (token != 0 && token->sub_kind == sub_kind){
        if (token_it_inc(it)){
            match = true;
        }
    }
    return(match);
}

function b32
api_parse__match_identifier(Token_Iterator *it, String_Const_u8 source, String_Const_u8 *lexeme){
    b32 match = false;
    Token *token = token_it_read(it);
    if (token->kind == TokenBaseKind_Identifier ||
        token->kind == TokenBaseKind_Keyword){
        if (token_it_inc(it)){
            *lexeme = string_substring(source, Ii64(token));
            match = true;
        }
    }
    return(match);
}

function b32
api_parse__match_identifier(Token_Iterator *it, String_Const_u8 source, char *lexeme){
    b32 match = false;
    Token *token = token_it_read(it);
    if ((token->kind == TokenBaseKind_Identifier ||
         token->kind == TokenBaseKind_Keyword) &&
        string_match(SCu8(lexeme), string_substring(source, Ii64(token)))){
        if (token_it_inc(it)){
            match = true;
        }
    }
    return(match);
}

function String_Const_u8
api_parse__type_name_with_stars(Arena *arena, String_Const_u8 type, i32 star_counter){
    if (star_counter > 0){
        i32 type_full_size = (i32)(type.size) + star_counter;
        u8 *type_buffer = push_array(arena, u8, type_full_size + 1);
        block_copy(type_buffer, type.str, type.size);
        block_fill_u8(type_buffer + type.size, star_counter, (u8)'*');
        type_buffer[type_full_size] = 0;
        type = SCu8(type_buffer, type_full_size);
    }
    return(type);
}

function void
api_parse_add_param(Arena *arena, API_Param_List *list, String_Const_u8 type, i32 star_counter, String_Const_u8 name){
    type = api_parse__type_name_with_stars(arena, type, star_counter);
    API_Param *param = push_array(arena, API_Param, 1);
    sll_queue_push(list->first, list->last, param);
    list->count += 1;
    param->type_name = type;
    param->name = name;
}

function void
api_parse_add_function(Arena *arena, API_Definition_List *list,
                       String_Const_u8 api_name, String_Const_u8 func_name,
                       String_Const_u8 type, i32 star_counter, API_Param_List param_list,
                       String_Const_u8 location){
    API_Definition *api = api_get_api(arena, list, api_name);
    type = api_parse__type_name_with_stars(arena, type, star_counter);
    API_Call *call = api_call_with_location(arena, api, func_name, type, location);
    api_set_param_list(call, param_list);
}

function void
api_parse_add_structure(Arena *arena, API_Definition_List *list,
                        String_Const_u8 api_name, API_Type_Structure_Kind kind,
                        String_Const_u8 name, List_String_Const_u8 member_list,
                        String_Const_u8 definition, String_Const_u8 location){
    API_Definition *api = api_get_api(arena, list, api_name);
       api_type_structure_with_location(arena, api, kind, name, member_list, definition, location);
}

function String_Const_u8
api_parse_location(Arena *arena, String_Const_u8 source_name, String_Const_u8 source, u8 *pos){
    i32 line_number = 1;
    i32 col_number = 1;
    if (source.str <= pos && pos < source.str + source.size){
        for (u8 *ptr = source.str;;){
            if (ptr == pos){
                break;
            }
            if (*ptr == '\n'){
                line_number += 1;
                col_number = 1;
            }
            else{
                col_number += 1;
            }
            ptr += 1;
        }
    }
    return(push_u8_stringf(arena, "%.*s:%d:%d:", string_expand(source_name), line_number, col_number));
}

function b32
api_parse_source__function(Arena *arena, String_Const_u8 source_name, String_Const_u8 source, Token_Iterator *token_it, String_Const_u8 api_name, API_Definition_List *list){
    b32 result = false;
    String_Const_u8 ret_type = {};
    i32 ret_type_star_counter = 0;
    String_Const_u8 func_name = {};
    API_Param_List param_list = {};
    if (api_parse__match_identifier(token_it, source, &ret_type)){
        for (;api_parse__match(token_it, TokenCppKind_Star);){
            ret_type_star_counter += 1;
        }
        if (api_parse__match_identifier(token_it, source, &func_name)){
            if (api_parse__match(token_it, TokenCppKind_ParenOp)){
                b32 param_list_success = false;
                if (api_parse__match_identifier(token_it, source, "void")){
                    param_list_success = true;
                }
                else{
                    for (;;){
                        String_Const_u8 type = {};
                        i32 star_counter = 0;
                        String_Const_u8 name = {};
                        if (api_parse__match_identifier(token_it, source, &type)){
                            for (;api_parse__match(token_it, TokenCppKind_Star);){
                                star_counter += 1;
                            }
                            if (api_parse__match_identifier(token_it, source, &name)){
                                param_list_success = true;
                            }
                            else{
                                break;
                            }
                        }
                        else{
                            break;
                        }
                        if (param_list_success){
                            api_parse_add_param(arena, &param_list, type, star_counter, name);
                        }
                        if (api_parse__match(token_it, TokenCppKind_Comma)){
                            param_list_success = false;
                        }
                        else{
                            break;
                        }
                    }
                }
                if (param_list_success){
                    if (api_parse__match(token_it, TokenCppKind_ParenCl)){
                         result = true;
                    }
                }
            }
        }
    }
    if (result){
        String_Const_u8 location = api_parse_location(arena, source_name, source, func_name.str);
        api_parse_add_function(arena, list, api_name, func_name, ret_type, ret_type_star_counter, param_list, location);
    }
    return(result);
}

function String_Const_u8
api_parse__restringize_token_range(Arena *arena, String_Const_u8 source, Token *token, Token *token_end){
    List_String_Const_u8 list = {};
    for (Token *t = token; t < token_end; t += 1){
        if (t->kind == TokenBaseKind_Comment){
            continue;
        }
        if (t->kind == TokenBaseKind_Whitespace){
            // TODO(allen): if there is a newline, emit it, all other whitespace is managed automatically.
            continue;
        }
        
        String_Const_u8 str = string_substring(source, Ii64(t));
        string_list_push(arena, &list, str);
    }
    return(string_list_flatten(arena, list));
}

function b32
api_parse_source__structure(Arena *arena, String_Const_u8 source_name, String_Const_u8 source, API_Type_Structure_Kind kind, Token_Iterator *token_it, String_Const_u8 api_name, API_Definition_List *list){
    b32 result = false;
    String_Const_u8 name = {};
    List_String_Const_u8 member_list = {};
    Token *token = api_parse__token_pos(token_it);
    (void)token;
    if (api_parse__match_identifier(token_it, source, &name)){
        if (api_parse__match(token_it, TokenCppKind_Semicolon)){
            result = true;
        }
        else if (api_parse__match(token_it, TokenCppKind_BraceOp)){
                b32 member_list_success = false;
            for (;;){
                String_Const_u8 member_name = {};
                if (api_parse__match(token_it, TokenCppKind_BraceCl)){
                    member_list_success = true;
                    break;
                }
                else if (api_parse__match_identifier(token_it, source, &member_name)){
                    if (api_parse__match(token_it, TokenCppKind_Semicolon)){
                        string_list_push(arena, &member_list, member_name);
                    }
                }
                else{
                    if (!token_it_inc(token_it)){
                        break;
                    }
                }
            }
            if (member_list_success){
                if (api_parse__match(token_it, TokenCppKind_BraceCl)){
                    if (api_parse__match(token_it, TokenCppKind_Semicolon)){
                        result = true;
                    }
                    }
                }
            }
    }
    if (result){
        Token *token_end = api_parse__token_pos(token_it);
        (void)token_end;
        // TODO(allen): 
        String_Const_u8 definition = {};
        String_Const_u8 location = api_parse_location(arena, source_name, source, name.str);
        api_parse_add_structure(arena, list, api_name, kind, name, member_list, definition, location);
    }
    return(result);
}

function b32
api_parse_source__struct(Arena *arena, String_Const_u8 source_name, String_Const_u8 source, Token_Iterator *token_it, String_Const_u8 api_name, API_Definition_List *list){
    return(api_parse_source__structure(arena, source_name, source, APITypeStructureKind_Struct, token_it, api_name, list));
}

function b32
api_parse_source__union(Arena *arena, String_Const_u8 source_name, String_Const_u8 source, Token_Iterator *token_it, String_Const_u8 api_name, API_Definition_List *list){
    return(api_parse_source__structure(arena, source_name, source, APITypeStructureKind_Union, token_it, api_name, list));
}

function void
api_parse_source_add_to_list(Arena *arena, String_Const_u8 source_name, String_Const_u8 source, API_Definition_List *list){
    Token_List token_list = lex_full_input_cpp(arena, source);
    Token_Iterator token_it = token_iterator(token_iterator(0, &token_list));
    
    for (;;){
        Token *token = token_it_read(&token_it);
        if (token->sub_kind == TokenCppKind_EOF){
            break;
        }
        
        if (api_parse__match_identifier(&token_it, source, "api")){
            String_Const_u8 api_name = {};
            if (api_parse__match(&token_it, TokenCppKind_ParenOp)){
                if (api_parse__match_identifier(&token_it, source, &api_name)){
                    if (api_parse__match(&token_it, TokenCppKind_ParenCl)){
                        if (api_parse__match_identifier(&token_it, source, "function")){
                            api_parse_source__function(arena, source_name, source, &token_it, api_name, list);
                        }
                        else if (api_parse__match_identifier(&token_it, source, "struct")){
                            api_parse_source__struct(arena, source_name, source, &token_it, api_name, list);
                        }
                        else if (api_parse__match_identifier(&token_it, source, "union")){
                            api_parse_source__union(arena, source_name, source, &token_it, api_name, list);
                        }
                        }
                }
            }
        }
        else{
            if (!token_it_inc(&token_it)){
                break;
            }
        }
    }
}

function API_Definition_List
api_parse_source(Arena *arena, String_Const_u8 source_name, String_Const_u8 source){
    API_Definition_List list = {};
    api_parse_source_add_to_list(arena, source_name, source, &list);
    return(list);
}

// BOTTOM



// end --- 4ed_api_parser.cpp --- 



#include <stdio.h>

////////////////////////////////

function void
print_usage(void){
    printf("usage: <script> <source-1> {<source-1>} : <source-2> {<source-2>}\n"
           " source-1 : the authoritative/master api source file(s)\n"
           " source-2 : the 'remote' api source file(s) to check against the master\n");
    exit(1);
}

int
main(int argc, char **argv){
    Arena arena = make_arena_malloc();
    
    if (argc < 4){
        print_usage();
    }
    
    API_Definition_List master_list = {};
    API_Definition_List remote_list = {};
    
    {
        i32 i = 1;
        for (;i < argc; i += 1){
            char *file_name = argv[i];
            if (string_match(SCu8(file_name), string_u8_litexpr(":"))){
                i += 1;
                break;
            }
            FILE *file = fopen(file_name, "rb");
            if (file == 0){
                printf("error: could not open input file: '%s'\n", file_name);
                continue;
            }
            String_Const_u8 text = data_from_file(&arena, file);
            fclose(file);
            if (text.size > 0){
                api_parse_source_add_to_list(&arena, SCu8(file_name), text, &master_list);
            }
        }
        for (;i < argc; i += 1){
            char *file_name = argv[i];
            FILE *file = fopen(file_name, "rb");
            if (file == 0){
                printf("error: could not open input file: '%s'\n", file_name);
                continue;
            }
            String_Const_u8 text = data_from_file(&arena, file);
            fclose(file);
            if (text.size > 0){
                api_parse_source_add_to_list(&arena, SCu8(file_name), text, &remote_list);
            }
        }
    }
    
    if (master_list.count == 0){
        printf("error: no apis in master list\n");
        exit(1);
    }
    
    if (remote_list.count == 0){
        printf("error: no apis in remote list\n");
        exit(1);
    }
    
    List_String_Const_u8 errors = {};
    api_list_check(&arena, &master_list, &remote_list, APICheck_ReportAll, &errors);
    String_Const_u8 string = string_list_flatten(&arena, errors, StringFill_NullTerminate);
    printf("%.*s", string_expand(string));
    if (string.size > 0){
        exit(1);
    }
    
    return(0);
}

// BOTTOM


// end --- 4ed_api_check.cpp --- 



// begin --- 4ed_api_definition_main.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 02.10.2019
 *
 * System API definition program.
 *
 */

// TOP

#include <stdio.h>

////////////////////////////////

function API_Definition*
define_api(Arena *arena);

function Generated_Group
get_api_group(void);

int
main(void){
    Arena arena = make_arena_malloc();
    API_Definition *api = define_api(&arena);
    if (!api_definition_generate_api_includes(&arena, api, get_api_group(), 0)){
        return(1);
    }
    return(0);
}

// BOTTOM



// end --- 4ed_api_definition_main.cpp --- 



// begin --- 4ed_api_implementation.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * ??.??.????
 *
 * Implementation of the API functions.
 *
 */

// TOP

function void
output_file_append(Thread_Context *tctx, Models *models, Editing_File *file, String_Const_u8 value){
    i64 end = buffer_size(&file->state.buffer);
    Edit_Behaviors behaviors = {};
    behaviors.pos_before_edit = end;
    edit_single(tctx, models, file, Ii64(end), value, behaviors);
}

function void
file_cursor_to_end(Thread_Context *tctx, Models *models, Editing_File *file){
    Assert(file != 0);
    i64 pos = buffer_size(&file->state.buffer);
    Layout *layout = &models->layout;
    for (Panel *panel = layout_get_first_open_panel(layout);
         panel != 0;
         panel = layout_get_next_open_panel(layout, panel)){
        View *view = panel->view;
        if (view->file != file){
            continue;
        }
        view_set_cursor(tctx, models, view, pos);
        view->mark = pos;
    }
}

////////////////////////////////

function b32
access_test(Access_Flag object_flags, Access_Flag access_flags){
    return((object_flags & access_flags) == access_flags);
}

function b32
api_check_panel(Panel *panel){
    b32 result = false;
    if (panel != 0 && panel->kind != PanelKind_Unused){
        result = true;
    }
    return(result);
}

function b32
api_check_buffer(Editing_File *file){
    return(file != 0);
}

function b32
api_check_buffer(Editing_File *file, Access_Flag access){
    return(api_check_buffer(file) && access_test(file_get_access_flags(file), access));
}

function b32
api_check_view(View *view){
    return(view != 0 && view->in_use);
}

function b32
api_check_view(View *view, Access_Flag access){
    return(api_check_view(view) && access_test(view_get_access_flags(view), access));
}

function b32
is_running_coroutine(Application_Links *app){
    Thread_Context *tctx = app->tctx;
    Thread_Context_Extra_Info *info = (Thread_Context_Extra_Info*)tctx->user_data;
    return(info->coroutine != 0);
}

api(custom) function b32
global_set_setting(Application_Links *app, Global_Setting_ID setting, i64 value){
    Models *models = (Models*)app->cmd_context;
    b32 result = true;
    switch (setting){
        case GlobalSetting_LAltLCtrlIsAltGr:
        {
            models->settings.lctrl_lalt_is_altgr = (b32)(value != 0);
        }break;
        default:
        {
            result = false;
        }break;
    }
    return(result);
}

api(custom) function Rect_f32
global_get_screen_rectangle(Application_Links *app){
    Models *models = (Models*)app->cmd_context;
    return(Rf32(V2f32(0, 0), V2f32(layout_get_root_size(&models->layout))));
}

api(custom) function Thread_Context*
get_thread_context(Application_Links *app){
    return(app->tctx);
}

api(custom) function Child_Process_ID
create_child_process(Application_Links *app, String_Const_u8 path, String_Const_u8 command){
    Models *models = (Models*)app->cmd_context;
    Child_Process_ID result = 0;
    if (!child_process_call(app->tctx, models, path, command, &result)){
        result = 0;
    }
    return(result);
}

api(custom) function b32
child_process_set_target_buffer(Application_Links *app, Child_Process_ID child_process_id, Buffer_ID buffer_id, Child_Process_Set_Target_Flags flags){
    Models *models = (Models*)app->cmd_context;
    Child_Process *child_process = child_process_from_id(&models->child_processes, child_process_id);
    Editing_File *file = imp_get_file(models, buffer_id);
    b32 result = false;
    if (api_check_buffer(file) && child_process != 0){
        result = child_process_set_target_buffer(models, child_process, file, flags);
    }
    return(result);
}

api(custom) function Child_Process_ID
buffer_get_attached_child_process(Application_Links *app, Buffer_ID buffer_id){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    Child_Process_ID result = 0;
    if (api_check_buffer(file)){
        result = file->state.attached_child_process;
    }
    return(result);
}

api(custom) function Buffer_ID
child_process_get_attached_buffer(Application_Links *app, Child_Process_ID child_process_id){
    Models *models = (Models*)app->cmd_context;
    Child_Process *child_process = child_process_from_id(&models->child_processes, child_process_id);
    Buffer_ID result = 0;
    if (child_process != 0 && child_process->out_file != 0){
        result = child_process->out_file->id;
    }
    return(result);
}

api(custom) function Process_State
child_process_get_state(Application_Links *app, Child_Process_ID child_process_id){
    Models *models = (Models*)app->cmd_context;
    return(child_process_get_state(&models->child_processes, child_process_id));
}

api(custom) function b32
enqueue_virtual_event(Application_Links *app, Input_Event *event){
    Models *models = (Models*)app->cmd_context;
    b32 result = false;
    if (InputEventKind_None < event->kind && event->kind < InputEventKind_COUNT){
        models_push_virtual_event(models, event);
    }
    return(result);
}

api(custom) function i32
get_buffer_count(Application_Links *app)
{
    Models *models = (Models*)app->cmd_context;
    Working_Set *working_set = &models->working_set;
    return(working_set->active_file_count);
}

api(custom) function Buffer_ID
get_buffer_next(Application_Links *app, Buffer_ID buffer_id, Access_Flag access)
{
    Models *models = (Models*)app->cmd_context;
    Working_Set *working_set = &models->working_set;
    Editing_File *file = working_set_get_file(working_set, buffer_id);
    file = file_get_next(working_set, file);
    for (;file != 0 && !access_test(file_get_access_flags(file), access);){
        file = file_get_next(working_set, file);
    }
    Buffer_ID result = 0;
    if (file != 0){
        result = file->id;
    }
    return(result);
}

api(custom) function Buffer_ID
get_buffer_by_name(Application_Links *app, String_Const_u8 name, Access_Flag access)
{
    Models *models = (Models*)app->cmd_context;
    Working_Set *working_set = &models->working_set;
    Editing_File *file = working_set_contains_name(working_set, name);
    Buffer_ID result = 0;
    if (api_check_buffer(file, access)){
        result = file->id;
    }
    return(result);
}

api(custom) function Buffer_ID
get_buffer_by_file_name(Application_Links *app, String_Const_u8 file_name, Access_Flag access)
{
    Models *models = (Models*)app->cmd_context;
    Editing_File_Name canon = {};
    Buffer_ID result = false;
    Scratch_Block scratch(app);
    if (get_canon_name(scratch, file_name, &canon)){
        Working_Set *working_set = &models->working_set;
        Editing_File *file = working_set_contains_canon(working_set, string_from_file_name(&canon));
        if (api_check_buffer(file, access)){
            result = file->id;
        }
    }
    return(result);
}

api(custom) function b32
buffer_read_range(Application_Links *app, Buffer_ID buffer_id, Range_i64 range, u8 *out)
{
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    b32 result = false;
    if (api_check_buffer(file)){
        i64 size = buffer_size(&file->state.buffer);
        if (0 <= range.min && range.min <= range.max && range.max <= size){
            Scratch_Block scratch(app);
            String_Const_u8 string = buffer_stringify(scratch, &file->state.buffer, range);
            block_copy(out, string.str, string.size);
            result = true;
        }
    }
    return(result);
}

function Edit_Behaviors
get_active_edit_behaviors(Models *models, Editing_File *file){
    Panel *panel = layout_get_active_panel(&models->layout);
    Assert(panel != 0);
    View *view = panel->view;
    Assert(view != 0);
    Edit_Behaviors behaviors = {};
    if (view->file == file){
        behaviors.pos_before_edit = view->edit_pos_.cursor_pos;
    }
    else{
        behaviors.pos_before_edit = -1;
    }
    return(behaviors);
}

api(custom) function b32
buffer_replace_range(Application_Links *app, Buffer_ID buffer_id, Range_i64 range, String_Const_u8 string)
{
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    b32 result = false;
    if (api_check_buffer(file)){
        i64 size = buffer_size(&file->state.buffer);
        if (0 <= range.first && range.first <= range.one_past_last && range.one_past_last <= size){
            Edit_Behaviors behaviors = get_active_edit_behaviors(models, file);
            edit_single(app->tctx, models, file, range, string, behaviors);
            result = true;
        }
    }
    return(result);
}

api(custom) function b32
buffer_batch_edit(Application_Links *app, Buffer_ID buffer_id, Batch_Edit *batch)
{
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    b32 result = false;
    if (api_check_buffer(file)){
        Edit_Behaviors behaviors = get_active_edit_behaviors(models, file);
        result = edit_batch(app->tctx, models, file, batch, behaviors);
    }
    return(result);
}

api(custom) function String_Match
buffer_seek_string(Application_Links *app, Buffer_ID buffer, String_Const_u8 needle, Scan_Direction direction, i64 start_pos){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer);
    String_Match result = {};
    if (api_check_buffer(file)){
        if (needle.size == 0){
            result.flags = StringMatch_CaseSensitive;
            result.range = Ii64(start_pos);
        }
        else{
            Scratch_Block scratch(app);
            Gap_Buffer *gap_buffer = &file->state.buffer;
            i64 size = buffer_size(gap_buffer);
            List_String_Const_u8 chunks = buffer_get_chunks(scratch, gap_buffer);
            Range_i64 range = {};
            if (direction == Scan_Forward){
                i64 adjusted_pos = start_pos + 1;
                start_pos = clamp_top(adjusted_pos, size);
                range = Ii64(adjusted_pos, size);
            }
            else{
                i64 adjusted_pos = start_pos - 1 + needle.size;
                start_pos = clamp_bot(0, adjusted_pos);
                range = Ii64(0, adjusted_pos);
            }
            buffer_chunks_clamp(&chunks, range);
            if (chunks.first != 0){
                u64_Array jump_table = string_compute_needle_jump_table(scratch, needle, direction);
                Character_Predicate dummy = {};
                String_Match_List list = find_all_matches(scratch, 1,
                                                          chunks, needle, jump_table, &dummy, direction,
                                                          range.min, buffer, 0);
                if (list.count == 1){
                    result = *list.first;
                }
            }
            else{
                result.range = Ii64(start_pos);
            }
        }
    }
    return(result);
}

api(custom) function String_Match
buffer_seek_character_class(Application_Links *app, Buffer_ID buffer, Character_Predicate *predicate, Scan_Direction direction, i64 start_pos){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer);
    String_Match result = {};
    if (api_check_buffer(file)){
        Scratch_Block scratch(app);
        Gap_Buffer *gap_buffer = &file->state.buffer;
        List_String_Const_u8 chunks_list = buffer_get_chunks(scratch, gap_buffer);
        
        if (chunks_list.node_count > 0){
            // TODO(allen): If you are reading this comment, then I haven't revisited this to tighten it up yet.
            // buffer_seek_character_class was originally implemented using the chunk indexer helper
            // Buffer_Chunk_Position, and it was written when buffer chunks were in an array instead
            // of the new method of listing strings in a linked list.
            //   This should probably be implemented as a direct iteration-in-an-iteration that avoids the
            // extra function calls and branches to achieve the iteration.  However, this is a very easy API to
            // get wrong.  There are _a lot_ of opportunities for off by one errors and necessary code duplication,
            // really tedious stuff.  Anyway, this is all just to say, cleaning this up would be really nice, but
            // there are almost certainly lower hanging fruit with higher payoffs elsewhere... unless need to change
            // this anyway or whatever.
            String_Const_u8 chunk_mem[3] = {};
            String_Const_u8_Array chunks = {chunk_mem};
            for (Node_String_Const_u8 *node = chunks_list.first;
                 node != 0;
                 node = node->next){
                chunks.vals[chunks.count] = node->string;
                chunks.count += 1;
            }
            
            i64 size = buffer_size(gap_buffer);
            start_pos = clamp(-1, start_pos, size);
            Buffer_Chunk_Position pos = buffer_get_chunk_position(chunks, size, start_pos);
            for (;;){
                i32 past_end = buffer_chunk_position_iterate(chunks, &pos, direction);
                if (past_end == -1){
                    break;
                }
                else if (past_end == 1){
                    result.range = Ii64(size);
                    break;
                }
                u8 v = chunks.vals[pos.chunk_index].str[pos.chunk_pos];
                if (character_predicate_check_character(*predicate, v)){
                    result.buffer = buffer;
                    result.range = Ii64(pos.real_pos, pos.real_pos + 1);
                    break;
                }
            }
        }
    }
    return(result);
}

api(custom) function f32
buffer_line_y_difference(Application_Links *app, Buffer_ID buffer_id,
                         f32 width, Face_ID face_id,
                         i64 line_a, i64 line_b){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    f32 result = 0.0f;
    if (api_check_buffer(file)){
        Face *face = font_set_face_from_id(&models->font_set, face_id);
        if (face != 0){
            Layout_Function *layout_func = file_get_layout_func(file);
            result = file_line_y_difference(app->tctx, models, file,
                                            layout_func, width, face,
                                            line_a, line_b);
        }
    }
    return(result);
}

api(custom) function Line_Shift_Vertical
buffer_line_shift_y(Application_Links *app, Buffer_ID buffer_id,
                    f32 width, Face_ID face_id,
                    i64 line, f32 y_shift){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    Line_Shift_Vertical result = {};
    if (api_check_buffer(file)){
        Face *face = font_set_face_from_id(&models->font_set, face_id);
        if (face != 0){
            Layout_Function *layout_func = file_get_layout_func(file);
            result = file_line_shift_y(app->tctx, models, file,
                                       layout_func, width, face,
                                       line, y_shift);
        }
    }
    return(result);
}

api(custom) function i64
buffer_pos_at_relative_xy(Application_Links *app, Buffer_ID buffer_id,
                          f32 width, Face_ID face_id,
                          i64 base_line, Vec2_f32 relative_xy){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    i64 result = -1;
    if (api_check_buffer(file)){
        Face *face = font_set_face_from_id(&models->font_set, face_id);
        if (face != 0){
            Layout_Function *layout_func = file_get_layout_func(file);
            result = file_pos_at_relative_xy(app->tctx, models, file,
                                             layout_func, width, face,
                                             base_line, relative_xy);
        }
    }
    return(result);
}

api(custom) function Rect_f32
buffer_relative_box_of_pos(Application_Links *app, Buffer_ID buffer_id, f32 width, Face_ID face_id, i64 base_line, i64 pos){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    Rect_f32 result = {};
    if (api_check_buffer(file)){
        Face *face = font_set_face_from_id(&models->font_set, face_id);
        if (face != 0){
            Layout_Function *layout_func = file_get_layout_func(file);
            result = file_relative_box_of_pos(app->tctx, models, file,
                                              layout_func, width, face,
                                              base_line, pos);
        }
    }
    return(result);
}

api(custom) function Rect_f32
buffer_padded_box_of_pos(Application_Links *app, Buffer_ID buffer_id, f32 width, Face_ID face_id, i64 base_line, i64 pos){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    Rect_f32 result = {};
    if (api_check_buffer(file)){
        Face *face = font_set_face_from_id(&models->font_set, face_id);
        if (face != 0){
            Layout_Function *layout_func = file_get_layout_func(file);
            result = file_padded_box_of_pos(app->tctx, models, file,
                                            layout_func, width, face,
                                            base_line, pos);
        }
    }
    return(result);
}

api(custom) function i64
buffer_relative_character_from_pos(Application_Links *app, Buffer_ID buffer_id,
                                   f32 width, Face_ID face_id, i64 base_line, i64 pos)
{
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    i64 result = 0;
    if (api_check_buffer(file)){
        Face *face = font_set_face_from_id(&models->font_set, face_id);
        if (face != 0){
            Layout_Function *layout_func = file_get_layout_func(file);
            result = file_relative_character_from_pos(app->tctx, models, file,
                                                      layout_func, width, face,
                                                      base_line, pos);
        }
    }
    return(result);
}

api(custom) function i64
buffer_pos_from_relative_character(Application_Links *app,  Buffer_ID buffer_id, f32 width, Face_ID face_id, i64 base_line, i64 relative_character)
{
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    i64 result = -1;
    if (api_check_buffer(file)){
        Face *face = font_set_face_from_id(&models->font_set, face_id);
        if (face != 0){
            Layout_Function *layout_func = file_get_layout_func(file);
            result = file_pos_from_relative_character(app->tctx, models, file,
                                                      layout_func, width, face,
                                                      base_line, relative_character);
        }
    }
    return(result);
}


api(custom) function f32
view_line_y_difference(Application_Links *app, View_ID view_id, i64 line_a, i64 line_b){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    f32 result = 0.0f;
    if (api_check_view(view)){
        result = view_line_y_difference(app->tctx, models, view, line_a, line_b);
    }
    return(result);
}

api(custom) function Line_Shift_Vertical
view_line_shift_y(Application_Links *app, View_ID view_id, i64 line, f32 y_shift){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    Line_Shift_Vertical result = {};
    if (api_check_view(view)){
        result = view_line_shift_y(app->tctx, models, view, line, y_shift);
    }
    return(result);
}

api(custom) function i64
view_pos_at_relative_xy(Application_Links *app, View_ID view_id, i64 base_line, Vec2_f32 relative_xy){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    i64 result = -1;
    if (api_check_view(view)){
        result = view_pos_at_relative_xy(app->tctx, models, view, base_line, relative_xy);
    }
    return(result);
}

api(custom) function Rect_f32
view_relative_box_of_pos(Application_Links *app, View_ID view_id, i64 base_line, i64 pos){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    Rect_f32 result = {};
    if (api_check_view(view)){
        result = view_relative_box_of_pos(app->tctx, models, view, base_line, pos);
    }
    return(result);
}

api(custom) function Rect_f32
view_padded_box_of_pos(Application_Links *app, View_ID view_id, i64 base_line, i64 pos){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    Rect_f32 result = {};
    if (api_check_view(view)){
        result = view_padded_box_of_pos(app->tctx, models, view, base_line, pos);
    }
    return(result);
}

api(custom) function i64
view_relative_character_from_pos(Application_Links *app,  View_ID view_id, i64 base_line, i64 pos){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    i64 result = 0;
    if (api_check_view(view)){
        result = view_relative_character_from_pos(app->tctx, models, view, base_line, pos);
    }
    return(result);
}

api(custom) function i64
view_pos_from_relative_character(Application_Links *app,  View_ID view_id, i64 base_line, i64 character){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    i64 result = 0;
    if (api_check_view(view)){
        result = view_pos_from_relative_character(app->tctx, models, view, base_line, character);
    }
    return(result);
}

api(custom) function b32
buffer_exists(Application_Links *app, Buffer_ID buffer_id){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    return(api_check_buffer(file));
}

api(custom) function Access_Flag
buffer_get_access_flags(Application_Links *app, Buffer_ID buffer_id){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    Access_Flag result = 0;
    if (api_check_buffer(file)){
        result = file_get_access_flags(file);
    }
    return(result);
}

api(custom) function i64
buffer_get_size(Application_Links *app, Buffer_ID buffer_id){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    i64 result = 0;
    if (api_check_buffer(file)){
        result = buffer_size(&file->state.buffer);
    }
    return(result);
}

api(custom) function i64
buffer_get_line_count(Application_Links *app, Buffer_ID buffer_id){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    u64 result = 0;
    if (api_check_buffer(file)){
        result = buffer_line_count(&file->state.buffer);
    }
    return(result);
}

api(custom) function String_Const_u8
push_buffer_base_name(Application_Links *app, Arena *arena, Buffer_ID buffer_id){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    String_Const_u8 result = {};
    if (api_check_buffer(file)){
        result = push_string_copy(arena, string_from_file_name(&file->base_name));
    }
    return(result);
}

api(custom) function String_Const_u8
push_buffer_unique_name(Application_Links *app, Arena *out, Buffer_ID buffer_id){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    String_Const_u8 result = {};
    if (api_check_buffer(file)){
        result = push_string_copy(out, string_from_file_name(&file->unique_name));
    }
    return(result);
}

api(custom) function String_Const_u8
push_buffer_file_name(Application_Links *app, Arena *arena, Buffer_ID buffer_id){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    String_Const_u8 result = {};
    if (api_check_buffer(file)){
        result = push_string_copy(arena, string_from_file_name(&file->canon));
    }
    return(result);
}

api(custom) function Dirty_State
buffer_get_dirty_state(Application_Links *app, Buffer_ID buffer_id){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    Dirty_State result = 0;
    if (api_check_buffer(file)){
        result = file->state.dirty;
    }
    return(result);
}

api(custom) function b32
buffer_set_dirty_state(Application_Links *app, Buffer_ID buffer_id, Dirty_State dirty_state){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    b32 result = false;
    if (api_check_buffer(file)){
        result = true;
        file->state.dirty = dirty_state;
    }
    return(result);
}

api(custom) function b32
buffer_set_layout(Application_Links *app, Buffer_ID buffer_id, Layout_Function *layout_func){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    b32 result = false;
    if (api_check_buffer(file)){
        result = true;
        file->settings.layout_func = layout_func;
        file_clear_layout_cache(file);
    }
    return(result);
}

api(custom) function b32
buffer_clear_layout_cache(Application_Links *app, Buffer_ID buffer_id){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    b32 result = false;
    if (api_check_buffer(file)){
        result = true;
        file_clear_layout_cache(file);
    }
    return(result);
}

api(custom) function Layout_Function*
buffer_get_layout(Application_Links *app, Buffer_ID buffer_id){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    Layout_Function *result = 0;
    if (api_check_buffer(file)){
        result = file->settings.layout_func;
    }
    return(result);
}

api(custom) function b32
buffer_get_setting(Application_Links *app, Buffer_ID buffer_id, Buffer_Setting_ID setting, i64 *value_out)
{
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    b32 result = false;
    if (api_check_buffer(file)){
        result = true;
        switch (setting){
            case BufferSetting_Unimportant:
            {
                *value_out = file->settings.unimportant;
            }break;
            
            case BufferSetting_Unkillable:
            {
                *value_out = (file->settings.never_kill || file->settings.unkillable);
            }break;
            
            case BufferSetting_ReadOnly:
            {
                *value_out = file->settings.read_only;
            }break;
            
            case BufferSetting_RecordsHistory:
            {
                *value_out = history_is_activated(&file->state.history);
            }break;
            
            default:
            {
                result = false;
            }break;
        }
    }
    return(result);
}

api(custom) function b32
buffer_set_setting(Application_Links *app, Buffer_ID buffer_id, Buffer_Setting_ID setting, i64 value)
{
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    b32 result = false;
    if (api_check_buffer(file)){
        result = true;
        switch (setting){
            case BufferSetting_Unimportant:
            {
                if (value != 0){
                    file_set_unimportant(file, true);
                }
                else{
                    file_set_unimportant(file, false);
                }
            }break;
            
            case BufferSetting_Unkillable:
            {
                file->settings.unkillable = (value != 0);
            }break;
            
            case BufferSetting_ReadOnly:
            {
                file->settings.read_only = (value != 0);
            }break;
            
            case BufferSetting_RecordsHistory:
            {
                if (value){
                    if (!history_is_activated(&file->state.history)){
                        history_init(app->tctx, models, &file->state.history);
                    }
                }
                else{
                    if (history_is_activated(&file->state.history)){
                        history_free(app->tctx, &file->state.history);
                    }
                }
            }break;
            
            default:
            {
                result = 0;
            }break;
        }
    }
    
    return(result);
}

api(custom) function Managed_Scope
buffer_get_managed_scope(Application_Links *app, Buffer_ID buffer_id)
{
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    Managed_Scope result = 0;
    if (api_check_buffer(file)){
        result = file_get_managed_scope(file);
    }
    return(result);
}

api(custom) function b32
buffer_send_end_signal(Application_Links *app, Buffer_ID buffer_id)
{
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    b32 result = false;
    if (api_check_buffer(file)){
        file_end_file(app->tctx, models, file);
        result = true;
    }
    return(result);
}

api(custom) function Buffer_ID
create_buffer(Application_Links *app, String_Const_u8 file_name, Buffer_Create_Flag flags)
{
    Models *models = (Models*)app->cmd_context;
    Editing_File *new_file = create_file(app->tctx, models, file_name, flags);
    Buffer_ID result = 0;
    if (new_file != 0){
        result = new_file->id;
    }
    return(result);
}

api(custom) function b32
buffer_save(Application_Links *app, Buffer_ID buffer_id, String_Const_u8 file_name, Buffer_Save_Flag flags)
{
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    
    b32 result = false;
    if (api_check_buffer(file)){
        b32 skip_save = false;
        if (!HasFlag(flags, BufferSave_IgnoreDirtyFlag)){
            if (file->state.dirty == DirtyState_UpToDate){
                skip_save = true;
            }
        }
        
        if (!skip_save){
            Thread_Context *tctx = app->tctx;
            Scratch_Block scratch(tctx);
            String_Const_u8 name = push_string_copy(scratch, file_name);
            save_file_to_name(tctx, models, file, name.str);
            result = true;
        }
    }
    
    return(result);
}

api(custom) function Buffer_Kill_Result
buffer_kill(Application_Links *app, Buffer_ID buffer_id, Buffer_Kill_Flag flags)
{
    Models *models = (Models*)app->cmd_context;
    Working_Set *working_set = &models->working_set;
    Editing_File *file = imp_get_file(models, buffer_id);
    Buffer_Kill_Result result = BufferKillResult_DoesNotExist;
    if (api_check_buffer(file)){
        if (!file->settings.never_kill && !file->settings.unkillable){
            b32 needs_to_save = file_needs_save(file);
            if (!needs_to_save || (flags & BufferKill_AlwaysKill) != 0){
                Thread_Context *tctx = app->tctx;
                if (models->end_buffer != 0){
                    models->end_buffer(app, file->id);
                }
                
                buffer_unbind_name_low_level(working_set, file);
                if (file->canon.name_size != 0){
                    buffer_unbind_file(working_set, file);
                }
                file_free(tctx, models, file);
                working_set_free_file(&models->heap, working_set, file);
                
                Layout *layout = &models->layout;
                
                Node *order = &working_set->touch_order_sentinel;
                Node *file_node = order->next;
                for (Panel *panel = layout_get_first_open_panel(layout);
                     panel != 0;
                     panel = layout_get_next_open_panel(layout, panel)){
                    View *view = panel->view;
                    if (view->file == file){
                        Assert(file_node != order);
                        view->file = 0;
                        Editing_File *new_file = CastFromMember(Editing_File, touch_node, file_node);
                        view_set_file(tctx, models, view, new_file);
                        file_node = file_node->next;
                        if (file_node == order){
                            file_node = file_node->next;
                        }
                        Assert(file_node != order);
                    }
                }
                
                Child_Process_Container *child_processes = &models->child_processes;
                for (Node *node = child_processes->child_process_active_list.next;
                     node != &child_processes->child_process_active_list;
                     node = node->next){
                    Child_Process *child_process = CastFromMember(Child_Process, node, node);
                    if (child_process->out_file == file){
                        child_process->out_file = 0;
                    }
                }
                
                result = BufferKillResult_Killed;
            }
            else{
                result = BufferKillResult_Dirty;
            }
        }
        else{
            result = BufferKillResult_Unkillable;
        }
    }
    return(result);
}

api(custom) function Buffer_Reopen_Result
buffer_reopen(Application_Links *app, Buffer_ID buffer_id, Buffer_Reopen_Flag flags)
{
    Models *models = (Models*)app->cmd_context;
    Thread_Context *tctx = app->tctx;
    Scratch_Block scratch(tctx);
    Editing_File *file = imp_get_file(models, buffer_id);
    Buffer_Reopen_Result result = BufferReopenResult_Failed;
    if (api_check_buffer(file)){
        if (file->canon.name_size > 0){
            Plat_Handle handle = {};
            if (system_load_handle(scratch, (char*)file->canon.name_space, &handle)){
                File_Attributes attributes = system_load_attributes(handle);
                
                char *file_memory = push_array(scratch, char, (i32)attributes.size);
                
                if (file_memory != 0){
                    if (system_load_file(handle, file_memory, (i32)attributes.size)){
                        system_load_close(handle);
                        
                        // TODO(allen): try(perform a diff maybe apply edits in reopen)
                        
                        i32 line_numbers[16];
                        i32 column_numbers[16];
                        View *vptrs[16];
                        i32 vptr_count = 0;
                        
                        Layout *layout = &models->layout;
                        for (Panel *panel = layout_get_first_open_panel(layout);
                             panel != 0;
                             panel = layout_get_next_open_panel(layout, panel)){
                            View *view_it = panel->view;
                            if (view_it->file == file){
                                vptrs[vptr_count] = view_it;
                                File_Edit_Positions edit_pos = view_get_edit_pos(view_it);
                                Buffer_Cursor cursor = file_compute_cursor(view_it->file, seek_pos(edit_pos.cursor_pos));
                                line_numbers[vptr_count]   = (i32)cursor.line;
                                column_numbers[vptr_count] = (i32)cursor.col;
                                view_it->file = models->scratch_buffer;
                                ++vptr_count;
                            }
                        }
                        
                        Working_Set *working_set = &models->working_set;
                        file_free(tctx, models, file);
                        working_set_file_default_settings(working_set, file);
                        file_create_from_string(tctx, models, file, SCu8(file_memory, attributes.size), attributes);
                        
                        for (i32 i = 0; i < vptr_count; ++i){
                            view_set_file(tctx, models, vptrs[i], file);
                            
                            vptrs[i]->file = file;
                            i64 line = line_numbers[i];
                            i64 col = column_numbers[i];
                            Buffer_Cursor cursor = file_compute_cursor(file, seek_line_col(line, col));
                            view_set_cursor(tctx, models, vptrs[i], cursor.pos);
                        }
                        result = BufferReopenResult_Reopened;
                    }
                    else{
                        system_load_close(handle);
                    }
                }
                else{
                    system_load_close(handle);
                }
            }
        }
    }
    return(result);
}

api(custom) function File_Attributes
buffer_get_file_attributes(Application_Links *app, Buffer_ID buffer_id)
{
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    File_Attributes result = {};
    if (api_check_buffer(file)){
        block_copy_struct(&result, &file->attributes);
    }
    return(result);
}

function View*
get_view_next__inner(Layout *layout, View *view){
    if (view != 0){
        Panel *panel = view->panel;
        panel = layout_get_next_open_panel(layout, panel);
        if (panel != 0){
            view = panel->view;
        }
        else{
            view = 0;
        }
    }
    else{
        Panel *panel = layout_get_first_open_panel(layout);
        view = panel->view;
    }
    return(view);
}

function View*
get_view_prev__inner(Layout *layout, View *view){
    if (view != 0){
        Panel *panel = view->panel;
        panel = layout_get_prev_open_panel(layout, panel);
        if (panel != 0){
            view = panel->view;
        }
        else{
            view = 0;
        }
    }
    else{
        Panel *panel = layout_get_last_open_panel(layout);
        view = panel->view;
    }
    return(view);
}

api(custom) function View_ID
get_view_next(Application_Links *app, View_ID view_id, Access_Flag access)
{
    Models *models = (Models*)app->cmd_context;
    Layout *layout = &models->layout;
    View *view = imp_get_view(models, view_id);
    view = get_view_next__inner(layout, view);
    for (;view != 0 && !access_test(view_get_access_flags(view), access);){
        view = get_view_next__inner(layout, view);
    }
    View_ID result = 0;
    if (view != 0){
        result = view_get_id(&models->view_set, view);
    }
    return(result);
}

api(custom) function View_ID
get_view_prev(Application_Links *app, View_ID view_id, Access_Flag access)
{
    Models *models = (Models*)app->cmd_context;
    Layout *layout = &models->layout;
    View *view = imp_get_view(models, view_id);
    view = get_view_prev__inner(layout, view);
    for (;view != 0 && !access_test(view_get_access_flags(view), access);){
        view = get_view_prev__inner(layout, view);
    }
    View_ID result = 0;
    if (view != 0){
        result = view_get_id(&models->view_set, view);
    }
    return(result);
}

api(custom) function View_ID
get_this_ctx_view(Application_Links *app, Access_Flag access)
{
    Models *models = (Models*)app->cmd_context;
    Thread_Context *tctx = app->tctx;
    Thread_Context_Extra_Info *tctx_info = (Thread_Context_Extra_Info*)tctx->user_data;
    View_ID result = 0;
    if (tctx_info->coroutine != 0){
        Coroutine *coroutine = (Coroutine*)tctx_info->coroutine;
        View *view = (View*)coroutine->user_data;
        if (view != 0){
            result = view_get_id(&models->view_set, view);
        }
    }
    return(result);
}

api(custom) function View_ID
get_active_view(Application_Links *app, Access_Flag access)
{
    Models *models = (Models*)app->cmd_context;
    Panel *panel = layout_get_active_panel(&models->layout);
    Assert(panel != 0);
    View *view = panel->view;
    Assert(view != 0);
    View_ID result = 0;
    if (api_check_view(view, access)){
        result = view_get_id(&models->view_set, view);
    }
    return(result);
}

api(custom) function b32
view_exists(Application_Links *app, View_ID view_id){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    b32 result = false;
    if (api_check_view(view)){
        result = true;
    }
    return(result);
}

api(custom) function Buffer_ID
view_get_buffer(Application_Links *app, View_ID view_id, Access_Flag access){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    Buffer_ID result = 0;
    if (api_check_view(view)){
        Editing_File *file = view->file;
        if (api_check_buffer(file, access)){
            result = file->id;
        }
    }
    return(result);
}

api(custom) function i64
view_get_cursor_pos(Application_Links *app, View_ID view_id){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    i64 result = 0;
    if (api_check_view(view)){
        File_Edit_Positions edit_pos = view_get_edit_pos(view);
        result = edit_pos.cursor_pos;
    }
    return(result);
}

api(custom) function i64
view_get_mark_pos(Application_Links *app, View_ID view_id){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    i64 result = 0;;
    if (api_check_view(view)){
        result = view->mark;
    }
    return(result);
}

api(custom) function f32
view_get_preferred_x(Application_Links *app, View_ID view_id){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    f32 result = 0.f;;
    if (api_check_view(view)){
        result = view->preferred_x;
    }
    return(result);
}

api(custom) function b32
view_set_preferred_x(Application_Links *app, View_ID view_id, f32 x){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    b32 result = false;
    if (api_check_view(view)){
        view->preferred_x = x;
        result = true;
    }
    return(result);
}

api(custom) function Rect_f32
view_get_screen_rect(Application_Links *app, View_ID view_id){
    Models *models = (Models*)app->cmd_context;
    Rect_f32 result = {};
    View *view = imp_get_view(models, view_id);
    if (api_check_view(view)){
        result = Rf32(view->panel->rect_full);
    }
    return(result);
}

api(custom) function Panel_ID
view_get_panel(Application_Links *app, View_ID view_id){
    Models *models = (Models*)app->cmd_context;
    Layout *layout = &models->layout;
    View *view = imp_get_view(models, view_id);
    Panel_ID result = 0;
    if (api_check_view(view)){
        Panel *panel = view->panel;
        result = panel_get_id(layout, panel);
    }
    return(result);
}

api(custom) function View_ID
panel_get_view(Application_Links *app, Panel_ID panel_id, Access_Flag access){
    Models *models = (Models*)app->cmd_context;
    Panel *panel = imp_get_panel(models, panel_id);
    View_ID result = 0;
    if (api_check_panel(panel)){
        if (panel->kind == PanelKind_Final){
            View *view = panel->view;
            if (api_check_view(view, access)){
                result = view_get_id(&models->view_set, view);
            }
        }
    }
    return(result);
}

api(custom) function b32
panel_is_split(Application_Links *app, Panel_ID panel_id){
    Models *models = (Models*)app->cmd_context;
    b32 result = false;
    Panel *panel = imp_get_panel(models, panel_id);
    if (api_check_panel(panel)){
        if (panel->kind == PanelKind_Intermediate){
            result = true;
        }
    }
    return(result);
}

api(custom) function b32
panel_is_leaf(Application_Links *app, Panel_ID panel_id){
    Models *models = (Models*)app->cmd_context;
    b32 result = false;
    Panel *panel = imp_get_panel(models, panel_id);
    if (api_check_panel(panel)){
        if (panel->kind == PanelKind_Final){
            result = true;
        }
    }
    return(result);
}

api(custom) function b32
panel_split(Application_Links *app, Panel_ID panel_id, Dimension split_dim){
    Models *models = (Models*)app->cmd_context;
    Layout *layout = &models->layout;
    b32 result = false;
    Panel *panel = imp_get_panel(models, panel_id);
    if (api_check_panel(panel)){
        Panel *new_panel = 0;
        if (layout_split_panel(layout, panel, (split_dim == Dimension_X), &new_panel)){
            Live_Views *view_set = &models->view_set;
            View *new_view = live_set_alloc_view(&models->lifetime_allocator, view_set, new_panel);
            view_init(app->tctx, models, new_view, models->scratch_buffer,
                      models->view_event_handler);
            result = true;
        }
    }
    return(result);
}

api(custom) function b32
panel_set_split(Application_Links *app, Panel_ID panel_id, Panel_Split_Kind kind,
                f32 t){
    Models *models = (Models*)app->cmd_context;
    Layout *layout = &models->layout;
    b32 result = false;
    Panel *panel = imp_get_panel(models, panel_id);
    if (api_check_panel(panel)){
        if (panel->kind == PanelKind_Intermediate){
            panel->split.kind = kind;
            switch (kind){
                case PanelSplitKind_Ratio_Max:
                case PanelSplitKind_Ratio_Min:
                {
                    panel->split.v_f32 = clamp(0.f, t, 1.f);
                }break;
                
                case PanelSplitKind_FixedPixels_Max:
                case PanelSplitKind_FixedPixels_Min:
                {
                    panel->split.v_i32 = i32_round32(t);
                }break;
                
                default:
                {
                    print_message(app, string_u8_litexpr("Invalid split kind passed to panel_set_split, no change made to view layout"));
                }break;
            }
            layout_propogate_sizes_down_from_node(layout, panel);
            result = true;
        }
    }
    return(result);
}

api(custom) function b32
panel_swap_children(Application_Links *app, Panel_ID panel_id){
    Models *models = (Models*)app->cmd_context;
    Layout *layout = &models->layout;
    b32 result = false;
    Panel *panel = imp_get_panel(models, panel_id);
    if (api_check_panel(panel)){
        if (panel->kind == PanelKind_Intermediate){
            Swap(Panel*, panel->tl_panel, panel->br_panel);
            layout_propogate_sizes_down_from_node(layout, panel);
        }
    }
    return(result);
}

api(custom) function Panel_ID
panel_get_root(Application_Links *app){
    Models *models = (Models*)app->cmd_context;
    Layout *layout = &models->layout;
    Panel *panel = layout->root;
    return(panel_get_id(layout, panel));
}

api(custom) function Panel_ID
panel_get_parent(Application_Links *app, Panel_ID panel_id){
    Models *models = (Models*)app->cmd_context;
    Layout *layout = &models->layout;
    Panel *panel = imp_get_panel(models, panel_id);
    Panel_ID result = false;
    if (api_check_panel(panel)){
        result = panel_get_id(layout, panel->parent);
    }
    return(result);
}

api(custom) function Panel_ID
panel_get_child(Application_Links *app, Panel_ID panel_id, Side which_child){
    Models *models = (Models*)app->cmd_context;
    Layout *layout = &models->layout;
    Panel *panel = imp_get_panel(models, panel_id);
    Panel_ID result = 0;
    if (api_check_panel(panel)){
        if (panel->kind == PanelKind_Intermediate){
            Panel *child = 0;
            switch (which_child){
                case Side_Min:
                {
                    child = panel->tl_panel;
                }break;
                case Side_Max:
                {
                    child = panel->br_panel;
                }break;
            }
            if (child != 0){
                result = panel_get_id(layout, child);
            }
        }
    }
    return(result);
}

api(custom) function b32
view_close(Application_Links *app, View_ID view_id)
{
    Models *models = (Models*)app->cmd_context;
    Layout *layout = &models->layout;
    View *view = imp_get_view(models, view_id);
    b32 result = false;
    if (api_check_view(view)){
        result = view_close(models, view);
    }
    return(result);
}

api(custom) function Rect_f32
view_get_buffer_region(Application_Links *app, View_ID view_id){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    Rect_f32 result = {};
    if (api_check_view(view)){
        result = view_get_buffer_rect(app->tctx, models, view);
    }
    return(result);
}

api(custom) function Buffer_Scroll
view_get_buffer_scroll(Application_Links *app, View_ID view_id){
    Models *models = (Models*)app->cmd_context;
    Buffer_Scroll  result = {};
    View *view = imp_get_view(models, view_id);
    if (api_check_view(view)){
        File_Edit_Positions edit_pos = view_get_edit_pos(view);
        result = edit_pos.scroll;
    }
    return(result);
}

api(custom) function b32
view_set_active(Application_Links *app, View_ID view_id)
{
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    b32 result = false;
    if (api_check_view(view)){
        models->layout.active_panel = view->panel;
        result = true;
    }
    return(result);
}

api(custom) function b32
view_enqueue_command_function(Application_Links *app, View_ID view_id, Custom_Command_Function *custom_func)
{
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    b32 result = false;
    if (api_check_view(view)){
        models_push_view_command_function(models, view_id, custom_func);
        result = true;
    }
    return(result);
}

api(custom) function b32
view_get_setting(Application_Links *app, View_ID view_id, View_Setting_ID setting, i64 *value_out)
{
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    
    b32 result = false;
    if (api_check_view(view)){
        result = true;
        switch (setting){
            case ViewSetting_ShowWhitespace:
            {
                *value_out = view->show_whitespace;
            }break;
            
            case ViewSetting_ShowScrollbar:
            {
                *value_out = !view->hide_scrollbar;
            }break;
            
            case ViewSetting_ShowFileBar:
            {
                *value_out = !view->hide_file_bar;
            }break;
            
            default:
            {
                result = false;
            }break;
        }
    }
    return(result);
}

api(custom) function b32
view_set_setting(Application_Links *app, View_ID view_id, View_Setting_ID setting, i64 value)
{
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    
    b32 result = false;
    if (api_check_view(view)){
        result = true;
        switch (setting){
            case ViewSetting_ShowWhitespace:
            {
                view->show_whitespace = (b8)value;
            }break;
            
            case ViewSetting_ShowScrollbar:
            {
                view->hide_scrollbar = (b8)!value;
            }break;
            
            case ViewSetting_ShowFileBar:
            {
                view->hide_file_bar = (b8)!value;
            }break;
            
            default:
            {
                result = false;
            }break;
        }
    }
    return(result);
}

api(custom) function Managed_Scope
view_get_managed_scope(Application_Links *app, View_ID view_id)
{
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    Managed_Scope result = 0;
    if (api_check_view(view)){
        Assert(view->lifetime_object != 0);
        result = (Managed_Scope)(view->lifetime_object->workspace.scope_id);
    }
    return(result);
}

api(custom) function Buffer_Cursor
buffer_compute_cursor(Application_Links *app, Buffer_ID buffer, Buffer_Seek seek)
{
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer);
    Buffer_Cursor result = {};
    if (api_check_buffer(file)){
        result = file_compute_cursor(file, seek);
    }
    return(result);
}

api(custom) function Buffer_Cursor
view_compute_cursor(Application_Links *app, View_ID view_id, Buffer_Seek seek){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    Buffer_Cursor result = {};
    if (api_check_view(view)){
        result = view_compute_cursor(view, seek);
    }
    return(result);
}

api(custom) function b32
view_set_camera_bounds(Application_Links *app, View_ID view_id, Vec2_f32 margin, Vec2_f32 push_in_multiplier)
{
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    b32 result = false;
    if (api_check_view(view)){
        result = true;
        margin.x = clamp_bot(0.f, margin.x);
        margin.y = clamp_bot(0.f, margin.y);
        push_in_multiplier.x = clamp_bot(1.5f, push_in_multiplier.x);
        push_in_multiplier.y = clamp_bot(1.5f, push_in_multiplier.y);
        view->cursor_margin = margin;
        view->cursor_push_in_multiplier = push_in_multiplier;
    }
    return(result);
}

api(custom) function b32
view_get_camera_bounds(Application_Links *app, View_ID view_id, Vec2_f32 *margin, Vec2_f32 *push_in_multiplier)
{
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    b32 result = false;
    if (api_check_view(view)){
        result = true;
        *margin = view->cursor_margin;
        *push_in_multiplier = view->cursor_push_in_multiplier;
    }
    return(result);
}

api(custom) function b32
view_set_cursor(Application_Links *app, View_ID view_id, Buffer_Seek seek)
{
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    b32 result = false;
    if (api_check_view(view)){
        Editing_File *file = view->file;
        Assert(file != 0);
        if (api_check_buffer(file)){
            Buffer_Cursor cursor = file_compute_cursor(file, seek);
            view_set_cursor(app->tctx, models, view, cursor.pos);
            result = true;
        }
    }
    return(result);
}

api(custom) function b32
view_set_buffer_scroll(Application_Links *app, View_ID view_id, Buffer_Scroll scroll,
                       Set_Buffer_Scroll_Rule rule)
{
    Models *models = (Models*)app->cmd_context;
    b32 result = false;
    View *view = imp_get_view(models, view_id);
    if (api_check_view(view)){
        Thread_Context *tctx = app->tctx;
        scroll.position = view_normalize_buffer_point(tctx, models, view, scroll.position);
        scroll.target = view_normalize_buffer_point(tctx, models, view, scroll.target);
        scroll.target.pixel_shift.x = f32_round32(scroll.target.pixel_shift.x);
        scroll.target.pixel_shift.y = f32_round32(scroll.target.pixel_shift.y);
        scroll.target.pixel_shift.x = clamp_bot(0.f, scroll.target.pixel_shift.x);
        Layout_Item_List line = view_get_line_layout(tctx, models, view,
                                                     scroll.target.line_number);
        scroll.target.pixel_shift.y =
            clamp(0.f, scroll.target.pixel_shift.y, line.height);
        if (rule == SetBufferScroll_SnapCursorIntoView){
            view_set_scroll(tctx, models, view, scroll);
        }
        else{
            File_Edit_Positions edit_pos = view_get_edit_pos(view);
            edit_pos.scroll = scroll;
            view_set_edit_pos(view, edit_pos);
        }
        view->new_scroll_target = true;
        result = true;
    }
    return(result);
}

api(custom) function b32
view_set_mark(Application_Links *app, View_ID view_id, Buffer_Seek seek)
{
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    
    b32 result = false;
    if (api_check_view(view)){
        Editing_File *file = view->file;
        Assert(file != 0);
        if (api_check_buffer(file)){
            if (seek.type != buffer_seek_pos){
                Buffer_Cursor cursor = file_compute_cursor(file, seek);
                view->mark = cursor.pos;
            }
            else{
                view->mark = seek.pos;
            }
            result = true;
        }
    }
    return(result);
}

api(custom) function b32
view_quit_ui(Application_Links *app, View_ID view_id){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    b32 result = false;
    if (view != 0){
        view_quit_ui(app->tctx, models, view);
        result = true;
    }
    return(result);
}

api(custom) function b32
view_set_buffer(Application_Links *app, View_ID view_id, Buffer_ID buffer_id, Set_Buffer_Flag flags)
{
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    b32 result = false;
    if (api_check_view(view)){
        Editing_File *file = working_set_get_file(&models->working_set, buffer_id);
        if (api_check_buffer(file)){
            if (file != view->file){
                view_set_file(app->tctx, models, view, file);
                if (!(flags & SetBuffer_KeepOriginalGUI)){
                    view_quit_ui(app->tctx, models, view);
                }
            }
            result = true;
        }
    }
    return(result);
}

api(custom) function b32
view_push_context(Application_Links *app, View_ID view_id, View_Context *ctx){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    b32 result = false;
    if (api_check_view(view)){
        view_push_context(view, ctx);
        result = true;
    }
    return(result);
}

api(custom) function b32
view_pop_context(Application_Links *app, View_ID view_id){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    b32 result = false;
    if (api_check_view(view)){
        view_pop_context(view);
        result = true;
    }
    return(result);
}

api(custom) function b32
view_alter_context(Application_Links *app, View_ID view_id, View_Context *ctx){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    b32 result = false;
    if (api_check_view(view)){
        view_alter_context(view, ctx);
        result = true;
    }
    return(result);
}

api(custom) function View_Context
view_current_context(Application_Links *app, View_ID view_id){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    View_Context result = {};
    if (api_check_view(view)){
        result = view_current_context(view);
    }
    return(result);
}

api(custom) function String_Const_u8
view_current_context_hook_memory(Application_Links *app, View_ID view_id,
                                 Hook_ID hook_id){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    String_Const_u8 result = {};
    if (api_check_view(view)){
        View_Context_Node *ctx = view_current_context_node(view);
        if (ctx != 0){
            switch (hook_id){
                case HookID_DeltaRule:
                {
                    result = make_data(ctx->delta_rule_memory,
                                       ctx->ctx.delta_rule_memory_size);
                }break;
            }
        }
    }
    return(result);
}

function Dynamic_Workspace*
get_dynamic_workspace(Models *models, Managed_Scope handle){
    Dynamic_Workspace *result = 0;
    Table_Lookup lookup = table_lookup(&models->lifetime_allocator.scope_id_to_scope_ptr_table, handle);
    if (lookup.found_match){
        u64 val = 0;
        table_read(&models->lifetime_allocator.scope_id_to_scope_ptr_table, lookup, &val);
        result = (Dynamic_Workspace*)IntAsPtr(val);
    }
    return(result);
}

api(custom) function Managed_Scope
create_user_managed_scope(Application_Links *app)
{
    Models *models = (Models*)app->cmd_context;
    Lifetime_Object *object = lifetime_alloc_object(&models->lifetime_allocator, DynamicWorkspace_Unassociated, 0);
    object->workspace.user_back_ptr = object;
    Managed_Scope scope = (Managed_Scope)object->workspace.scope_id;
    return(scope);
}

api(custom) function b32
destroy_user_managed_scope(Application_Links *app, Managed_Scope scope)
{
    Models *models = (Models*)app->cmd_context;
    Dynamic_Workspace *workspace = get_dynamic_workspace(models, scope);
    b32 result = false;
    if (workspace != 0 && workspace->user_type == DynamicWorkspace_Unassociated){
        Lifetime_Object *lifetime_object = (Lifetime_Object*)workspace->user_back_ptr;
        lifetime_free_object(&models->lifetime_allocator, lifetime_object);
        result = true;
    }
    return(result);
}

api(custom) function Managed_Scope
get_global_managed_scope(Application_Links *app)
{
    Models *models = (Models*)app->cmd_context;
    return((Managed_Scope)models->dynamic_workspace.scope_id);
}

function Lifetime_Object*
get_lifetime_object_from_workspace(Dynamic_Workspace *workspace){
    Lifetime_Object *result = 0;
    switch (workspace->user_type){
        case DynamicWorkspace_Unassociated:
        {
            result = (Lifetime_Object*)workspace->user_back_ptr;
        }break;
        case DynamicWorkspace_Buffer:
        {
            Editing_File *file = (Editing_File*)workspace->user_back_ptr;
            result = file->lifetime_object;
        }break;
        case DynamicWorkspace_View:
        {
            View *vptr = (View*)workspace->user_back_ptr;
            result = vptr->lifetime_object;
        }break;
        default:
        {
            InvalidPath;
        }break;
    }
    return(result);
}

api(custom) function Managed_Scope
get_managed_scope_with_multiple_dependencies(Application_Links *app, Managed_Scope *scopes, i32 count)
{
    Models *models = (Models*)app->cmd_context;
    Lifetime_Allocator *lifetime_allocator = &models->lifetime_allocator;
    
    Scratch_Block scratch(app);
    
    // TODO(allen): revisit this
    struct Node_Ptr{
        Node_Ptr *next;
        Lifetime_Object *object_ptr;
    };
    
    Node_Ptr *first = 0;
    Node_Ptr *last = 0;
    i32 member_count = 0;
    
    b32 filled_array = true;
    for (i32 i = 0; i < count; i += 1){
        Dynamic_Workspace *workspace = get_dynamic_workspace(models, scopes[i]);
        if (workspace == 0){
            filled_array = false;
            break;
        }
        
        switch (workspace->user_type){
            case DynamicWorkspace_Global:
            {
                // NOTE(allen): (global_scope INTERSECT X) == X for all X, therefore we emit nothing when a global group is in the key list.
            }break;
            
            case DynamicWorkspace_Unassociated:
            case DynamicWorkspace_Buffer:
            case DynamicWorkspace_View:
            {
                Lifetime_Object *object = get_lifetime_object_from_workspace(workspace);
                Assert(object != 0);
                Node_Ptr *new_node = push_array(scratch, Node_Ptr, 1);
                sll_queue_push(first, last, new_node);
                new_node->object_ptr = object;
                member_count += 1;
            }break;
            
            case DynamicWorkspace_Intersected:
            {
                Lifetime_Key *key = (Lifetime_Key*)workspace->user_back_ptr;
                if (lifetime_key_check(lifetime_allocator, key)){
                    i32 key_member_count = key->count;
                    Lifetime_Object **key_member_ptr = key->members;
                    for (i32 j = 0; j < key_member_count; j += 1, key_member_ptr += 1){
                        Node_Ptr *new_node = push_array(scratch, Node_Ptr, 1);
                        sll_queue_push(first, last, new_node);
                        new_node->object_ptr = *key_member_ptr;
                        member_count += 1;
                    }
                }
            }break;
            
            default:
            {
                InvalidPath;
            }break;
        }
    }
    
    Managed_Scope result = 0;
    if (filled_array){
        Lifetime_Object **object_ptr_array = push_array(scratch, Lifetime_Object*, member_count);
        i32 index = 0;
        for (Node_Ptr *node = first;
             node != 0;
             node = node->next){
            object_ptr_array[index] = node->object_ptr;
            index += 1;
        }
        member_count = lifetime_sort_and_dedup_object_set(object_ptr_array, member_count);
        Lifetime_Key *key = lifetime_get_or_create_intersection_key(lifetime_allocator, object_ptr_array, member_count);
        result = (Managed_Scope)key->dynamic_workspace.scope_id;
    }
    
    return(result);
}

api(custom) function b32
managed_scope_clear_contents(Application_Links *app, Managed_Scope scope)
{
    Models *models = (Models*)app->cmd_context;
    Dynamic_Workspace *workspace = get_dynamic_workspace(models, scope);
    b32 result = false;
    if (workspace != 0){
        dynamic_workspace_clear_contents(workspace);
        result = true;
    }
    return(result);
}

api(custom) function b32
managed_scope_clear_self_all_dependent_scopes(Application_Links *app, Managed_Scope scope)
{
    Models *models = (Models*)app->cmd_context;
    Dynamic_Workspace *workspace = get_dynamic_workspace(models, scope);
    b32 result = false;
    if (workspace != 0 && workspace->user_type != DynamicWorkspace_Global && workspace->user_type != DynamicWorkspace_Intersected){
        Lifetime_Object *object = get_lifetime_object_from_workspace(workspace);
        Assert(object != 0);
        lifetime_object_reset(&models->lifetime_allocator, object);
        result = true;
    }
    return(result);
}

api(custom) function Base_Allocator*
managed_scope_allocator(Application_Links *app, Managed_Scope scope)
{
    Models *models = (Models*)app->cmd_context;
    Dynamic_Workspace *workspace = get_dynamic_workspace(models, scope);
    Base_Allocator *result = 0;
    if (workspace != 0){
        result = &workspace->heap_wrapper;
    }
    return(result);
}

api(custom) function u64
managed_id_group_highest_id(Application_Links *app, String_Const_u8 group){
    Models *models = (Models*)app->cmd_context;
    Managed_ID_Set *set = &models->managed_id_set;
    return(managed_ids_group_highest_id(set, group));
}

api(custom) function Managed_ID
managed_id_declare(Application_Links *app, String_Const_u8 group, String_Const_u8 name)
{
    Models *models = (Models*)app->cmd_context;
    Managed_ID_Set *set = &models->managed_id_set;
    return(managed_ids_declare(set, group, name));
}

api(custom) function Managed_ID
managed_id_get(Application_Links *app, String_Const_u8 group, String_Const_u8 name){
    Models *models = (Models*)app->cmd_context;
    Managed_ID_Set *set = &models->managed_id_set;
    return(managed_ids_get(set, group, name));
}

api(custom) function void*
managed_scope_get_attachment(Application_Links *app, Managed_Scope scope, Managed_ID id, u64 size){
    Models *models = (Models*)app->cmd_context;
    Dynamic_Workspace *workspace = get_dynamic_workspace(models, scope);
    void *result = 0;
    if (workspace != 0){
        Dynamic_Variable_Block *var_block = &workspace->var_block;
        String_Const_u8 data = dynamic_variable_get(var_block, id, size);
        if (data.size >= size){
            result = data.str;
        }
        else{
#define M \
"ERROR: scope attachment already exists with a size smaller than the requested size; no attachment pointer can be returned."
            print_message(app, string_u8_litexpr(M));
#undef M
        }
    }
    return(result);
}

api(custom) function b32
managed_scope_attachment_erase(Application_Links *app, Managed_Scope scope, Managed_ID id){
    Models *models = (Models*)app->cmd_context;
    Dynamic_Workspace *workspace = get_dynamic_workspace(models, scope);
    b32 result = false;
    if (workspace != 0){
        Dynamic_Variable_Block *var_block = &workspace->var_block;
        dynamic_variable_erase(var_block, id);
        result = true;
    }
    return(result);
}

api(custom) function Managed_Object
alloc_managed_memory_in_scope(Application_Links *app, Managed_Scope scope, i32 item_size, i32 count)
{
    Models *models = (Models*)app->cmd_context;
    Dynamic_Workspace *workspace = get_dynamic_workspace(models, scope);
    Managed_Object result = 0;
    if (workspace != 0){
        result = managed_object_alloc_managed_memory(workspace, item_size, count, 0);
    }
    return(result);
}

api(custom) function Managed_Object
alloc_buffer_markers_on_buffer(Application_Links *app, Buffer_ID buffer_id, i32 count, Managed_Scope *optional_extra_scope)
{
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    Managed_Scope markers_scope = file_get_managed_scope(file);
    if (optional_extra_scope != 0){
        Managed_Object scope_array[2];
        scope_array[0] = markers_scope;
        scope_array[1] = *optional_extra_scope;
        markers_scope = get_managed_scope_with_multiple_dependencies(app, scope_array, 2);
    }
    Dynamic_Workspace *workspace = get_dynamic_workspace(models, markers_scope);
    Managed_Object result = 0;
    if (workspace != 0){
        result = managed_object_alloc_buffer_markers(workspace, buffer_id, count, 0);
    }
    return(result);
}

function Managed_Object_Ptr_And_Workspace
get_dynamic_object_ptrs(Models *models, Managed_Object object){
    Managed_Object_Ptr_And_Workspace result = {};
    u32 hi_id = (object >> 32)&max_u32;
    Dynamic_Workspace *workspace = get_dynamic_workspace(models, hi_id);
    if (workspace != 0){
        u32 lo_id = object&max_u32;
        Managed_Object_Standard_Header *header = (Managed_Object_Standard_Header*)dynamic_workspace_get_pointer(workspace, lo_id);
        if (header != 0){
            result.workspace = workspace;
            result.header = header;
        }
    }
    return(result);
}

api(custom) function u32
managed_object_get_item_size(Application_Links *app, Managed_Object object)
{
    Models *models = (Models*)app->cmd_context;
    Managed_Object_Ptr_And_Workspace object_ptrs = get_dynamic_object_ptrs(models, object);
    u32 result = 0;
    if (object_ptrs.header != 0){
        result = object_ptrs.header->item_size;
    }
    return(result);
}

api(custom) function u32
managed_object_get_item_count(Application_Links *app, Managed_Object object)
{
    Models *models = (Models*)app->cmd_context;
    Managed_Object_Ptr_And_Workspace object_ptrs = get_dynamic_object_ptrs(models, object);
    u32 result = 0;
    if (object_ptrs.header != 0){
        result = object_ptrs.header->count;
    }
    return(result);
}

api(custom) function void*
managed_object_get_pointer(Application_Links *app, Managed_Object object)
{
    Models *models = (Models*)app->cmd_context;
    Managed_Object_Ptr_And_Workspace object_ptrs = get_dynamic_object_ptrs(models, object);
    return(get_dynamic_object_memory_ptr(object_ptrs.header));
}

api(custom) function Managed_Object_Type
managed_object_get_type(Application_Links *app, Managed_Object object)
{
    Models *models = (Models*)app->cmd_context;
    Managed_Object_Ptr_And_Workspace object_ptrs = get_dynamic_object_ptrs(models, object);
    if (object_ptrs.header != 0){
        Managed_Object_Type type = object_ptrs.header->type;
        if (type < 0 || ManagedObjectType_COUNT <= type){
            type = ManagedObjectType_Error;
        }
        return(type);
    }
    return(ManagedObjectType_Error);
}

api(custom) function Managed_Scope
managed_object_get_containing_scope(Application_Links *app, Managed_Object object)
{
    Models *models = (Models*)app->cmd_context;
    u32 hi_id = (object >> 32)&max_u32;
    Dynamic_Workspace *workspace = get_dynamic_workspace(models, hi_id);
    if (workspace != 0){
        return((Managed_Scope)hi_id);
    }
    return(0);
}

api(custom) function b32
managed_object_free(Application_Links *app, Managed_Object object)
{
    Models *models = (Models*)app->cmd_context;
    u32 hi_id = (object >> 32)&max_u32;
    Dynamic_Workspace *workspace = get_dynamic_workspace(models, hi_id);
    b32 result = false;
    if (workspace != 0){
        result = managed_object_free(workspace, object);
    }
    return(result);
}

// TODO(allen): ELIMINATE STORE & LOAD
api(custom) function b32
managed_object_store_data(Application_Links *app, Managed_Object object, u32 first_index, u32 count, void *mem)
{
    Models *models = (Models*)app->cmd_context;
    Managed_Object_Ptr_And_Workspace object_ptrs = get_dynamic_object_ptrs(models, object);
    u8 *ptr = get_dynamic_object_memory_ptr(object_ptrs.header);
    b32 result = false;
    if (ptr != 0){
        u32 item_count = object_ptrs.header->count;
        if (0 <= first_index && first_index + count <= item_count){
            u32 item_size = object_ptrs.header->item_size;
            block_copy(ptr + first_index*item_size, mem, count*item_size);
            heap_assert_good(&object_ptrs.workspace->heap);
            result = true;
        }
    }
    return(result);
}

api(custom) function b32
managed_object_load_data(Application_Links *app, Managed_Object object, u32 first_index, u32 count, void *mem_out)
{
    Models *models = (Models*)app->cmd_context;
    Managed_Object_Ptr_And_Workspace object_ptrs = get_dynamic_object_ptrs(models, object);
    u8 *ptr = get_dynamic_object_memory_ptr(object_ptrs.header);
    b32 result = false;
    if (ptr != 0){
        u32 item_count = object_ptrs.header->count;
        if (0 <= first_index && first_index + count <= item_count){
            u32 item_size = object_ptrs.header->item_size;
            block_copy(mem_out, ptr + first_index*item_size, count*item_size);
            heap_assert_good(&object_ptrs.workspace->heap);
            result = true;
        }
    }
    return(result);
}

api(custom) function User_Input
get_next_input_raw(Application_Links *app)
{
    Models *models = (Models*)app->cmd_context;
    Thread_Context *tctx = app->tctx;
    Thread_Context_Extra_Info *tctx_info = (Thread_Context_Extra_Info*)tctx->user_data;
    User_Input result = {};
    if (tctx_info->coroutine != 0){
        Coroutine *coroutine = (Coroutine*)tctx_info->coroutine;
        Co_Out *out = (Co_Out*)coroutine->out;
        out->request = CoRequest_None;
        coroutine_yield(coroutine);
        Co_In *in = (Co_In*)coroutine->in;
        result = in->user_input;
    }
    else{
#define M "ERROR: get_next_input called in a hook that may not make calls to blocking APIs"
        print_message(app, string_u8_litexpr(M));
#undef M
    }
    return(result);
}

api(custom) function i64
get_current_input_sequence_number(Application_Links *app)
{
    Models *models = (Models*)app->cmd_context;
    return(models->current_input_sequence_number);
}

api(custom) function User_Input
get_current_input(Application_Links *app)
{
    Models *models = (Models*)app->cmd_context;
    return(models->current_input);
}

api(custom) function void
set_current_input(Application_Links *app, User_Input *input)
{
    Models *models = (Models*)app->cmd_context;
    block_copy_struct(&models->current_input, input);
}

api(custom) function void
leave_current_input_unhandled(Application_Links *app){
    Models *models = (Models*)app->cmd_context;
    models->current_input_unhandled = true;
}

api(custom) function void
set_custom_hook(Application_Links *app, Hook_ID hook_id, Void_Func *func_ptr){
    Models *models = (Models*)app->cmd_context;
    switch (hook_id){
        case HookID_BufferViewerUpdate:
        {
            models->buffer_viewer_update = (Hook_Function*)func_ptr;
        }break;
        case HookID_DeltaRule:
        {
            models->delta_rule = (Delta_Rule_Function*)func_ptr;
        }break;
        case HookID_ViewEventHandler:
        {
            models->view_event_handler = (Custom_Command_Function*)func_ptr;
        }break;
        case HookID_Tick:
        {
            models->tick = (Tick_Function*)func_ptr;
        }break;
        case HookID_RenderCaller:
        {
            models->render_caller = (Render_Caller_Function*)func_ptr;
        }break;
        case HookID_WholeScreenRenderCaller:
        {
            models->whole_screen_render_caller = (Whole_Screen_Render_Caller_Function*)func_ptr;
        }break;
        case HookID_BufferNameResolver:
        {
            models->buffer_name_resolver = (Buffer_Name_Resolver_Function*)func_ptr;
        }break;
        case HookID_BeginBuffer:
        {
            models->begin_buffer = (Buffer_Hook_Function*)func_ptr;
        }break;
        case HookID_EndBuffer:
        {
            models->end_buffer = (Buffer_Hook_Function*)func_ptr;
        }break;
        case HookID_NewFile:
        {
            models->new_file = (Buffer_Hook_Function*)func_ptr;
        }break;
        case HookID_SaveFile:
        {
            models->save_file = (Buffer_Hook_Function*)func_ptr;
        }break;
        case HookID_BufferEditRange:
        {
            models->buffer_edit_range = (Buffer_Edit_Range_Function*)func_ptr;
        }break;
        case HookID_BufferRegion:
        {
            models->buffer_region = (Buffer_Region_Function*)func_ptr;
        }break;
        case HookID_Layout:
        {
            models->layout_func = (Layout_Function*)func_ptr;
        }break;
        case HookID_ViewChangeBuffer:
        {
            models->view_change_buffer = (View_Change_Buffer_Function*)func_ptr;
        }break;
    }
}

api(custom) function Void_Func*
get_custom_hook(Application_Links *app, Hook_ID hook_id){
    Void_Func *result = 0;
    Models *models = (Models*)app->cmd_context;
    switch (hook_id){
        case HookID_BufferViewerUpdate:
        {
            result = (Void_Func*)models->buffer_viewer_update;
        }break;
        case HookID_DeltaRule:
        {
            result = (Void_Func*)models->delta_rule;
        }break;
        case HookID_ViewEventHandler:
        {
            result = (Void_Func*)models->view_event_handler;
        }break;
        case HookID_Tick:
        {
            result = (Void_Func*)models->tick;
        }break;
        case HookID_RenderCaller:
        {
            result = (Void_Func*)models->render_caller;
        }break;
        case HookID_WholeScreenRenderCaller:
        {
            result = (Void_Func*)models->whole_screen_render_caller;
        }break;
        case HookID_BufferNameResolver:
        {
            result = (Void_Func*)models->buffer_name_resolver;
        }break;
        case HookID_BeginBuffer:
        {
            result = (Void_Func*)models->begin_buffer;
        }break;
        case HookID_EndBuffer:
        {
            result = (Void_Func*)models->end_buffer;
        }break;
        case HookID_NewFile:
        {
            result = (Void_Func*)models->new_file;
        }break;
        case HookID_SaveFile:
        {
            result = (Void_Func*)models->save_file;
        }break;
        case HookID_BufferEditRange:
        {
            result = (Void_Func*)models->buffer_edit_range;
        }break;
        case HookID_BufferRegion:
        {
            result = (Void_Func*)models->buffer_region;
        }break;
        case HookID_Layout:
        {
            result = (Void_Func*)models->layout_func;
        }break;
        case HookID_ViewChangeBuffer:
        {
            result = (Void_Func*)models->view_change_buffer;
        }break;
    }
    return(result);
}

api(custom) function b32
set_custom_hook_memory_size(Application_Links *app, Hook_ID hook_id, u64 size){
    Models *models = (Models*)app->cmd_context;
    b32 result = true;
    switch (hook_id){
        case HookID_DeltaRule:
        {
            models->delta_rule_memory_size = size;
        }break;
        default:
        {
            result = false;
        }break;
    }
    return(result);
}

api(custom) function Mouse_State
get_mouse_state(Application_Links *app)
{
    Models *models = (Models*)app->cmd_context;
    return(models->input->mouse);
}

api(custom) function b32
get_active_query_bars(Application_Links *app, View_ID view_id, i32 max_result_count, Query_Bar_Ptr_Array *array_out)
{
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    b32 result = false;
    if (api_check_view(view)){
        i32 count = 0;
        Query_Bar **ptrs = array_out->ptrs;
        for (Query_Slot *slot = view->query_set.used_slot;
             slot != 0 && (count < max_result_count);
             slot = slot->next){
            if (slot->query_bar != 0){
                ptrs[count++] = slot->query_bar;
            }
        }
        array_out->count = count;
        result = true;
    }
    return(result);
}

api(custom) function b32
start_query_bar(Application_Links *app, Query_Bar *bar, u32 flags)
{
    Models *models = (Models*)app->cmd_context;
    Panel *active_panel = layout_get_active_panel(&models->layout);
    View *active_view = active_panel->view;
    Query_Slot *slot = alloc_query_slot(&active_view->query_set);
    b32 result = (slot != 0);
    if (result){
        slot->query_bar = bar;
    }
    return(result);
}

api(custom) function void
end_query_bar(Application_Links *app, Query_Bar *bar, u32 flags)
{
    Models *models = (Models*)app->cmd_context;
    Panel *active_panel = layout_get_active_panel(&models->layout);
    View *active_view = active_panel->view;
    free_query_slot(&active_view->query_set, bar);
}

api(custom) function void
clear_all_query_bars(Application_Links *app, View_ID view_id){
    Models *models = (Models*)app->cmd_context;
    View *view = imp_get_view(models, view_id);
    if (api_check_view(view)){
        free_all_queries(&view->query_set);
    }
}

api(custom) function void
print_message(Application_Links *app, String_Const_u8 message)
{
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = models->message_buffer;
    if (file != 0){
        output_file_append(app->tctx, models, file, message);
        file_cursor_to_end(app->tctx, models, file);
    }
}

api(custom) function b32
log_string(Application_Links *app, String_Const_u8 str){
    return(log_string(str));
}

api(custom) function Face_ID
get_largest_face_id(Application_Links *app)
{
    Models *models = (Models*)app->cmd_context;
    return(font_set_get_largest_id(&models->font_set));
}

api(custom) function b32
set_global_face(Application_Links *app, Face_ID id)
{
    Models *models = (Models*)app->cmd_context;
    b32 result = false;
    Face *face = font_set_face_from_id(&models->font_set, id);
    if (face != 0){
        models->global_face_id = face->id;
        result = true;
    }
    return(result);
}

api(custom) function History_Record_Index
buffer_history_get_max_record_index(Application_Links *app, Buffer_ID buffer_id){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    History_Record_Index result = 0;
    if (api_check_buffer(file) && history_is_activated(&file->state.history)){
        result = history_get_record_count(&file->state.history);
    }
    return(result);
}

function void
buffer_history__fill_record_info(Record *record, Record_Info *out){
    out->kind = record->kind;
    out->pos_before_edit = record->pos_before_edit;
    out->edit_number = record->edit_number;
    switch (out->kind){
        case RecordKind_Single:
        {
            out->single_string_forward  = record->single.forward_text ;
            out->single_string_backward = record->single.backward_text;
            out->single_first = record->single.first;
        }break;
        case RecordKind_Group:
        {
            out->group_count = record->group.count;
        }break;
        default:
        {
            InvalidPath;
        }break;
    }
}

api(custom) function Record_Info
buffer_history_get_record_info(Application_Links *app, Buffer_ID buffer_id, History_Record_Index index){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    Record_Info result = {};
    if (api_check_buffer(file)){
        History *history = &file->state.history;
        if (history_is_activated(history)){
            i32 max_index = history_get_record_count(history);
            if (0 <= index && index <= max_index){
                if (0 < index){
                    Record *record = history_get_record(history, index);
                    buffer_history__fill_record_info(record, &result);
                }
                else{
                    result.error = RecordError_InitialStateDummyRecord;
                }
            }
            else{
                result.error = RecordError_IndexOutOfBounds;
            }
        }
        else{
            result.error = RecordError_NoHistoryAttached;
        }
    }
    else{
        result.error = RecordError_InvalidBuffer;
    }
    return(result);
}

api(custom) function Record_Info
buffer_history_get_group_sub_record(Application_Links *app, Buffer_ID buffer_id, History_Record_Index index, i32 sub_index){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    Record_Info result = {};
    if (api_check_buffer(file)){
        History *history = &file->state.history;
        if (history_is_activated(history)){
            i32 max_index = history_get_record_count(history);
            if (0 <= index && index <= max_index){
                if (0 < index){
                    Record *record = history_get_record(history, index);
                    if (record->kind == RecordKind_Group){
                        record = history_get_sub_record(record, sub_index + 1);
                        if (record != 0){
                            buffer_history__fill_record_info(record, &result);
                        }
                        else{
                            result.error = RecordError_SubIndexOutOfBounds;
                        }
                    }
                    else{
                        result.error = RecordError_WrongRecordTypeAtIndex;
                    }
                }
                else{
                    result.error = RecordError_InitialStateDummyRecord;
                }
            }
            else{
                result.error = RecordError_IndexOutOfBounds;
            }
        }
        else{
            result.error = RecordError_NoHistoryAttached;
        }
    }
    else{
        result.error = RecordError_InvalidBuffer;
    }
    return(result);
}

api(custom) function History_Record_Index
buffer_history_get_current_state_index(Application_Links *app, Buffer_ID buffer_id){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    History_Record_Index result = 0;
    if (api_check_buffer(file) && history_is_activated(&file->state.history)){
        result = file_get_current_record_index(file);
    }
    return(result);
}

api(custom) function b32
buffer_history_set_current_state_index(Application_Links *app, Buffer_ID buffer_id, History_Record_Index index){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    b32 result = false;
    if (api_check_buffer(file) && history_is_activated(&file->state.history)){
        i32 max_index = history_get_record_count(&file->state.history);
        if (0 <= index && index <= max_index){
            edit_change_current_history_state(app->tctx, models, file, index);
            result = true;
        }
    }
    return(result);
}

api(custom) function b32
buffer_history_merge_record_range(Application_Links *app, Buffer_ID buffer_id, History_Record_Index first_index, History_Record_Index last_index, Record_Merge_Flag flags){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    b32 result = false;
    if (api_check_buffer(file)){
        result = edit_merge_history_range(app->tctx, models, file, first_index, last_index, flags);
    }
    return(result);
}

api(custom) function b32
buffer_history_clear_after_current_state(Application_Links *app, Buffer_ID buffer_id){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    b32 result = false;
    if (api_check_buffer(file) && history_is_activated(&file->state.history)){
        history_dump_records_after_index(&file->state.history, file->state.current_record_index);
        result = true;
    }
    return(result);
}

api(custom) function void
global_history_edit_group_begin(Application_Links *app){
    Models *models = (Models*)app->cmd_context;
    global_history_adjust_edit_grouping_counter(&models->global_history, 1);
}

api(custom) function void
global_history_edit_group_end(Application_Links *app){
    Models *models = (Models*)app->cmd_context;
    global_history_adjust_edit_grouping_counter(&models->global_history, -1);
}

api(custom) function b32
buffer_set_face(Application_Links *app, Buffer_ID buffer_id, Face_ID id)
{
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    
    b32 did_change = false;
    if (api_check_buffer(file)){
        Face *face = font_set_face_from_id(&models->font_set, id);
        if (face != 0){
            file->settings.face_id = face->id;
            did_change = true;
        }
    }
    return(did_change);
}

api(custom) function Face_Description
get_face_description(Application_Links *app, Face_ID face_id)
{
    Models *models = (Models*)app->cmd_context;
    Face_Description description = {};
    if (face_id != 0){
        Face *face = font_set_face_from_id(&models->font_set, face_id);
        if (face != 0){
            description = face->description;
        }
    }
    else{
        description.parameters.aa_mode = FaceAntialiasingMode_8BitMono;
        description.parameters.pt_size = models->settings.font_size;
        description.parameters.hinting = models->settings.use_hinting;
    }
    return(description);
}

api(custom) function Face_Metrics
get_face_metrics(Application_Links *app, Face_ID face_id){
    Models *models = (Models*)app->cmd_context;
    Face_Metrics result = {};
    if (face_id != 0){
        Face *face = font_set_face_from_id(&models->font_set, face_id);
        if (face != 0){
            result = face->metrics;
        }
    }
    return(result);
}

api(custom) function Face_Advance_Map
get_face_advance_map(Application_Links *app, Face_ID face_id){
    Models *models = (Models*)app->cmd_context;
    Face_Advance_Map result = {};
    if (face_id != 0){
        Face *face = font_set_face_from_id(&models->font_set, face_id);
        if (face != 0){
            result = face->advance_map;
        }
    }
    return(result);
}

api(custom) function Face_ID
get_face_id(Application_Links *app, Buffer_ID buffer_id)
{
    Models *models = (Models*)app->cmd_context;
    Face_ID result = 0;
    if (buffer_id != 0){
        Editing_File *file = imp_get_file(models, buffer_id);
        if (api_check_buffer(file)){
            result = file->settings.face_id;
        }
    }
    else{
        result = models->global_face_id;
    }
    return(result);
}

api(custom) function Face_ID
try_create_new_face(Application_Links *app, Face_Description *description)
{
    Models *models = (Models*)app->cmd_context;
    Thread_Context *tctx = app->tctx;
    Thread_Context_Extra_Info *tctx_info = (Thread_Context_Extra_Info*)tctx->user_data;
    Face_ID result = 0;
    if (tctx_info != 0 && tctx_info->coroutine != 0){
        Coroutine *coroutine = (Coroutine*)tctx_info->coroutine;
        Assert(coroutine != 0);
        Co_Out *out = (Co_Out*)coroutine->out;
        out->request = CoRequest_NewFontFace;
        out->face_description = description;
        coroutine_yield(coroutine);
        Co_In *in = (Co_In*)coroutine->in;
        result = in->face_id;
    }
    else if (tctx_info != 0){
        // This API does nothing when called from an async thread.
    }
    else{
        Face *new_face = font_set_new_face(&models->font_set, description);
        if (new_face != 0){
            result = new_face->id;
        }
    }
    return(result);
}

api(custom) function b32
try_modify_face(Application_Links *app, Face_ID id, Face_Description *description)
{
    Models *models = (Models*)app->cmd_context;
    Thread_Context *tctx = app->tctx;
    Thread_Context_Extra_Info *tctx_info = (Thread_Context_Extra_Info*)tctx->user_data;
    b32 result = false;
    if (tctx_info != 0 && tctx_info->coroutine != 0){
        Coroutine *coroutine = (Coroutine*)tctx_info->coroutine;
        Assert(coroutine != 0);
        Co_Out *out = (Co_Out*)coroutine->out;
        out->request = CoRequest_ModifyFace;
        out->face_description = description;
        out->face_id = id;
        coroutine_yield(coroutine);
        Co_In *in = (Co_In*)coroutine->in;
        result = in->success;
    }
    else if (tctx_info != 0){
        // This API does nothing when called from an async thread.
    }
    else{
        result = font_set_modify_face(&models->font_set, id, description);
    }
    return(result);
}

api(custom) function b32
try_release_face(Application_Links *app, Face_ID id, Face_ID replacement_id)
{
    Models *models = (Models*)app->cmd_context;
    Font_Set *font_set = &models->font_set;
    Face *face = font_set_face_from_id(font_set, id);
    Face *replacement = font_set_face_from_id(font_set, replacement_id);
    return(release_font_and_update(models, face, replacement));
}

api(custom) function String_Const_u8
push_hot_directory(Application_Links *app, Arena *arena)
{
    Models *models = (Models*)app->cmd_context;
    Hot_Directory *hot = &models->hot_directory;
    hot_directory_clean_end(hot);
    return(push_string_copy(arena, hot->string));
}

api(custom) function void
set_hot_directory(Application_Links *app, String_Const_u8 string)
{
    Models *models = (Models*)app->cmd_context;
    Hot_Directory *hot = &models->hot_directory;
    hot_directory_set(hot, string);
}

api(custom) function void
send_exit_signal(Application_Links *app)
{
    Models *models = (Models*)app->cmd_context;
    models->keep_playing = false;
}

api(custom) function void
hard_exit(Application_Links *app)
{
    Models *models = (Models*)app->cmd_context;
    models->hard_exit = true;
}

api(custom) function void
set_window_title(Application_Links *app, String_Const_u8 title)
{
    Models *models = (Models*)app->cmd_context;
    models->has_new_title = true;
    u64 cap_before_null = (u64)(models->title_capacity - 1);
    u64 copy_size = clamp_top(title.size, cap_before_null);
    block_copy(models->title_space, title.str, copy_size);
    models->title_space[copy_size] = 0;
}

api(custom) function void
acquire_global_frame_mutex(Application_Links *app){
    Thread_Context *tctx = app->tctx;
    Thread_Context_Extra_Info *tctx_info = (Thread_Context_Extra_Info*)tctx->user_data;
    if (tctx_info != 0 && tctx_info->coroutine != 0){
        Coroutine *coroutine = (Coroutine*)tctx_info->coroutine;
        Assert(coroutine != 0);
        Co_Out *out = (Co_Out*)coroutine->out;
        out->request = CoRequest_AcquireGlobalFrameMutex;
        coroutine_yield(coroutine);
    }
    else{
        system_acquire_global_frame_mutex(tctx);
    }
}

api(custom) function void
release_global_frame_mutex(Application_Links *app){
    Thread_Context *tctx = app->tctx;
    Thread_Context_Extra_Info *tctx_info = (Thread_Context_Extra_Info*)tctx->user_data;
    if (tctx_info != 0 && tctx_info->coroutine != 0){
        Coroutine *coroutine = (Coroutine*)tctx_info->coroutine;
        Assert(coroutine != 0);
        Co_Out *out = (Co_Out*)coroutine->out;
        out->request = CoRequest_ReleaseGlobalFrameMutex;
        coroutine_yield(coroutine);
    }
    else{
        system_release_global_frame_mutex(tctx);
    }
}

////////////////////////////////

api(custom) function Vec2_f32
draw_string_oriented(Application_Links *app, Face_ID font_id, ARGB_Color color,
                     String_Const_u8 str, Vec2_f32 point, u32 flags, Vec2_f32 delta)
{
    Vec2_f32 result = point;
    Models *models = (Models*)app->cmd_context;
    Face *face = font_set_face_from_id(&models->font_set, font_id);
    if (models->target == 0){
        f32 width = font_string_width(models->target, face, str);
        result += delta*width;
    }
    else{
        f32 width = draw_string(models->target, face, str, point, color, flags, delta);
        result += delta*width;
    }
    return(result);
}

api(custom) function f32
get_string_advance(Application_Links *app, Face_ID font_id, String_Const_u8 str)
{
    Models *models = (Models*)app->cmd_context;
    Face *face = font_set_face_from_id(&models->font_set, font_id);
    return(font_string_width(models->target, face, str));
}

api(custom) function void
draw_rectangle(Application_Links *app, Rect_f32 rect, f32 roundness, ARGB_Color color){
    Models *models = (Models*)app->cmd_context;
    if (models->in_render_mode){
        draw_rectangle(models->target, rect, roundness, color);
    }
}

api(custom) function void
draw_rectangle_outline(Application_Links *app, Rect_f32 rect, f32 roundness, f32 thickness, ARGB_Color color){
    Models *models = (Models*)app->cmd_context;
    if (models->in_render_mode){
        draw_rectangle_outline(models->target, rect, roundness, thickness, color);
    }
}

api(custom) function Rect_f32
draw_set_clip(Application_Links *app, Rect_f32 new_clip){
    Models *models = (Models*)app->cmd_context;
    return(draw_set_clip(models->target, new_clip));
}

api(custom) function Text_Layout_ID
text_layout_create(Application_Links *app, Buffer_ID buffer_id, Rect_f32 rect, Buffer_Point buffer_point){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer_id);
    Text_Layout_ID result = 0;
    if (api_check_buffer(file)){
        Thread_Context *tctx = app->tctx;
        Face *face = file_get_face(models, file);
        
        Gap_Buffer *buffer = &file->state.buffer;
        
        Layout_Function *layout_func = file_get_layout_func(file);
        
        Vec2_f32 dim = rect_dim(rect);
        
        i64 line_count = buffer_line_count(buffer);
        i64 line_number = buffer_point.line_number;
        f32 y = -buffer_point.pixel_shift.y;
        for (;line_number <= line_count;
             line_number += 1){
            Layout_Item_List line = file_get_line_layout(tctx, models, file,
                                                         layout_func, dim.x, face,
                                                         line_number);
            f32 next_y = y + line.height;
            if (next_y >= dim.y){
                break;
            }
            y = next_y;
        }
        
        Range_i64 visible_line_number_range = Ii64(buffer_point.line_number, line_number);
        Range_i64 visible_range = Ii64(buffer_get_first_pos_from_line_number(buffer, visible_line_number_range.min),
                                       buffer_get_last_pos_from_line_number(buffer, visible_line_number_range.max));
        
        i64 item_count = range_size_inclusive(visible_range);
        
        Arena arena = make_arena_system();
        Arena *arena_ptr = push_array_zero(&arena, Arena, 1);
        *arena_ptr = arena;
        ARGB_Color *colors_array = push_array_zero(arena_ptr, ARGB_Color, item_count);
        result = text_layout_new(&models->text_layouts, arena_ptr, buffer_id, buffer_point,
                                 visible_range, visible_line_number_range, rect, colors_array,
                                 layout_func);
    }
    return(result);
}

api(custom) function Rect_f32
text_layout_region(Application_Links *app, Text_Layout_ID text_layout_id){
    Models *models = (Models*)app->cmd_context;
    Rect_f32 result = {};
    Text_Layout *layout = text_layout_get(&models->text_layouts, text_layout_id);
    if (layout != 0){
        result = layout->rect;
    }
    return(result);
}

api(custom) function Buffer_ID
text_layout_get_buffer(Application_Links *app, Text_Layout_ID text_layout_id){
    Models *models = (Models*)app->cmd_context;
    Buffer_ID result = 0;
    Text_Layout *layout = text_layout_get(&models->text_layouts, text_layout_id);
    if (layout != 0){
        result = layout->buffer_id;
    }
    return(result);
}

api(custom) function Range_i64
text_layout_get_visible_range(Application_Links *app, Text_Layout_ID text_layout_id){
    Models *models = (Models*)app->cmd_context;
    Range_i64 result = {};
    Text_Layout *layout = text_layout_get(&models->text_layouts, text_layout_id);
    if (layout != 0){
        result = layout->visible_range;
    }
    return(result);
}

api(custom) function Range_f32
text_layout_line_on_screen(Application_Links *app, Text_Layout_ID layout_id, i64 line_number){
    Models *models = (Models*)app->cmd_context;
    Range_f32 result = {};
    Text_Layout *layout = text_layout_get(&models->text_layouts, layout_id);
    if (layout == 0){
        return(result);
    }
    
    Layout_Function *layout_func = layout->layout_func;
    
    Rect_f32 rect = layout->rect;
    if (range_contains_inclusive(layout->visible_line_number_range, line_number)){
        Editing_File *file = imp_get_file(models, layout->buffer_id);
        if (api_check_buffer(file)){
            f32 width = rect_width(rect);
            Face *face = file_get_face(models, file);
            
            for (i64 line_number_it = layout->visible_line_number_range.first;;
                 line_number_it += 1){
                Layout_Item_List line = file_get_line_layout(app->tctx, models, file,
                                                             layout_func, width, face,
                                                             line_number_it);
                result.max += line.height;
                if (line_number_it == line_number){
                    break;
                }
                result.min = result.max;
            }
            
            result += rect.y0 - layout->point.pixel_shift.y;
        }
    }
    else if (line_number < layout->visible_line_number_range.min){
        result = If32(rect.y0, rect.y0);
    }
    else if (line_number > layout->visible_line_number_range.max){
        result = If32(rect.y1, rect.y1);
    }
    
    return(result);
}

api(custom) function Rect_f32
text_layout_character_on_screen(Application_Links *app, Text_Layout_ID layout_id, i64 pos){
    Models *models = (Models*)app->cmd_context;
    Rect_f32 result = {};
    Text_Layout *layout = text_layout_get(&models->text_layouts, layout_id);
    if (layout != 0 && range_contains_inclusive(layout->visible_range, pos)){
        Editing_File *file = imp_get_file(models, layout->buffer_id);
        if (api_check_buffer(file)){
            Gap_Buffer *buffer = &file->state.buffer;
            i64 line_number = buffer_get_line_index(buffer, pos) + 1;
            
            if (range_contains_inclusive(layout->visible_line_number_range, line_number)){
                Rect_f32 rect = layout->rect;
                f32 width = rect_width(rect);
                Face *face = file_get_face(models, file);
                
                Layout_Function *layout_func = layout->layout_func;
                
                f32 y = 0.f;
                Layout_Item_List line = {};
                for (i64 line_number_it = layout->visible_line_number_range.first;;
                     line_number_it += 1){
                    line = file_get_line_layout(app->tctx, models, file,
                                                layout_func, width, face,
                                                line_number_it);
                    if (line_number_it == line_number){
                        break;
                    }
                    y += line.height;
                }
                
                // TODO(allen): optimization: This is some fairly heavy computation.  We really
                // need to accelerate the (pos -> item) lookup within a single
                // Buffer_Layout_Item_List.
                b32 is_first_item = true;
                result = Rf32_negative_infinity;
                for (Layout_Item_Block *block = line.first;
                     block != 0;
                     block = block->next){
                    i64 count = block->item_count;
                    Layout_Item *item_ptr = block->items;
                    for (i32 i = 0; i < count; i += 1, item_ptr += 1){
                        if (HasFlag(item_ptr->flags, LayoutItemFlag_Ghost_Character)){
                            continue;
                        }
                        i64 index = item_ptr->index;
                        if (index == pos){
                            result = rect_union(result, item_ptr->rect);
                        }
                        else if (index > pos){
                            break;
                        }
                    }
                }
                
                Vec2_f32 shift = V2f32(rect.x0, rect.y0 + y) - layout->point.pixel_shift;
                result.p0 += shift;
                result.p1 += shift;
            }
        }
    }
    return(result);
}

api(custom) function void
paint_text_color(Application_Links *app, Text_Layout_ID layout_id, Range_i64 range, ARGB_Color color){
    Models *models = (Models*)app->cmd_context;
    Rect_f32 result = {};
    Text_Layout *layout = text_layout_get(&models->text_layouts, layout_id);
    if (layout != 0){
        range.min = clamp_bot(layout->visible_range.min, range.min);
        range.max = clamp_top(range.max, layout->visible_range.max);
        range.min -= layout->visible_range.min;
        range.max -= layout->visible_range.min;
        ARGB_Color *color_ptr = layout->item_colors + range.min;
        for (i64 i = range.min; i < range.max; i += 1, color_ptr += 1){
            *color_ptr = color;
        }
    }
}

api(custom) function void
paint_text_color_blend(Application_Links *app, Text_Layout_ID layout_id, Range_i64 range, ARGB_Color color, f32 blend){
    Models *models = (Models*)app->cmd_context;
    Rect_f32 result = {};
    Text_Layout *layout = text_layout_get(&models->text_layouts, layout_id);
    if (layout != 0){
        range.min = clamp_bot(layout->visible_range.min, range.min);
        range.max = clamp_top(range.max, layout->visible_range.max);
        range.min -= layout->visible_range.min;
        range.max -= layout->visible_range.min;
        Vec4_f32 color_v4f32 = unpack_color(color);
        Vec4_f32 color_pm_v4f32 = color_v4f32*blend;
        f32 neg_blend = 1.f - blend;
        ARGB_Color *color_ptr = layout->item_colors + range.min;
        for (i64 i = range.min; i < range.max; i += 1, color_ptr += 1){
            Vec4_f32 color_ptr_v4f32 = unpack_color(*color_ptr);
            Vec4_f32 blended_v4f32 = color_ptr_v4f32*neg_blend + color_pm_v4f32;
            *color_ptr = pack_color(blended_v4f32);
        }
    }
}

api(custom) function b32
text_layout_free(Application_Links *app, Text_Layout_ID text_layout_id){
    Models *models = (Models*)app->cmd_context;
    return(text_layout_erase(app->tctx, models, &models->text_layouts, text_layout_id));
}

api(custom) function void
draw_text_layout(Application_Links *app, Text_Layout_ID layout_id, ARGB_Color special_color, ARGB_Color ghost_color){
    Models *models = (Models*)app->cmd_context;
    Text_Layout *layout = text_layout_get(&models->text_layouts, layout_id);
    if (layout != 0 && models->target != 0){
        text_layout_render(app->tctx, models, layout, special_color, ghost_color);
    }
}

api(custom) function void
open_color_picker(Application_Links *app, Color_Picker *picker)
{
    Models *models = (Models*)app->cmd_context;
    if (picker->finished != 0){
        *picker->finished = false;
    }
    system_open_color_picker(picker);
}

api(custom) function void
animate_in_n_milliseconds(Application_Links *app, u32 n)
{
    Models *models = (Models*)app->cmd_context;
    if (n == 0){
        models->animate_next_frame = true;
    }
    else{
        models->next_animate_delay = Min(models->next_animate_delay, n);
    }
}

api(custom) function String_Match_List
buffer_find_all_matches(Application_Links *app, Arena *arena, Buffer_ID buffer,
                        i32 string_id, Range_i64 range, String_Const_u8 needle,
                        Character_Predicate *predicate, Scan_Direction direction){
    Models *models = (Models*)app->cmd_context;
    Editing_File *file = imp_get_file(models, buffer);
    String_Match_List list = {};
    if (api_check_buffer(file)){
        if (needle.size > 0){
            Scratch_Block scratch(app, arena);
            List_String_Const_u8 chunks = buffer_get_chunks(scratch, &file->state.buffer);
            buffer_chunks_clamp(&chunks, range);
            if (chunks.node_count > 0){
                u64_Array jump_table = string_compute_needle_jump_table(arena, needle, direction);
                Character_Predicate dummy = {};
                if (predicate == 0){
                    predicate = &dummy;
                }
                list = find_all_matches(arena, max_i32,
                                        chunks, needle, jump_table, predicate,
                                        direction, range.min, buffer, string_id);
            }
        }
    }
    return(list);
}

////////////////////////////////

api(custom) function Profile_Global_List*
get_core_profile_list(Application_Links *app){
    Models *models = (Models*)app->cmd_context;
    return(&models->profile_list);
}

api(custom) function Doc_Cluster*
get_custom_layer_boundary_docs(Application_Links *app, Arena *arena){
    API_Definition *api_def = custom_api_construct(arena);
    return(doc_custom_api(arena, api_def));
}

// BOTTOM


// end --- 4ed_api_implementation.cpp --- 



// begin --- 4ed_api_parser_main.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 06.10.2019
 *
 * Parser that extracts an API from C++ source code.
 *
 */

// TOP

#include <stdio.h>

////////////////////////////////

int
main(int argc, char **argv){
    Arena arena = make_arena_malloc();
    
    if (argc < 2){
        printf("usage: <script> <source> {<source>}\n"
               " source : file to load and parse into the output list\n");
        exit(1);
    }
    
    API_Definition_List list = {};
    for (i32 i = 1; i < argc; i += 1){
        char *file_name = argv[i];
        FILE *file = fopen(file_name, "rb");
        if (file == 0){
            printf("error: could not open input file: '%s'\n", argv[i]);
            continue;
        }
        
        String_Const_u8 text = data_from_file(&arena, file);
        fclose(file);
        
        if (text.size > 0){
            api_parse_source_add_to_list(&arena, SCu8(file_name), text, &list);
        }
    }
    
    for (API_Definition *node = list.first;
         node != 0;
         node = node->next){
        api_definition_generate_api_includes(&arena, node, GeneratedGroup_Custom, APIGeneration_NoAPINameOnCallables);
    }
}

// BOTTOM


// end --- 4ed_api_parser_main.cpp --- 



// begin --- 4ed_app_models.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 01.05.2020
 *
 * Implementation of the root models features.
 *
 */

// TOP

function void
models_push_view_command_function(Models *models, View_ID view_id, Custom_Command_Function *custom_func){
    Model_View_Command_Function *node = models->free_view_cmd_funcs;
    if (node == 0){
        node = push_array(models->arena, Model_View_Command_Function, 1);
    }
    else{
        sll_stack_pop(models->free_view_cmd_funcs);
    }
    sll_queue_push(models->first_view_cmd_func, models->last_view_cmd_func, node);
    node->view_id = view_id;
    node->custom_func = custom_func;
}

function Model_View_Command_Function
models_pop_view_command_function(Models *models){
    Model_View_Command_Function result = {};
    if (models->first_view_cmd_func != 0){
        Model_View_Command_Function *node = models->first_view_cmd_func;
        result.custom_func = node->custom_func;
        result.view_id = node->view_id;
        sll_queue_pop(models->first_view_cmd_func, models->last_view_cmd_func);
        sll_stack_push(models->free_view_cmd_funcs, node);
    }
    return(result);
}

function void
models_push_virtual_event(Models *models, Input_Event *event){
    Model_Input_Event_Node *node = models->free_virtual_event;
    if (node == 0){
        node = push_array(&models->virtual_event_arena, Model_Input_Event_Node, 1);
    }
    else{
        sll_stack_pop(models->free_virtual_event);
    }
    sll_queue_push(models->first_virtual_event, models->last_virtual_event, node);
    node->event = copy_input_event(&models->virtual_event_arena, event);
}

function Input_Event
models_pop_virtual_event(Arena *arena, Models *models){
    Input_Event result = {};
    if (models->first_virtual_event != 0){
        Model_Input_Event_Node *node = models->first_virtual_event;
        result = copy_input_event(arena, &node->event);
        sll_queue_pop(models->first_virtual_event, models->last_virtual_event);
        sll_stack_push(models->free_virtual_event, node);
    }
    return(result);
}

function void
models_push_wind_down(Models *models, Coroutine *co){
    Model_Wind_Down_Co *node = models->free_wind_downs;
    if (node != 0){
        sll_stack_pop(models->free_wind_downs);
    }
    else{
        node = push_array(models->arena, Model_Wind_Down_Co, 1);
    }
    sll_stack_push(models->wind_down_stack, node);
    node->co = co;
}

// BOTTOM


// end --- 4ed_app_models.cpp --- 



// begin --- 4ed_app_target.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 13.11.2015
 *
 * Application layer build target
 *
 */

// TOP

#define REMOVE_OLD_STRING
#define STATIC_LINK_API
#define DYNAMIC_LINK_API

// begin --- 4ed_font_interface.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 11.03.2017
 *
 * Font system interface.
 *
 */

// TOP

#if !defined(FCODER_FONT_INTERFACE_H)
#define FCODER_FONT_INTERFACE_H

typedef i32 Texture_Kind;
enum{
    TextureKind_Error,
    TextureKind_Mono,
};

typedef u32 Graphics_Get_Texture_Function(Vec3_i32 dim, Texture_Kind texture_kind);
typedef b32 Graphics_Fill_Texture_Function(Texture_Kind texture_kind, u32 texture,
                                           Vec3_i32 p, Vec3_i32 dim, void *data);

////////////////////////////////

struct Glyph_Bounds{
    Rect_f32 uv;
    f32 w;
    Rect_f32 xy_off;
};

struct Face{
    Face_Description description;
    Face_ID id;
    i32 version_number;
    
    // NOTE(allen): Metrics
    Face_Metrics metrics;
    
    // NOTE(allen): Glyph data
    Face_Advance_Map advance_map;
    Glyph_Bounds *bounds;
    Glyph_Bounds white;
    
    Texture_Kind texture_kind;
    u32 texture;
    Vec3_f32 texture_dim;
};

////////////////////////////////

// NOTE(allen): Platform layer calls - implemented in a "font provider"
typedef Face *Font_Make_Face_Function(Arena *arena, Face_Description *description, f32 scale_factor);

#endif

// BOTTOM




// end --- 4ed_font_interface.h --- 


#define DYNAMIC_LINK_API
#define DYNAMIC_LINK_API

// begin --- 4ed_render_target.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 10.11.2017
 *
 * Render target type definition
 *
 */

// TOP

#if !defined(FRED_RENDER_TARGET_H)
#define FRED_RENDER_TARGET_H

struct Render_Free_Texture{
    Render_Free_Texture *next;
    u32 tex_id;
};

struct Render_Vertex{
    Vec2_f32 xy;
    Vec3_f32 uvw;
    u32 color;
    f32 half_thickness;
};

struct Render_Vertex_Array_Node{
    Render_Vertex_Array_Node *next;
    Render_Vertex *vertices;
    i32 vertex_count;
    i32 vertex_max;
};

struct Render_Vertex_List{
    Render_Vertex_Array_Node *first;
    Render_Vertex_Array_Node *last;
    i32 vertex_count;
};

struct Render_Group{
    Render_Group *next;
    Render_Vertex_List vertex_list;
    // parameters
    Face_ID face_id;
    Rect_f32 clip_box;
};

struct Render_Target{
    b8 clip_all;
    i32 width;
    i32 height;
    i32 bound_texture;
    u32 color;
    
    i32 frame_index;
    f32 literal_dt;
    f32 animation_dt;
    
    Render_Free_Texture *free_texture_first;
    Render_Free_Texture *free_texture_last;
    
    Arena arena;
    Render_Group *group_first;
    Render_Group *group_last;
    i32 group_count;
    
    Face_ID current_face_id;
    Rect_f32 current_clip_box;
    void *font_set;
    u32 fallback_texture_id;
};

#endif

// BOTTOM



// end --- 4ed_render_target.h --- 



// begin --- 4ed.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 12.12.2014
 *
 * Application Layer for 4coder
 *
 */

// TOP

#if !defined(FRED_H)
#define FRED_H

#define MAX_VIEWS 16

struct Plat_Settings{
    char *custom_dll;
    b8 custom_dll_is_strict;
    b8 fullscreen_window;
    
    i32 window_w;
    i32 window_h;
    i32 window_x;
    i32 window_y;
    b8 set_window_pos;
    b8 set_window_size;
    b8 maximize_window;
    
    b8 use_hinting;
    
    char *user_directory;
};

#define App_Read_Command_Line_Sig(name) \
void *name(Thread_Context *tctx,\
String_Const_u8 current_directory,\
Plat_Settings *plat_settings,\
char ***files,   \
i32 **file_count,\
i32 argc,        \
char **argv)

typedef App_Read_Command_Line_Sig(App_Read_Command_Line);

struct Custom_API{
    _Get_Version_Type *get_version;
    _Init_APIs_Type *init_apis;
};

#define App_Init_Sig(name) \
void name(Thread_Context *tctx,     \
Render_Target *target,    \
void *base_ptr,           \
String_Const_u8 current_directory,\
Custom_API api)

typedef App_Init_Sig(App_Init);

// begin --- 4ed_cursor_codes.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 07.11.2017
 *
 * Application Cursor Codes
 *
 */

// TOP

#if !defined(FRED_CURSOR_CODES_H)
#define FRED_CURSOR_CODES_H

typedef i32 Application_Mouse_Cursor;
enum{
    APP_MOUSE_CURSOR_DEFAULT,
    APP_MOUSE_CURSOR_ARROW,
    APP_MOUSE_CURSOR_IBEAM,
    APP_MOUSE_CURSOR_LEFTRIGHT,
    APP_MOUSE_CURSOR_UPDOWN,
    // never below this
    APP_MOUSE_CURSOR_COUNT
};

#endif

// BOTTOM



// end --- 4ed_cursor_codes.h --- 



struct Application_Step_Result{
    Application_Mouse_Cursor mouse_cursor_type;
    b32 lctrl_lalt_is_altgr;
    b32 perform_kill;
    b32 animating;
    b32 has_new_title;
    char *title_string;
};

struct Application_Step_Input{
    b32 first_step;
    f32 dt;
    Mouse_State mouse;
    Input_List events;
    String_Const_u8 clipboard;
    b32 trying_to_kill;
};

#define App_Step_Sig(name) Application_Step_Result \
name(Thread_Context *tctx,                 \
Render_Target *target,                \
void *base_ptr,                       \
Application_Step_Input *input)

typedef App_Step_Sig(App_Step);

typedef b32 Log_Function(String_Const_u8 str);
typedef Log_Function *App_Get_Logger(void);
typedef void App_Load_VTables(API_VTable_system *vtable_system,
                              API_VTable_font *vtable_font,
                              API_VTable_graphics *vtable_graphics);

struct App_Functions{
    App_Load_VTables *load_vtables;
    App_Get_Logger *get_logger;
    App_Read_Command_Line *read_command_line;
    App_Init *init;
    App_Step *step;
};

#define App_Get_Functions_Sig(name) App_Functions name()
typedef App_Get_Functions_Sig(App_Get_Functions);

#endif

// BOTTOM



// end --- 4ed.h --- 



// begin --- 4ed_buffer_model.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 18.03.2017
 *
 * Abstract model for the describing the characters of a buffer.
 *
 */

// TOP

#if !defined(FRED_BUFFER_MODEL_H)
#define FRED_BUFFER_MODEL_H

struct Buffer_Model_Step{
    u32 type;
    u32 value;
    i32 i;
    u32 byte_length;
};

struct Buffer_Model_Behavior{
    b32 do_newline;
    b32 do_codepoint_advance;
    b32 do_number_advance;
};

enum{
    BufferModelUnit_None,
    BufferModelUnit_Codepoint,
    BufferModelUnit_Numbers,
};

#endif

// BOTTOM



// end --- 4ed_buffer_model.h --- 



// begin --- 4ed_coroutine.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 03.08.2019
 *
 * Coroutine implementation from thread+mutex+cv
 *
 */

// TOP

#if !defined(FRED_COROUTINE_H)
#define FRED_COROUTINE_H

typedef void Coroutine_Function(struct Coroutine *head);

typedef u32 Coroutine_State;
enum{
    CoroutineState_Dead,
    CoroutineState_Active,
    CoroutineState_Inactive,
    CoroutineState_Waiting,
};

typedef u32 Coroutine_Type;
enum{
    CoroutineType_Uninitialized,
    CoroutineType_Root,
    CoroutineType_Sub,
};

struct Coroutine{
    Coroutine *next;
    Thread_Context *tctx;
    void *in;
    void *out;
    System_Thread thread;
    System_Condition_Variable cv;
    struct Coroutine_Group *sys;
    Coroutine_Function *func;
    Coroutine *yield_ctx;
    Coroutine_State state;
    Coroutine_Type type;
    void *user_data;
};

struct Coroutine_Group{
    Arena arena;
    System_Mutex lock;
    System_Condition_Variable init_cv;
    b32 did_init;
    Coroutine *active;
    Coroutine *unused;
    Coroutine root;
};

////////////////////////////////

typedef i32 Coroutine_Pass_Control;
enum{
    CoroutinePassControl_ExitMe,
    CoroutinePassControl_BlockMe,
};

#endif

// BOTTOM


// end --- 4ed_coroutine.h --- 



// begin --- 4ed_dynamic_variables.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 22.06.2018
 *
 * Dynamic variable system
 *
 */

// TOP

#if !defined(FRED_DYNAMIC_VARIABLES_H)
#define FRED_DYNAMIC_VARIABLES_H

union Managed_Object_Standard_Header{
    u64 eight_byte_alignment__;
    struct{
        Managed_Object_Type type;
        u32 item_size;
        u32 count;
    };
};

struct Managed_Memory_Header{
    Managed_Object_Standard_Header std_header;
};

struct Managed_Buffer_Markers_Header{
    Managed_Object_Standard_Header std_header;
    Managed_Buffer_Markers_Header *next;
    Managed_Buffer_Markers_Header *prev;
    Buffer_ID buffer_id;
};

struct Managed_Arena_Header{
    Managed_Object_Standard_Header std_header;
    Managed_Arena_Header *next;
    Managed_Arena_Header *prev;
    Arena arena;
};

global_const i32 managed_header_type_sizes[ManagedObjectType_COUNT] = {
    0,
    sizeof(Managed_Memory_Header),
    sizeof(Managed_Buffer_Markers_Header),
    sizeof(Managed_Arena_Header),
};

struct Managed_Buffer_Markers_Header_List{
    Managed_Buffer_Markers_Header *first;
    Managed_Buffer_Markers_Header *last;
    i32 count;
};

struct Managed_Arena_Header_List{
    Managed_Arena_Header *first;
    Managed_Arena_Header *last;
    i32 count;
};

////////////////////////////////

struct Managed_ID_Group{
    Table_Data_u64 name_to_id_table;
    Managed_ID id_counter;
};

struct Managed_ID_Set{
    Arena arena;
    Table_Data_u64 name_to_group_table;
};

struct Dynamic_Variable_Block{
    Arena arena;
    Table_u64_Data id_to_data_table;
};

////////////////////////////////

struct Dynamic_Workspace{
    Dynamic_Variable_Block var_block;
    Heap heap;
    Base_Allocator heap_wrapper;
    Table_u64_u64 object_id_to_object_ptr;
    u32 object_id_counter;
    u32 visual_id_counter;
    u32 scope_id;
    i32 user_type;
    void *user_back_ptr;
    Managed_Buffer_Markers_Header_List buffer_markers_list;
    Managed_Arena_Header_List arena_list;
    i32 total_marker_count;
};

////////////////////////////////

global_const i32 lifetime_key_reference_per_node = 32;

struct Lifetime_Key_Ref_Node{
    Lifetime_Key_Ref_Node *next;
    Lifetime_Key_Ref_Node *prev;
    struct Lifetime_Key *keys[lifetime_key_reference_per_node];
};

union Lifetime_Object{
    Lifetime_Object *next;
    struct{
        Lifetime_Key_Ref_Node *key_node_first;
        Lifetime_Key_Ref_Node *key_node_last;
        i32 key_count;
        Dynamic_Workspace workspace;
    };
};

struct Lifetime_Key{
    union{
        struct{
            Lifetime_Key *next;
            Lifetime_Key *prev;
        };
        struct{
            Lifetime_Object **members;
            i32 count;
            Dynamic_Workspace dynamic_workspace;
        };
    };
};

global_const u64 LifetimeKeyHash_Empty   = 0&(~bit_63);
global_const u64 LifetimeKeyHash_Deleted = max_u64&(~bit_63);

struct Lifetime_Allocator{
    Base_Allocator *allocator;
    Arena node_arena;
    Lifetime_Key_Ref_Node *free_key_references;
    Lifetime_Key* free_keys;
    Lifetime_Object *free_objects;
    Table_Data_u64 key_table;
    Table_u64_u64 key_check_table;
    Table_u64_u64 scope_id_to_scope_ptr_table;
    u32 scope_id_counter;
};

struct Lifetime_Key_With_Opaque_ID{
    Lifetime_Key *key;
    u64 opaque_id;
};

////////////////////////////////

struct Managed_Object_Ptr_And_Workspace{
    Dynamic_Workspace *workspace;
    Managed_Object_Standard_Header *header;
};

#endif

// BOTTOM



// end --- 4ed_dynamic_variables.h --- 



// begin --- 4ed_translation.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 24.01.2018
 *
 * Buffer types
 *
 */

// TOP

#if !defined(FRED_TRANSLATION_H)
#define FRED_TRANSLATION_H

struct Translation_State{
    u8 fill_buffer[4];
    u32 fill_start_i;
    u8 fill_i;
    u8 fill_expected;
};

enum{
    TranLBH_None,
    TranLBH_Rebuffer,
    TranLBH_EmitAsCP,
};
struct Translation_Byte_Description{
    u8 byte_class;
    u8 last_byte_handler;
    u8 prelim_emit_type;
};

struct Translation_Emit_Rule{
    u8 byte_class;
    u8 last_byte_handler;
    u8 emit_type;
    
    u32 codepoint;
    u32 codepoint_length;
};

struct Translation_Emits{
    Buffer_Model_Step steps[5];
    u32 step_count;
};

#endif

// BOTTOM



// end --- 4ed_translation.h --- 



// begin --- 4ed_buffer.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 24.01.2018
 *
 * Buffer types
 *
 */

// TOP

#if !defined(FRED_BUFFER_H)
#define FRED_BUFFER_H

struct Cursor_With_Index{
    i64 pos;
    i32 index;
};

struct Gap_Buffer{
    Base_Allocator *allocator;
    
    u8 *data;
    i64 size1;
    i64 gap_size;
    i64 size2;
    i64 max;
    
    // NOTE(allen): If there are N lines I store N + 1 slots in this array with
    // line_starts[N] = size of the buffer.
    //    The variable line_start_count stores N + 1; call buffer_line_count(buffer)
    // to get "N" the actual number of lines.
    i64 *line_starts;
    i64 line_start_count;
    i64 line_start_max;
};

struct Buffer_Chunk_Position{
    i64 real_pos;
    i64 chunk_pos;
    i64 chunk_index;
};

typedef i32 Line_Move_Kind;
enum{
    LineMove_ShiftOldValues,
    LineMove_MeasureString,
};
struct Line_Move{
    Line_Move *next;
    Line_Move_Kind kind;
    i64 new_line_first;
    union{
        struct{
            i64 old_line_first;
            i64 old_line_opl;
            i64 text_shift;
        };
        struct{
            String_Const_u8 string;
            i64 text_base;
        };
    };
};

#endif

// BOTTOM


// end --- 4ed_buffer.h --- 



// begin --- 4ed_history.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 24.03.2018
 *
 * History
 *
 */

// TOP

#if !defined(FRED_HISTORY_H)
#define FRED_HISTORY_H

struct Record_Batch_Slot{
    i64 length_forward;
    i64 length_backward;
    i32 first;
};

struct Record{
    Node node;
    Temp_Memory restore_point;
    i64 pos_before_edit;
    i32 edit_number;
    Record_Kind kind;
    union{
        struct{
            String_Const_u8 forward_text;
            String_Const_u8 backward_text;
            i64 first;
        } single;
        struct{
            Node children;
            i32 count;
        } group;
    };
};

struct Record_Ptr_Lookup_Table{
    Record **records;
    i32 count;
    i32 max;
};

struct History{
    b32 activated;
    Arena arena;
    Heap heap;
    Base_Allocator heap_wrapper;
    Node free_records;
    Node records;
    i32 record_count;
    Record_Ptr_Lookup_Table record_lookup;
};

struct Global_History{
    i32 edit_number_counter;
    i32 edit_grouping_counter;
};

#endif

// BOTTOM


// end --- 4ed_history.h --- 



// begin --- 4ed_file.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 24.01.2018
 *
 * Buffer types
 *
 */

// TOP

#if !defined(FRED_FILE_H)
#define FRED_FILE_H

typedef i32 Edit_Pos_Set_Type;
enum{
    EditPos_None,
    EditPos_CursorSet,
    EditPos_ScrollSet
};
struct File_Edit_Positions{
    Edit_Pos_Set_Type last_set_type;
    Buffer_Scroll scroll;
    i64 cursor_pos;
};

struct Editing_File_Settings{
    Layout_Function *layout_func;
    Face_ID face_id;
    b8 dos_write_mode;
    b8 is_initialized;
    b8 unimportant;
    b8 read_only;
    b8 unkillable;
    b8 never_kill;
};

struct Line_Layout_Key{
    Face_ID face_id;
    i32 face_version_number;
    f32 width;
    i64 line_number;
};

typedef i32 File_Save_State;
enum{
    FileSaveState_Normal,
    FileSaveState_SavedWaitingForNotification,
};

struct Editing_File_State{
    Gap_Buffer buffer;
    
    History history;
    i32 current_record_index;
    i32 saved_record_index;
    
    Dirty_State dirty;
    File_Save_State save_state;
    
    File_Edit_Positions edit_pos_most_recent;
    File_Edit_Positions edit_pos_stack[16];
    i32 edit_pos_stack_top;
    
    Child_Process_ID attached_child_process;
    
    Arena cached_layouts_arena;
    Table_Data_u64 line_layout_table;
};

struct Editing_File_Name{
    u8 name_space[256];
    u64 name_size;
};

struct Editing_File{
    union{
        Editing_File *next;
        Node main_chain_node;
    };
    Node touch_node;
    Node external_mod_node;
    Buffer_ID id;
    Editing_File_Settings settings;
    Editing_File_State state;
    File_Attributes attributes;
    Lifetime_Object *lifetime_object;
    Editing_File_Name base_name;
    Editing_File_Name unique_name;
    Editing_File_Name canon;
};

struct Buffer_Point_Delta{
    Buffer_Point new_point;
    f32 y_shift;
};

#endif

// BOTTOM



// end --- 4ed_file.h --- 



// begin --- 4ed_working_set.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 24.03.2018
 *
 * Working_Set data structure
 *
 */

// TOP

#if !defined(FRED_WORKING_SET_H)
#define FRED_WORKING_SET_H

struct Working_Set{
    // NOTE(allen): After initialization of file_change_thread
    // the members of this struct should only be accessed by a thread
    // who owns the mutex member.
    
    Arena arena;
    
    Editing_File *free_files;
    Buffer_ID id_counter;
    
    Node active_file_sentinel;
    Node touch_order_sentinel;
    i32 active_file_count;
    
    Table_u64_u64 id_to_ptr_table;
    Table_Data_u64 canon_table;
    Table_Data_u64 name_table;
    
    Node *sync_check_iterator;
    Node has_external_mod_sentinel;
    System_Mutex mutex;
    System_Thread file_change_thread;
};

#endif

// BOTTOM



// end --- 4ed_working_set.h --- 



// begin --- 4ed_hot_directory.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 24.01.2018
 *
 * Buffer types
 *
 */

// TOP

#if !defined(FRED_HOT_DIRECTORY_H)
#define FRED_HOT_DIRECTORY_H

struct Hot_Directory{
    Arena arena;
    String_Const_u8 string;
    String_Const_u8 canonical;
    File_List file_list;
};

#endif

// BOTTOM



// end --- 4ed_hot_directory.h --- 



// begin --- 4ed_cli.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 24.03.2018
 *
 * CLI handling code.
 *
 */

// TOP

#if !defined(FRED_CLI_H)
#define FRED_CLI_H

struct Child_Process{
    Node node;
    Child_Process_ID id;
    CLI_Handles cli;
    Editing_File *out_file;
    b32 cursor_at_end;
};

struct Child_Process_Container{
    Arena arena;
    Node child_process_active_list;
    Node child_process_free_list;
    i32 active_child_process_count;
    u32 child_process_id_counter;
    Table_u64_u64 id_to_ptr_table;
    Table_u64_u64 id_to_return_code_table;
};

struct Child_Process_And_ID{
    Child_Process *process;
    Child_Process_ID id;
};

#endif

// BOTTOM



// end --- 4ed_cli.h --- 



// begin --- 4ed_layout.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 24.03.2018
 *
 * Panel layout structures
 *
 */

// TOP

#if !defined(FRED_LAYOUT_H)
#define FRED_LAYOUT_H

struct Panel_Split{
    Panel_Split_Kind kind;
    union{
        f32 v_f32;
        i32 v_i32;
    };
};

typedef i32 Panel_Kind;
enum{
    PanelKind_Unused = 0,
    PanelKind_Intermediate = 1,
    PanelKind_Final = 2,
};

struct Panel{
    Node node;
    
    Panel *parent;
    Panel_Kind kind;
    union{
        struct View *view;
        struct{
            struct Panel *tl_panel;
            struct Panel *br_panel;
            b32 vertical_split;
            Panel_Split split;
        };
    };
    
    union{
        struct{
            Rect_i32 rect_full;
            Rect_i32 rect_inner;
        } screen_region;
        struct{
            Rect_i32 rect_full;
            Rect_i32 rect_inner;
        };
    };
};

struct Layout{
    Node free_panels;
    Node open_panels;
    Node intermediate_panels;
    
    Panel *root;
    Panel *active_panel;
    Panel *panel_first;
    Panel *panel_one_past_last;
    
    i32 margin;
    i32 open_panel_count;
    i32 open_panel_max_count;
    Vec2_i32 full_dim;
    b32 panel_state_dirty;
};

#endif

// BOTTOM



// end --- 4ed_layout.h --- 



// begin --- 4ed_view.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 17.07.2017
 *
 * File editing view for 4coder.
 *
 */

// TOP

#if !defined(FRED_VIEW_H)
#define FRED_VIEW_H

struct Co_In{
    union{
        struct{
            struct Models *models;
            Custom_Command_Function *event_context_base;
        };
        User_Input user_input;
        Face_ID face_id;
        b32 success;
    };
};

typedef i32 Co_Request;
enum{
    CoRequest_None = 0,
    CoRequest_NewFontFace = 1,
    CoRequest_ModifyFace = 2,
    CoRequest_AcquireGlobalFrameMutex = 3,
    CoRequest_ReleaseGlobalFrameMutex = 4,
};

struct Co_Out{
    Co_Request request;
    Face_Description *face_description;
    Face_ID face_id;
};

struct Query_Slot{
    Query_Slot *next;
    Query_Bar *query_bar;
};

struct Query_Set{
    Query_Slot slots[8];
    Query_Slot *free_slot;
    Query_Slot *used_slot;
};

struct View_Context_Node{
    View_Context_Node *next;
    Temp_Memory pop_me;
    View_Context ctx;
    void *delta_rule_memory;
};

struct View{
    View *next;
    View *prev;
    struct Panel *panel;
    b32 in_use;
    
    Editing_File *file;
    Lifetime_Object *lifetime_object;
    
    File_Edit_Positions edit_pos_;
    i64 mark;
    f32 preferred_x;
    Vec2_f32 cursor_margin;
    Vec2_f32 cursor_push_in_multiplier;
    
    b8 new_scroll_target;
    b8 hide_scrollbar;
    b8 hide_file_bar;
    b8 show_whitespace;
    
    Coroutine *co;
    Co_Out co_out;
    
    Arena node_arena;
    View_Context_Node *ctx;
    
    Query_Set query_set;
};

struct Live_Views{
    View *views;
    View free_sentinel;
    i32 count;
    i32 max;
};

#endif

// BOTTOM



// end --- 4ed_view.h --- 



// begin --- 4ed_edit.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 07.02.2019
 *
 * Types used for edit operations
 *
 */

// TOP

#if !defined(FRED_EDIT_H)
#define FRED_EDIT_H

struct Edit_Behaviors{
    b32 do_not_post_to_history;
    i64 pos_before_edit;
};

#endif

// BOTTOM



// end --- 4ed_edit.h --- 



// begin --- 4ed_text_layout.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 31.03.2019
 *
 * Text layout representation
 *
 */

// TOP

#if !defined(FRED_TEXT_LAYOUT_H)
#define FRED_TEXT_LAYOUT_H

union Text_Layout{
    Text_Layout *next;
    struct{
        Arena *arena;
        Buffer_ID buffer_id;
        Buffer_Point point;
        Range_i64 visible_range;
        Range_i64 visible_line_number_range;
        Rect_f32 rect;
        ARGB_Color *item_colors;
        Layout_Function *layout_func;
    };
};

struct Text_Layout_Container{
    Arena node_arena;
    Text_Layout *free_nodes;
    Table_u64_u64 table;
    Text_Layout_ID id_counter;
};

#endif

// BOTTOM



// end --- 4ed_text_layout.h --- 



// begin --- 4ed_font_set.h --- 

/*
* Mr. 4th Dimention - Allen Webster
*
* 23.07.2019
*
* Type for organizating the set of all loaded font faces.
*
*/

// TOP

#if !defined(FRED_FONT_SET_H)
#define FRED_FONT_SET_H

struct Font_Face_ID_Node{
    Font_Face_ID_Node *next;
    Face_ID id;
};

union Font_Face_Slot{
    struct{
        Font_Face_Slot *next;
    };
    struct{
        Arena arena;
        Face *face;
    };
};

struct Font_Set{
    Arena arena;
    Face_ID next_id_counter;
    Font_Face_ID_Node *free_ids;
    Font_Face_ID_Node *free_id_nodes;
    Font_Face_Slot *free_face_slots;
    Table_u64_u64 id_to_slot_table;
    f32 scale_factor;
};

#endif

// BOTTOM



// end --- 4ed_font_set.h --- 



// begin --- 4ed_log.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 14.08.2019
 *
 * Core logging structures.
 *
 */

// TOP

#if !defined(FRED_LOG_H)
#define FRED_LOG_H

struct Log{
    System_Mutex mutex;
    Arena arena;
    List_String_Const_u8 list;
    volatile i32 disabled_thread_id;
    b32 stdout_log_enabled;
};

#endif

// BOTTOM

// end --- 4ed_log.h --- 



// begin --- 4ed_app_models.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 06.05.2016 (dd.mm.yyyy)
 *
 * Global app level settings definition
 *
 */

// TOP

#if !defined(FRED_APP_MODELS_H)
#define FRED_APP_MODELS_H

struct App_Settings{
    char *init_files[8];
    i32 init_files_count;
    i32 init_files_max;
    
    char **custom_flags;
    i32 custom_flags_count;
    
    b32 lctrl_lalt_is_altgr;
    
    i32 font_size;
    b8 use_hinting;
};

enum App_State{
    APP_STATE_EDIT,
    APP_STATE_RESIZING,
    // never below this
    APP_STATE_COUNT
};

struct Model_View_Command_Function{
    Model_View_Command_Function *next;
    Custom_Command_Function *custom_func;
    View_ID view_id;
};

struct Model_Input_Event_Node{
    Model_Input_Event_Node *next;
    Input_Event event;
};

struct Model_Wind_Down_Co{
    Model_Wind_Down_Co *next;
    Coroutine *co;
};

struct Models{
    Arena arena_;
    Arena *arena;
    Heap heap;
    
    App_Settings settings;
    App_State state;
    
    Face_ID global_face_id;
    
    Coroutine_Group coroutines;
    Model_Wind_Down_Co *wind_down_stack;
    Model_Wind_Down_Co *free_wind_downs;
    
    Child_Process_Container child_processes;
    Custom_API config_api;
    
    Tick_Function *tick;
    Render_Caller_Function *render_caller;
    Whole_Screen_Render_Caller_Function *whole_screen_render_caller;
    Delta_Rule_Function *delta_rule;
    u64 delta_rule_memory_size;
    
    Hook_Function *buffer_viewer_update;
    Custom_Command_Function *view_event_handler;
    Buffer_Name_Resolver_Function *buffer_name_resolver;
    Buffer_Hook_Function *begin_buffer;
    Buffer_Hook_Function *end_buffer;
    Buffer_Hook_Function *new_file;
    Buffer_Hook_Function *save_file;
    Buffer_Edit_Range_Function *buffer_edit_range;
    Buffer_Region_Function *buffer_region;
    Layout_Function *layout_func;
    View_Change_Buffer_Function *view_change_buffer;
    
    Color_Table color_table_;
    
    Model_View_Command_Function *free_view_cmd_funcs;
    Model_View_Command_Function *first_view_cmd_func;
    Model_View_Command_Function *last_view_cmd_func;
    
    Arena virtual_event_arena;
    Model_Input_Event_Node *free_virtual_event;
    Model_Input_Event_Node *first_virtual_event;
    Model_Input_Event_Node *last_virtual_event;
    
    Layout layout;
    Working_Set working_set;
    Live_Views view_set;
    Global_History global_history;
    Text_Layout_Container text_layouts;
    Font_Set font_set;
    
    Managed_ID_Set managed_id_set;
    Dynamic_Workspace dynamic_workspace;
    Lifetime_Allocator lifetime_allocator;
    
    Editing_File *message_buffer;
    Editing_File *scratch_buffer;
    Editing_File *log_buffer;
    Editing_File *keyboard_buffer;
    
    Hot_Directory hot_directory;
    
    b8 keep_playing;
    b8 hard_exit;
    
    b8 has_new_title;
    i32 title_capacity;
    char *title_space;
    
    Panel *resizing_intermediate_panel;
    
    Plat_Handle period_wakeup_timer;
    i32 frame_counter;
    u32 next_animate_delay;
    b32 animate_next_frame;
    
    Profile_Global_List profile_list;
    
    // Last frame state
    Vec2_i32 prev_p;
    Panel *prev_mouse_panel;
    b32 animated_last_frame;
    u64 last_render_usecond_stamp;
    
    // Event Context
    Application_Step_Input *input;
    i64 current_input_sequence_number;
    User_Input current_input;
    b8 current_input_unhandled;
    
    b8 in_render_mode;
    Render_Target *target;
};

////////////////////////////////

typedef i32 Dynamic_Workspace_Type;
enum{
    DynamicWorkspace_Global = 0,
    DynamicWorkspace_Unassociated = 1,
    DynamicWorkspace_Buffer = 2,
    DynamicWorkspace_View = 3,
    DynamicWorkspace_Intersected = 4,
};

enum Input_Types{
    Input_AnyKey,
    Input_Esc,
    Input_MouseMove,
    Input_MouseLeftButton,
    Input_MouseRightButton,
    Input_MouseWheel,
    Input_Count
};

struct Consumption_Record{
    b32 consumed;
    char consumer[32];
};

struct File_Init{
    String_Const_u8 name;
    Editing_File **ptr;
    b32 read_only;
};

enum Command_Line_Action{
    CLAct_Nothing,
    CLAct_Ignore,
    CLAct_CustomDLL,
    CLAct_WindowSize,
    CLAct_WindowMaximize,
    CLAct_WindowPosition,
    CLAct_WindowFullscreen,
    CLAct_FontSize,
    CLAct_FontUseHinting,
    CLAct_UserDirectory,
    //
    CLAct_COUNT,
};

enum Command_Line_Mode{
    CLMode_App,
    CLMode_Custom
};

#endif

// BOTTOM



// end --- 4ed_app_models.h --- 



////////////////////////////////
#define DYNAMIC_LINK_API
#define DYNAMIC_LINK_API
#define DYNAMIC_LINK_API

// begin --- 4ed_log.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 14.08.2019
 *
 * Core logging implementation.
 *
 */

// TOP

global Log global_log = {};

internal void
log_init(void){
    global_log.mutex = system_mutex_make();
    global_log.arena = make_arena_system();
}

internal b32
log_string(String_Const_u8 str){
    b32 result = false;
    i32 thread_id = system_thread_get_id();
    if (global_log.disabled_thread_id != thread_id){
        system_mutex_acquire(global_log.mutex);
        string_list_push(&global_log.arena, &global_log.list, push_string_copy(&global_log.arena, str));
        system_mutex_release(global_log.mutex);
        result = true;
    }
    return(result);
}

internal void
output_file_append(Thread_Context *tctx, Models *models, Editing_File *file, String_Const_u8 value);

internal b32
log_flush(Thread_Context *tctx, Models *models){
    b32 result = false;
    
    system_mutex_acquire(global_log.mutex);
    global_log.disabled_thread_id = system_thread_get_id();
    
    if (global_log.list.total_size > 0){
        String_Const_u8 text = string_list_flatten(&global_log.arena, global_log.list);
        output_file_append(tctx, models, models->log_buffer, text);
        result = true;
    }
    linalloc_clear(&global_log.arena);
    block_zero_struct(&global_log.list);
    
    global_log.disabled_thread_id = 0;
    system_mutex_release(global_log.mutex);
    
    return(result);
}

// BOTTOM


// end --- 4ed_log.cpp --- 



// begin --- 4ed_coroutine.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 19.07.2017
 *
 * Coroutine implementation from thread+mutex+cv
 *
 */

// TOP

internal void
coroutine__pass_control(Coroutine *me, Coroutine *other,
                        Coroutine_State my_new_state, Coroutine_Pass_Control control){
    Assert(me->state == CoroutineState_Active);
    Assert(me->sys == other->sys);
    
    me->state = my_new_state;
    other->state = CoroutineState_Active;
    me->sys->active = other;
    system_condition_variable_signal(other->cv);
    if (control == CoroutinePassControl_BlockMe){
        for (;me->state != CoroutineState_Active;){
            system_condition_variable_wait(me->cv, me->sys->lock);
        }
    }
}

internal void
coroutine_main(void *ptr){
    Coroutine *me = (Coroutine*)ptr;
    
    Thread_Context_Extra_Info tctx_info = {};
    tctx_info.coroutine = me;
    
    Thread_Context tctx_ = {};
    thread_ctx_init(&tctx_, ThreadKind_MainCoroutine,
                    get_base_allocator_system(), get_base_allocator_system());
    tctx_.user_data = &tctx_info;
    me->tctx = &tctx_;
    
    // NOTE(allen): Init handshake
    Assert(me->state == CoroutineState_Dead);
    system_mutex_acquire(me->sys->lock);
    me->sys->did_init = true;
    system_condition_variable_signal(me->sys->init_cv);
    
    for (;;){
        // NOTE(allen): Wait until someone wakes us up, then go into our procedure.
        for (;me->state != CoroutineState_Active;){
            system_condition_variable_wait(me->cv, me->sys->lock);
        }
        Assert(me->type != CoroutineType_Root);
        Assert(me->yield_ctx != 0);
        Assert(me->func != 0);
        
        me->func(me);
        
        // NOTE(allen): Wake up the caller and set this coroutine back to being dead.
        Coroutine *other = me->yield_ctx;
        Assert(other != 0);
        Assert(other->state == CoroutineState_Waiting);
        
        coroutine__pass_control(me, other, CoroutineState_Dead, CoroutinePassControl_ExitMe);
        me->func = 0;
    }
}

internal void
coroutine_sub_init(Coroutine *co, Coroutine_Group *sys){
    block_zero_struct(co);
    co->sys = sys;
    co->state = CoroutineState_Dead;
    co->type = CoroutineType_Sub;
    co->cv = system_condition_variable_make();
    sys->did_init = false;
    co->thread = system_thread_launch(coroutine_main, co);
    for (;!sys->did_init;){
        system_condition_variable_wait(sys->init_cv, sys->lock);
    }
}

internal void
coroutine_system_init(Coroutine_Group *sys){
    sys->arena = make_arena_system();
    
    Coroutine *root = &sys->root;
    
    sys->lock = system_mutex_make();
    sys->init_cv = system_condition_variable_make();
    sys->active = root;
    
    block_zero_struct(root);
    root->sys = sys;
    root->state = CoroutineState_Active;
    root->type = CoroutineType_Root;
    root->cv = system_condition_variable_make();
    
    sys->unused = 0;
    
    system_mutex_acquire(sys->lock);
}

internal Coroutine*
coroutine_system_alloc(Coroutine_Group *sys){
    Coroutine *result = sys->unused;
    if (result != 0){
        sll_stack_pop(sys->unused);
    }
    else{
        result = push_array(&sys->arena, Coroutine, 1);
        coroutine_sub_init(result, sys);
    }
    result->next = 0;
    return(result);
}

internal void
coroutine_system_free(Coroutine_Group *sys, Coroutine *coroutine){
    sll_stack_push(sys->unused, coroutine);
}

////////////////////////////////

internal Coroutine*
coroutine_create(Coroutine_Group *coroutines, Coroutine_Function *func){
    Coroutine *result = coroutine_system_alloc(coroutines);
    Assert(result->state == CoroutineState_Dead);
    result->func = func;
    return(result);
}

internal Coroutine*
coroutine_run(Coroutine_Group *sys, Coroutine *other, void *in, void *out){
    other->in = in;
    other->out = out;
    
    Coroutine *me = other->sys->active;
    Assert(me != 0);
    Assert(me->sys == other->sys);
    Assert(other->state == CoroutineState_Dead || other->state == CoroutineState_Inactive);
    other->yield_ctx = me;
    coroutine__pass_control(me, other, CoroutineState_Waiting, CoroutinePassControl_BlockMe);
    Assert(me == other->sys->active);
    
    Coroutine *result = other;
    if (other->state == CoroutineState_Dead){
        coroutine_system_free(sys, other);
        result = 0;
    }
    return(result);
}

internal void
coroutine_yield(Coroutine *me){
    Coroutine *other = me->yield_ctx;
    Assert(other != 0);
    Assert(me->sys == other->sys);
    Assert(other->state == CoroutineState_Waiting);
    coroutine__pass_control(me, other, CoroutineState_Inactive, CoroutinePassControl_BlockMe);
}

// BOTTOM



// end --- 4ed_coroutine.cpp --- 



// begin --- 4ed_mem.cpp --- 

/*
* Mr. 4th Dimention - Allen Webster
 *
 * 30.08.2016
 *
 * Replacements for common memory block managing functions.
 */

// TOP

// TODO(allen): Make these as fast as possible

#if 0
internal void
block_zero(void *a, u64 size){
    for (u8 *ptr = (u8*)a, *e = ptr + size; ptr < e; ptr += 1){
        *ptr = 0;
    }
}
internal void
block_fill_ones(void *a, u64 size){
    for (u8 *ptr = (u8*)a, *e = ptr + size; ptr < e; ptr += 1){
        *ptr = 0xFF;
    }
}
internal void
block_copy(void *dst, void *src, u64 size){
    for (u8 *d = (u8*)dst, *s = (u8*)src, *e = s + size; s < e; d += 1, s += 1){
        *d = *s;
    }
}
internal i32
block_compare(void *a, void *b, u64 size){
    for (u8 *aptr = (u8*)a, *bptr = (u8*)b, *e = bptr + size; bptr < e; aptr += 1, bptr += 1){
        i32 dif = (i32)*aptr - (i32)*bptr;
        if (dif != 0){
            return(dif > 0?1:-1);
        }
    }
    return(0);
}
internal void
block_fill_u8(void *a, u64 size, u8 val){
    for (u8 *ptr = (u8*)a, *e = ptr + size; ptr < e; ptr += 1){
        *ptr = val;
    }
}
internal void
block_fill_u16(void *a, u64 size, u16 val){
    Assert(size%sizeof(u16) == 0);
    u64 count = size/sizeof(u16);
    for (u16 *ptr = (u16*)a, *e = ptr + count; ptr < e; ptr += 1){
        *ptr = val;
    }
}
internal void
block_fill_u32(void *a, u64 size, u32 val){
    Assert(size%sizeof(u32) == 0);
    u64 count = size/sizeof(u32);
    for (u32 *ptr = (u32*)a, *e = ptr + count; ptr < e; ptr += 1){
        *ptr = val;
    }
}
internal void
block_fill_u64(void *a, u64 size, u64 val){
    Assert(size%sizeof(u64) == 0);
    u64 count = size/sizeof(u64);
    for (u64 *ptr = (u64*)a, *e = ptr + count; ptr < e; ptr += 1){
        *ptr = val;
    }
}

#define block_zero_struct(s) block_zero((s), sizeof(*(s)))
#endif

// BOTTOM



// end --- 4ed_mem.cpp --- 



// begin --- 4ed_dynamic_variables.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 22.06.2018
 *
 * Dynamic variable system
 *
 */

// TOP

internal void
managed_ids_init(Base_Allocator *allocator, Managed_ID_Set *set){
    set->arena = make_arena(allocator, KB(4), 8);
    set->name_to_group_table = make_table_Data_u64(allocator, 20);
}

internal Managed_ID
managed_ids_group_highest_id(Managed_ID_Set *set, String_Const_u8 group_name){
    Managed_ID result = 0;
    String_Const_u8 data = make_data(group_name.str, group_name.size);
    Table_Lookup lookup = table_lookup(&set->name_to_group_table, data);
    if (lookup.found_match){
        u64 val = 0;
        table_read(&set->name_to_group_table, lookup, &val);
        Managed_ID_Group *group = (Managed_ID_Group*)IntAsPtr(val);
        result = group->id_counter - 1;
    }
    return(result);
}

internal Managed_ID
managed_ids_declare(Managed_ID_Set *set, String_Const_u8 group_name, String_Const_u8 name){
    Managed_ID_Group *group = 0;
    {
        String_Const_u8 data = make_data(group_name.str, group_name.size);
        Table_Lookup lookup = table_lookup(&set->name_to_group_table, data);
        if (lookup.found_match){
            u64 val = 0;
            table_read(&set->name_to_group_table, lookup, &val);
            group = (Managed_ID_Group*)IntAsPtr(val);
        }
        else{
            group = push_array(&set->arena, Managed_ID_Group, 1);
            group->id_counter = 1;
            group->name_to_id_table = make_table_Data_u64(set->arena.base_allocator, 50);
            data = push_data_copy(&set->arena, data);
            table_insert(&set->name_to_group_table, data, PtrAsInt(group));
        }
    }
    Managed_ID result = 0;
    {
        String_Const_u8 data = make_data(name.str, name.size);
        Table_Lookup lookup = table_lookup(&group->name_to_id_table, data);
        if (lookup.found_match){
            table_read(&group->name_to_id_table, lookup, &result);
        }
        else{
            result = group->id_counter;
            group->id_counter += 1;
            data = push_data_copy(&set->arena, data);
            table_insert(&group->name_to_id_table, data, result);
        }
    }
    return(result);
}

function Managed_ID
managed_ids_get(Managed_ID_Set *set, String_Const_u8 group_name, String_Const_u8 name){
    Managed_ID_Group *group = 0;
    {
        String_Const_u8 data = make_data(group_name.str, group_name.size);
        Table_Lookup lookup = table_lookup(&set->name_to_group_table, data);
        if (lookup.found_match){
            u64 val = 0;
            table_read(&set->name_to_group_table, lookup, &val);
            group = (Managed_ID_Group*)IntAsPtr(val);
        }
    }
    Managed_ID result = 0;
    if (group != 0){
        String_Const_u8 data = make_data(name.str, name.size);
        Table_Lookup lookup = table_lookup(&group->name_to_id_table, data);
        if (lookup.found_match){
            table_read(&group->name_to_id_table, lookup, &result);
        }
    }
    return(result);
}

////////////////////////////////

internal void
dynamic_variable_block_init(Base_Allocator *allocator, Dynamic_Variable_Block *block){
    block->arena = make_arena(allocator, KB(4), 8);
    block->id_to_data_table = make_table_u64_Data(allocator, 20);
}

internal String_Const_u8
dynamic_variable_get(Dynamic_Variable_Block *block, Managed_ID id, u64 size){
    String_Const_u8 result = {};
    Table_Lookup lookup = table_lookup(&block->id_to_data_table, id);
    if (lookup.found_match){
        table_read(&block->id_to_data_table, lookup, &result);
    }
    else{
        result = push_data(&block->arena, size);
        block_zero(result);
        table_insert(&block->id_to_data_table, id, result);
    }
    return(result);
}

internal void
dynamic_variable_erase(Dynamic_Variable_Block *block, Managed_ID id){
    table_erase(&block->id_to_data_table, id);
}

////////////////////////////////

internal void
lifetime_allocator_init(Base_Allocator *base_allocator, Lifetime_Allocator *lifetime_allocator){
    block_zero_struct(lifetime_allocator);
    lifetime_allocator->allocator = base_allocator;
    lifetime_allocator->node_arena = make_arena(base_allocator, KB(4));
    lifetime_allocator->key_table = make_table_Data_u64(base_allocator, 100);
    lifetime_allocator->key_check_table = make_table_u64_u64(base_allocator, 100);
    lifetime_allocator->scope_id_to_scope_ptr_table = make_table_u64_u64(base_allocator, 100);
}

////////////////////////////////

internal void
dynamic_workspace_init(Lifetime_Allocator *lifetime_allocator, i32 user_type, void *user_back_ptr, Dynamic_Workspace *workspace){
    block_zero_struct(workspace);
    heap_init(&workspace->heap, lifetime_allocator->allocator);
    workspace->heap_wrapper = base_allocator_on_heap(&workspace->heap);
    workspace->object_id_to_object_ptr = make_table_u64_u64(&workspace->heap_wrapper, 10);
    dynamic_variable_block_init(&workspace->heap_wrapper, &workspace->var_block);
    if (lifetime_allocator->scope_id_counter == 0){
        lifetime_allocator->scope_id_counter = 1;
    }
    workspace->scope_id = lifetime_allocator->scope_id_counter++;
    table_insert(&lifetime_allocator->scope_id_to_scope_ptr_table,
                 workspace->scope_id, (u64)PtrAsInt(workspace));
    workspace->user_type = user_type;
    workspace->user_back_ptr = user_back_ptr;
}

internal void
dynamic_workspace_free(Lifetime_Allocator *lifetime_allocator, Dynamic_Workspace *workspace){
    table_erase(&lifetime_allocator->scope_id_to_scope_ptr_table, workspace->scope_id);
    heap_free_all(&workspace->heap);
}

internal void
dynamic_workspace_clear_contents(Dynamic_Workspace *workspace){
    Base_Allocator *base_allocator = heap_get_base_allocator(&workspace->heap);
    heap_free_all(&workspace->heap);
    heap_init(&workspace->heap, base_allocator);
    workspace->heap_wrapper = base_allocator_on_heap(&workspace->heap);
    workspace->object_id_to_object_ptr = make_table_u64_u64(&workspace->heap_wrapper, 10);
    dynamic_variable_block_init(&workspace->heap_wrapper, &workspace->var_block);
    block_zero_struct(&workspace->buffer_markers_list);
    workspace->total_marker_count = 0;
}

internal u32
dynamic_workspace_store_pointer(Dynamic_Workspace *workspace, void *ptr){
    if (workspace->object_id_counter == 0){
        workspace->object_id_counter = 1;
    }
    u32 id = workspace->object_id_counter++;
    table_insert(&workspace->object_id_to_object_ptr, id, (u64)PtrAsInt(ptr));
    return(id);
}

internal void
dynamic_workspace_erase_pointer(Dynamic_Workspace *workspace, u32 id){
    table_erase(&workspace->object_id_to_object_ptr, id);
}

internal void*
dynamic_workspace_get_pointer(Dynamic_Workspace *workspace, u32 id){
    void *result = 0;
    Table_Lookup lookup = table_lookup(&workspace->object_id_to_object_ptr, id);
    if (lookup.found_match){
        u64 val = 0;
        table_read(&workspace->object_id_to_object_ptr, lookup, &val);
        result = IntAsPtr(val);
    }
    return(result);
}

////////////////////////////////

internal String_Const_u8
lifetime__key_as_data(Lifetime_Object **members, i32 count){
    return(make_data(members, sizeof(*members)*count));
}

internal String_Const_u8
lifetime__key_as_data(Lifetime_Key *key){
    return(lifetime__key_as_data(key->members, key->count));
}

internal void
lifetime__free_key(Lifetime_Allocator *lifetime_allocator, Lifetime_Key *key, Lifetime_Object *skip_object){
    // Deinit
    dynamic_workspace_free(lifetime_allocator, &key->dynamic_workspace);
    
    // Remove From Objects
    i32 count = key->count;
    Lifetime_Object **object_ptr = key->members;
    for (i32 i = 0; i < count; i += 1, object_ptr += 1){
        if (*object_ptr == skip_object) continue;
        
        Lifetime_Key_Ref_Node *delete_point_node = 0;
        i32 delete_point_i = 0;
        
        i32 key_i = 0;
        Lifetime_Object *object = *object_ptr;
        for (Lifetime_Key_Ref_Node *node = object->key_node_first;
             node != 0;
             node = node->next){
            i32 one_past_last = clamp_top(ArrayCount(node->keys), object->key_count - key_i);
            for (i32 j = 0; j < one_past_last; j += 1){
                if (node->keys[j] == key){
                    delete_point_node = node;
                    delete_point_i = j;
                    goto double_break;
                }
            }
            key_i += one_past_last;
        }
        double_break:;
        
        Assert(delete_point_node != 0);
        Lifetime_Key_Ref_Node *last_node = object->key_node_last;
        Lifetime_Key *last_key = last_node->keys[(object->key_count - 1) % ArrayCount(last_node->keys)];
        Assert(last_key != 0);
        delete_point_node->keys[delete_point_i] = last_key;
        object->key_count -= 1;
        
        if ((object->key_count % lifetime_key_reference_per_node) == 0){
            zdll_remove(object->key_node_first, object->key_node_last, last_node);
            sll_stack_push(lifetime_allocator->free_key_references, last_node);
        }
    }
    
    // Free
    String_Const_u8 key_data = lifetime__key_as_data(key);
    table_erase(&lifetime_allocator->key_table, key_data);
    table_erase(&lifetime_allocator->key_check_table, (u64)PtrAsInt(key));
    base_free(lifetime_allocator->allocator, key->members);
    sll_stack_push(lifetime_allocator->free_keys, key);
}

internal Lifetime_Key_Ref_Node*
lifetime__alloc_key_reference_node(Lifetime_Allocator *lifetime_allocator){
    Assert(lifetime_allocator != 0);
    Lifetime_Key_Ref_Node *result = lifetime_allocator->free_key_references;
    if (result == 0){
        result = push_array(&lifetime_allocator->node_arena, Lifetime_Key_Ref_Node, 1);
    }
    else{
        sll_stack_pop(lifetime_allocator->free_key_references);
    }
    return(result);
}

internal void
lifetime__object_add_key(Lifetime_Allocator *lifetime_allocator, Lifetime_Object *object, Lifetime_Key *key){
    Lifetime_Key_Ref_Node *last_node = object->key_node_last;
    b32 insert_on_new_node = false;
    if (last_node == 0){
        insert_on_new_node = true;
    }
    else{
        i32 next_insert_slot = object->key_count%ArrayCount(last_node->keys);
        if (next_insert_slot != 0){
            last_node->keys[next_insert_slot] = key;
            object->key_count += 1;
        }
        else{
            insert_on_new_node = true;
        }
    }
    if (insert_on_new_node){
        Lifetime_Key_Ref_Node *new_node = lifetime__alloc_key_reference_node(lifetime_allocator);
        zdll_push_back(object->key_node_first, object->key_node_last, new_node);
        block_zero_struct(new_node->keys);
        new_node->keys[0] = key;
        object->key_count += 1;
    }
}

internal Lifetime_Object*
lifetime_alloc_object(Lifetime_Allocator *lifetime_allocator, i32 user_type, void *user_back_ptr){
    Lifetime_Object *object = lifetime_allocator->free_objects;
    if (object == 0){
        object = push_array(&lifetime_allocator->node_arena, Lifetime_Object, 1);
    }
    else{
        sll_stack_pop(lifetime_allocator->free_objects);
    }
    block_zero_struct(object);
    dynamic_workspace_init(lifetime_allocator, user_type, user_back_ptr, &object->workspace);
    return(object);
}

internal void
lifetime__object_free_all_keys(Lifetime_Allocator *lifetime_allocator, Lifetime_Object *lifetime_object){
    i32 key_i = 0;
    for (Lifetime_Key_Ref_Node *node = lifetime_object->key_node_first;
         node != 0;
         node = node->next){
        i32 one_past_last = clamp_top(ArrayCount(node->keys), lifetime_object->key_count - key_i);
        for (i32 i = 0; i < one_past_last; i += 1){
            lifetime__free_key(lifetime_allocator, node->keys[i], lifetime_object);
        }
        key_i += one_past_last;
    }
    
    if (lifetime_object->key_count > 0){
        lifetime_object->key_node_last->next = lifetime_allocator->free_key_references;
        lifetime_allocator->free_key_references = lifetime_object->key_node_first;
    }
}

internal void
lifetime__object_clear_all_keys(Lifetime_Allocator *lifetime_allocator, Lifetime_Object *lifetime_object){
    i32 key_i = 0;
    for (Lifetime_Key_Ref_Node *node = lifetime_object->key_node_first;
         node != 0;
         node = node->next){
        i32 one_past_last = clamp_top(ArrayCount(node->keys), lifetime_object->key_count - key_i);
        Lifetime_Key **key_ptr = node->keys;
        for (i32 i = 0; i < one_past_last; i += 1, key_ptr += 1){
            dynamic_workspace_clear_contents(&(*key_ptr)->dynamic_workspace);
        }
        key_i += one_past_last;
    }
}

internal void
lifetime_free_object(Lifetime_Allocator *lifetime_allocator, Lifetime_Object *lifetime_object){
    lifetime__object_free_all_keys(lifetime_allocator, lifetime_object);
    dynamic_workspace_free(lifetime_allocator, &lifetime_object->workspace);
    sll_stack_push(lifetime_allocator->free_objects, lifetime_object);
}

internal void
lifetime_object_reset(Lifetime_Allocator *lifetime_allocator, Lifetime_Object *lifetime_object){
    lifetime__object_clear_all_keys(lifetime_allocator, lifetime_object);
    dynamic_workspace_clear_contents(&lifetime_object->workspace);
}

internal i32
lifetime_sort_object_set__part(Lifetime_Object **ptr_array, i32 first, i32 one_past_last){
    i32 pivot_index = one_past_last - 1;
    Lifetime_Object *pivot = ptr_array[pivot_index];
    i32 j = first;
    for (i32 i = first; i < pivot_index; i += 1){
        Lifetime_Object *object = ptr_array[i];
        if (object < pivot){
            Swap(Lifetime_Object*, ptr_array[i], ptr_array[j]);
            j += 1;
        }
    }
    Swap(Lifetime_Object*, ptr_array[j], ptr_array[pivot_index]);
    return(j);
}

internal void
lifetime_sort_object_set__quick(Lifetime_Object **ptr_array, i32 first, i32 one_past_last){
    if (first + 1 < one_past_last){
        i32 pivot = lifetime_sort_object_set__part(ptr_array, first, one_past_last);
        lifetime_sort_object_set__quick(ptr_array, first, pivot);
        lifetime_sort_object_set__quick(ptr_array, pivot + 1, one_past_last);
    }
}

internal i32
lifetime_sort_and_dedup_object_set(Lifetime_Object **ptr_array, i32 count){
    lifetime_sort_object_set__quick(ptr_array, 0, count);
    Lifetime_Object **ptr_write = ptr_array + 1;
    Lifetime_Object **ptr_read  = ptr_array + 1;
    for (i32 i = 1; i < count; i += 1, ptr_read += 1){
        if (ptr_read[-1] < ptr_read[0]){
            *ptr_write = *ptr_read;
            ptr_write += 1;
        }
    }
    return((i32)(ptr_write - ptr_array));
}

internal Lifetime_Key*
lifetime_get_or_create_intersection_key(Lifetime_Allocator *lifetime_allocator, Lifetime_Object **object_ptr_array, i32 count){
    {
        String_Const_u8 key_data = lifetime__key_as_data(object_ptr_array, count);
        Table_Lookup lookup = table_lookup(&lifetime_allocator->key_table, key_data);
        if (lookup.found_match){
            u64 val = 0;
            table_read(&lifetime_allocator->key_table, lookup, &val);
            return((Lifetime_Key*)IntAsPtr(val));
        }
    }
    
    // Allocate
    Lifetime_Key *new_key = lifetime_allocator->free_keys;
    if (new_key == 0){
        new_key = push_array(&lifetime_allocator->node_arena, Lifetime_Key, 1);
    }
    else{
        sll_stack_pop(lifetime_allocator->free_keys);
    }
    block_zero_struct(new_key);
    
    // Add to Objects
    Lifetime_Object **object_ptr = object_ptr_array;
    for (i32 i = 0; i < count; i += 1, object_ptr += 1){
        Lifetime_Object *object = *object_ptr;
        lifetime__object_add_key(lifetime_allocator, object, new_key);
    }
    
    // Initialize
    u64 new_memory_size = sizeof(Lifetime_Object*)*count;
    String_Const_u8 new_memory = base_allocate(lifetime_allocator->allocator, new_memory_size);
    new_key->members = (Lifetime_Object**)new_memory.str;
    block_copy_dynamic_array(new_key->members, object_ptr_array, count);
    new_key->count = count;
    dynamic_workspace_init(lifetime_allocator,
                           DynamicWorkspace_Intersected, new_key,
                           &new_key->dynamic_workspace);
    
    {
        String_Const_u8 key_data = lifetime__key_as_data(new_key);
        u64 new_key_val = (u64)PtrAsInt(new_key);
        table_insert(&lifetime_allocator->key_table, key_data, new_key_val);
        table_insert(&lifetime_allocator->key_check_table, new_key_val, new_key_val);
    }
    
    return(new_key);
}

internal b32
lifetime_key_check(Lifetime_Allocator *lifetime_allocator, Lifetime_Key *key){
    Table_Lookup lookup = table_lookup(&lifetime_allocator->key_check_table, (u64)PtrAsInt(key));
    return(lookup.found_match);
}

////////////////////////////////

// TODO(allen): move this shit somewhere real, clean up all object creation functions to be more cleanly layered.
internal u8*
get_dynamic_object_memory_ptr(Managed_Object_Standard_Header *header){
    u8 *ptr = 0;
    if (header != 0){
        switch (header->type){
            case ManagedObjectType_Memory:
            case ManagedObjectType_Markers:
            {
                ptr = ((u8*)header) + managed_header_type_sizes[header->type];
            }break;
        }
    }
    return(ptr);
}

internal Managed_Object
managed_object_alloc_managed_memory(Dynamic_Workspace *workspace, i32 item_size, i32 count, void **ptr_out){
    i32 size = item_size*count;
    String_Const_u8 new_memory = base_allocate(&workspace->heap_wrapper, sizeof(Managed_Memory_Header) + size);
    void *ptr = new_memory.str;
    Managed_Memory_Header *header = (Managed_Memory_Header*)ptr;
    header->std_header.type = ManagedObjectType_Memory;
    header->std_header.item_size = item_size;
    header->std_header.count = count;
    if (ptr_out != 0){
        *ptr_out = get_dynamic_object_memory_ptr(&header->std_header);
    }
    u32 id = dynamic_workspace_store_pointer(workspace, ptr);
    return(((u64)workspace->scope_id << 32) | (u64)id);
}

internal Managed_Object
managed_object_alloc_buffer_markers(Dynamic_Workspace *workspace, Buffer_ID buffer_id, i32 count, Marker **markers_out){
    i32 size = count*sizeof(Marker);
    String_Const_u8 new_memory = base_allocate(&workspace->heap_wrapper, size + sizeof(Managed_Buffer_Markers_Header));
    void *ptr = new_memory.str;
    Managed_Buffer_Markers_Header *header = (Managed_Buffer_Markers_Header*)ptr;
    header->std_header.type = ManagedObjectType_Markers;
    header->std_header.item_size = sizeof(Marker);
    header->std_header.count = count;
    zdll_push_back(workspace->buffer_markers_list.first, workspace->buffer_markers_list.last, header);
    workspace->buffer_markers_list.count += 1;
    workspace->total_marker_count += count;
    header->buffer_id = buffer_id;
    if (markers_out != 0){
        *markers_out = (Marker*)get_dynamic_object_memory_ptr(&header->std_header);
    }
    u32 id = dynamic_workspace_store_pointer(workspace, ptr);
    return(((u64)workspace->scope_id << 32) | (u64)id);
}

internal b32
managed_object_free(Dynamic_Workspace *workspace, Managed_Object object){
    b32 result = false;
    u32 lo_id = object&max_u32;
    u8 *object_ptr = (u8*)dynamic_workspace_get_pointer(workspace, lo_id);
    if (object_ptr != 0){
        Managed_Object_Type *type = (Managed_Object_Type*)object_ptr;
        switch (*type){
            case ManagedObjectType_Markers:
            {
                Managed_Buffer_Markers_Header *header = (Managed_Buffer_Markers_Header*)object_ptr;
                workspace->total_marker_count -= header->std_header.count;
                zdll_remove(workspace->buffer_markers_list.first, workspace->buffer_markers_list.last, header);
                workspace->buffer_markers_list.count -= 1;
            }break;
        }
        dynamic_workspace_erase_pointer(workspace, lo_id);
        base_free(&workspace->heap_wrapper, object_ptr);
        result = true;
    }
    return(result);
}

// BOTTOM



// end --- 4ed_dynamic_variables.cpp --- 



// begin --- 4ed_font_set.cpp --- 

/*
* Mr. 4th Dimention - Allen Webster
*
* 23.07.2019
*
* Type for organizating the set of all loaded font faces.
*
*/

// TOP

internal Face_ID
font_set__alloc_face_id(Font_Set *set){
    Face_ID result = 0;
    if (set->free_ids != 0){
        Font_Face_ID_Node *node = set->free_ids;
        result = node->id;
        sll_stack_pop(set->free_ids);
        sll_stack_push(set->free_id_nodes, node);
    }
    else{
        result = set->next_id_counter;
        set->next_id_counter += 1;
    }
    return(result);
}

internal void
font_set__free_face_id(Font_Set *set, Face_ID id){
    if (id + 1 == set->next_id_counter){
        set->next_id_counter -= 1;
    }
    else{
        Font_Face_ID_Node *node = 0;
        if (set->free_id_nodes == 0){
            node = push_array(&set->arena, Font_Face_ID_Node, 1);
        }
        else{
            node = set->free_id_nodes;
            sll_stack_pop(set->free_id_nodes);
        }
        sll_stack_push(set->free_ids, node);
        node->id = id;
    }
}

internal Font_Face_Slot*
font_set__alloc_face_slot(Font_Set *set){
    Font_Face_Slot *result = 0;
    if (set->free_face_slots == 0){
        result = push_array(&set->arena, Font_Face_Slot, 1);
    }
    else{
        result = set->free_face_slots;
        sll_stack_pop(set->free_face_slots);
    }
    return(result);
}

internal void
font_set__free_face_slot(Font_Set *set, Font_Face_Slot *slot){
    if (slot->arena.base_allocator != 0){
        table_free(&slot->face->advance_map.codepoint_to_index.table);
        linalloc_clear(&slot->arena);
    }
    block_zero_struct(slot);
    sll_stack_push(set->free_face_slots, slot);
}

internal void
font_set_init(Font_Set *set){
    block_zero_struct(set);
    set->arena = make_arena_system();
    set->next_id_counter = 1;
    set->id_to_slot_table = make_table_u64_u64(set->arena.base_allocator, 40);
    set->scale_factor = system_get_screen_scale_factor();
}

internal Face*
font_set_new_face(Font_Set *set, Face_Description *description){
    Arena arena = make_arena_system();
    Face *face = font_make_face(&arena, description, set->scale_factor);
    if (face != 0){
        Font_Face_Slot *slot = font_set__alloc_face_slot(set);
        slot->arena = arena;
        slot->face = face;
        Face_ID new_id = font_set__alloc_face_id(set);
        face->id = new_id;
        table_insert(&set->id_to_slot_table, new_id, (u64)slot);
    }
    else{
        linalloc_clear(&arena);
    }
    return(face);
}

internal Font_Face_Slot*
font_set__get_face_slot(Font_Set *set, Face_ID id){
    Font_Face_Slot *result = 0;
    u64 slot_ptr_u64 = 0;
    if (table_read(&set->id_to_slot_table, id, &slot_ptr_u64)){
        result = (Font_Face_Slot*)slot_ptr_u64;
    }
    return(result);
}

internal b32
font_set_release_face(Font_Set *set, Face_ID id){
    b32 result = false;
    Font_Face_Slot *slot = font_set__get_face_slot(set, id);
    if (slot != 0){
        table_erase(&set->id_to_slot_table, id);
        font_set__free_face_slot(set, slot);
        font_set__free_face_id(set, id);
        result = true;
    }
    return(result);
}

internal Face*
font_set_face_from_id(Font_Set *set, Face_ID id){
    Face *result = 0;
    Font_Face_Slot *slot = font_set__get_face_slot(set, id);
    if (slot != 0){
        result = slot->face;
    }
    return(result);
}

internal Face_ID
font_set_get_fallback_face(Font_Set *set){
    Face_ID result = 0;
    for (Face_ID i = 1; i < set->next_id_counter; i += 1){
        if (font_set__get_face_slot(set, i) != 0){
            result = i;
            break;
        }
    }
    return(result);
}

internal Face_ID
font_set_get_largest_id(Font_Set *set){
    return(set->next_id_counter - 1);
}

internal b32
font_set_modify_face(Font_Set *set, Face_ID id, Face_Description *description){
    b32 result = false;
    Font_Face_Slot *slot = font_set__get_face_slot(set, id);
    if (slot != 0){
        i32 version_number = slot->face->version_number;
        Arena arena = make_arena_system();
        Face *face = font_make_face(&arena, description, set->scale_factor);
        if (face != 0){
            linalloc_clear(&slot->arena);
            slot->arena = arena;
            slot->face = face;
            face->version_number = version_number + 1;
            face->id = id;
            result = true;
        }
        else{
            linalloc_clear(&arena);
        }
    }
    return(result);
}

// BOTTOM



// end --- 4ed_font_set.cpp --- 



// begin --- 4ed_translation.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 11.03.2017
 *
 * Translation system for turning byte streams into a stream of buffer model steps.
 *
 */

// TOP

// TODO(allen): I don't like this code _AT ALL_
// unravel the mess!
//
//
// So what happened here was I thought, "Hey I have text in non-contiguous chunks and now I 
// need to translates it into unicode codepoints (interpreting it as utf8), so I should make
// a system that translates utf-8 by taking in one byte at a time then emitting one or more
// codepoints whenever there is enough information, all the while ensuring there is no backtracking"
//
// Even though this may make the iteration sound nice, it's a HUGE FREAKING PAIN IN THE ASS.
// You can't optimize it very well, the code is inscrutible both on the implementation side
// and the calling side.  Besides the fact that I "got it working" there isn't one good thing
// about this code.
//
// My next idea would be to try to make translation systems that take in the chunks themselves as
// a linked list, and then just does the WHOLE translation, MAYBE with optional "stop conditions".
// This way someone can actually optimize the translation loop by hand in _ONE SPOT_.  The downside
// is that the caller will have to put up with maybe more translation work than they needed, but that
// translation work will be so much cheaper, and easier to maintain, that the caller will be happier
// overall.
//
//
// If this comment is still here, then I haven't fixed any of this garbage yet, but it should really
// be fixed!

#define ERROR_BYTE (max_u8-1)
#define CONTINUATION_BYTE max_u8

internal void
translating_consume_byte(Translation_State *tran, u8 ch, u32 i, u32 size, Translation_Byte_Description *desc_out){
    desc_out->byte_class = 0;
    if (ch < 0x80){
        desc_out->byte_class = 1;
    }
    else if (ch < 0xC0){
        desc_out->byte_class = CONTINUATION_BYTE;
    }
    else if (ch < 0xE0){
        desc_out->byte_class = 2;
    }
    else if (ch < 0xF0){
        desc_out->byte_class = 3;
    }
    else if (ch < 0xF8){
        desc_out->byte_class = 4;
    }
    else{
        desc_out->byte_class = ERROR_BYTE;
    }
    
    desc_out->prelim_emit_type = BufferModelUnit_None;
    desc_out->last_byte_handler = TranLBH_None;
    if (tran->fill_expected == 0){
        tran->fill_buffer[0] = ch;
        tran->fill_start_i = i;
        tran->fill_i = 1;
        
        if (desc_out->byte_class == 1){
            desc_out->prelim_emit_type = BufferModelUnit_Codepoint;
        }
        else if (desc_out->byte_class == 0 || desc_out->byte_class == CONTINUATION_BYTE || desc_out->byte_class == ERROR_BYTE){
            desc_out->prelim_emit_type = BufferModelUnit_Numbers;
        }
        else{
            tran->fill_expected = desc_out->byte_class;
        }
    }
    else{
        if (desc_out->byte_class == CONTINUATION_BYTE){
            tran->fill_buffer[tran->fill_i] = ch;
            ++tran->fill_i;
            
            if (tran->fill_i == tran->fill_expected){
                desc_out->prelim_emit_type = BufferModelUnit_Codepoint;
            }
        }
        else{
            if (desc_out->byte_class >= 2 && desc_out->byte_class <= 4){
                desc_out->last_byte_handler = TranLBH_Rebuffer;
            }
            else if (desc_out->byte_class == 1){
                desc_out->last_byte_handler = TranLBH_EmitAsCP;
            }
            else{
                tran->fill_buffer[tran->fill_i] = ch;
                ++tran->fill_i;
            }
            desc_out->prelim_emit_type = BufferModelUnit_Numbers;
        }
    }
    
    if (desc_out->prelim_emit_type == BufferModelUnit_None && i+1 == size){
        desc_out->prelim_emit_type = BufferModelUnit_Numbers;
    }
}

internal void
translating_select_emit_rule_UTF8(Translation_State *tran, Translation_Byte_Description desc, Translation_Emit_Rule *type_out){
    type_out->byte_class = desc.byte_class;
    type_out->last_byte_handler = desc.last_byte_handler;
    type_out->emit_type = desc.prelim_emit_type;
    
    type_out->codepoint = 0;
    type_out->codepoint_length = 0;
    if (desc.prelim_emit_type == BufferModelUnit_Codepoint){
        Character_Consume_Result consume = utf8_consume(tran->fill_buffer, ArrayCount(tran->fill_buffer));
        u32 cp = consume.codepoint;
        type_out->codepoint_length = consume.inc;
        if (cp == max_u32){
            type_out->codepoint_length = 0;
        }
        if (type_out->codepoint_length != 0){
            if ((cp >= nonchar_min && cp <= nonchar_max) || ((cp & 0xFFFF) >= 0xFFFE)){
                type_out->emit_type = BufferModelUnit_Numbers;
            }
            else{
                type_out->codepoint = cp;
                if (cp > 0x10FFFF){
                    type_out->emit_type = BufferModelUnit_Numbers;
                }
            }
        }
        else{
            type_out->emit_type = BufferModelUnit_Numbers;
        }
    }
}

internal void
translating_generate_emits(Translation_State *tran, Translation_Emit_Rule emit_rule, u8 ch, u32 i, Translation_Emits *emits_out){
    emits_out->step_count = 0;
    switch (emit_rule.emit_type){
        default: goto skip_all;
        
        case BufferModelUnit_Codepoint:
        {
            emits_out->steps[0].type = 1;
            emits_out->steps[0].value = emit_rule.codepoint;
            emits_out->steps[0].i = tran->fill_start_i;
            emits_out->steps[0].byte_length = emit_rule.codepoint_length;
            emits_out->step_count = 1;
        }break;
        
        case BufferModelUnit_Numbers:
        {
            for (u32 j = 0; j < tran->fill_i; ++j){
                emits_out->steps[j].type = 0;
                emits_out->steps[j].value = tran->fill_buffer[j];
                emits_out->steps[j].i = tran->fill_start_i + j;
                emits_out->steps[j].byte_length = 1;
            }
            emits_out->step_count = tran->fill_i;
        }break;
    }
    
    tran->fill_start_i = 0;
    tran->fill_i = 0;
    tran->fill_expected = 0;
    
    switch (emit_rule.last_byte_handler){
        case TranLBH_Rebuffer:
        {
            tran->fill_buffer[0] = ch;
            tran->fill_start_i = i;
            tran->fill_i = 1;
            tran->fill_expected = emit_rule.byte_class;
        }break;
        
        case TranLBH_EmitAsCP:
        {
            emits_out->steps[emits_out->step_count].type = 1;
            emits_out->steps[emits_out->step_count].value = ch;
            emits_out->steps[emits_out->step_count].i = i;
            emits_out->steps[emits_out->step_count].byte_length = 1;
            ++emits_out->step_count;
        }break;
    }
    
    skip_all:;
}

internal void
translating_fully_process_byte(Translation_State *tran, u8 ch, u32 i, u32 size, Translation_Emits *emits_out){
    Translation_Byte_Description description = {};
    translating_consume_byte(tran, ch, i, size, &description);
    Translation_Emit_Rule emit_rule = {};
    translating_select_emit_rule_UTF8(tran, description, &emit_rule);
    translating_generate_emits(tran, emit_rule, ch, i, emits_out);
}

internal void
translation_step_read(Buffer_Model_Step step, Buffer_Model_Behavior *behavior_out){
    behavior_out->do_newline = false;
    behavior_out->do_codepoint_advance = false;
    behavior_out->do_number_advance = false;
    if (step.type == 1){
        switch (step.value){
            case '\n':
            {
                behavior_out->do_newline = true;
            }break;
            default:
            {
                behavior_out->do_codepoint_advance = true;
            }break;
        }
    }
    else{
        behavior_out->do_number_advance = true;
    }
}

#define TRANSLATION_DECL_EMIT_LOOP(_j,_emit) u32 _j = 0; _j < (_emit).step_count; ++_j
#define TRANSLATION_DECL_GET_STEP(_step,_behav,_j,_emit)                 \
Buffer_Model_Step _step = _emit.steps[_j]; Buffer_Model_Behavior _behav; \
translation_step_read(_step, &_behav)

#define TRANSLATION_EMIT_LOOP(_j,_emit) _j = 0; _j < (_emit).step_count; ++_j
#define TRANSLATION_GET_STEP(_step,_behav,_j,_emit)\
(_step) = _emit.steps[_j]; translation_step_read((_step), &(_behav))

// BOTTOM





// end --- 4ed_translation.cpp --- 



// begin --- 4ed_render_target.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 10.11.2017
 *
 * Render target function implementations.
 *
 */

// TOP

internal void
draw__begin_new_group(Render_Target *target){
    Render_Group *group = 0;
    if (target->group_last != 0){
        if (target->group_last->vertex_list.vertex_count == 0){
            group = target->group_last;
        }
    }
    if (group == 0){
        group = push_array_zero(&target->arena, Render_Group, 1);
        sll_queue_push(target->group_first, target->group_last, group);
    }
    group->face_id = target->current_face_id;
    group->clip_box = target->current_clip_box;
}

internal Render_Vertex_Array_Node*
draw__extend_group_vertex_memory(Arena *arena, Render_Vertex_List *list, i32 size){
    Render_Vertex_Array_Node *node = push_array_zero(arena, Render_Vertex_Array_Node, 1);
    sll_queue_push(list->first, list->last, node);
    node->vertices = push_array(arena, Render_Vertex, size);
    node->vertex_max = size;
    return(node);
}

internal void
draw__write_vertices_in_current_group(Render_Target *target, Render_Vertex *vertices, i32 count){
    if (count > 0){
        Render_Group *group = target->group_last;
        if (group == 0){
            draw__begin_new_group(target);
            group = target->group_last;
        }
        
        Render_Vertex_List *list = &group->vertex_list;
        
        Render_Vertex_Array_Node *last = list->last;
        
        Render_Vertex *tail_vertex = 0;
        i32 tail_count = 0;
        if (last != 0){
            tail_vertex = last->vertices + last->vertex_count;
            tail_count = last->vertex_max - last->vertex_count;
        }
        
        i32 base_vertex_max = 64;
        i32 transfer_count = clamp_top(count, tail_count);
        if (transfer_count > 0){
            block_copy_dynamic_array(tail_vertex, vertices, transfer_count);
            last->vertex_count += transfer_count;
            list->vertex_count += transfer_count;
            base_vertex_max = last->vertex_max;
        }
        
        i32 count_left_over = count - transfer_count;
        if (count_left_over > 0){
            Render_Vertex *vertices_left_over = vertices + transfer_count;
            
            i32 next_node_size = (base_vertex_max + count_left_over)*2;
            Render_Vertex_Array_Node *memory = draw__extend_group_vertex_memory(&target->arena, list, next_node_size);
            block_copy_dynamic_array(memory->vertices, vertices_left_over, count_left_over);
            memory->vertex_count += count_left_over;
            list->vertex_count += count_left_over;
        }
        
    }
}

internal void
draw__set_face_id(Render_Target *target, Face_ID face_id){
    if (target->current_face_id != face_id){
        if (target->current_face_id != 0){
            target->current_face_id = face_id;
            draw__begin_new_group(target);
        }
        else{
            target->current_face_id = face_id;
            for (Render_Group *group = target->group_first;
                 group != 0;
                 group = group->next){
                group->face_id = face_id;
            }
        }
    }
}

////////////////////////////////

internal Rect_f32
draw_set_clip(Render_Target *target, Rect_f32 clip_box){
    Rect_f32 result = target->current_clip_box;
    if (target->current_clip_box != clip_box){
        target->current_clip_box = clip_box;
        draw__begin_new_group(target);
    }
    return(result);
}

internal void
begin_frame(Render_Target *target, void *font_set){
    linalloc_clear(&target->arena);
    target->group_first = 0;
    target->group_last = 0;
    target->current_face_id = 0;
    target->current_clip_box = Rf32(0, 0, (f32)target->width, (f32)target->height);
    target->font_set = font_set;
}

internal void
begin_render_section(Render_Target *target, i32 frame_index, f32 literal_dt, f32 animation_dt){
    target->frame_index = frame_index;
    target->literal_dt = literal_dt;
    target->animation_dt = animation_dt;
}

internal void
end_render_section(Render_Target *target){
}

////////////////////////////////

internal void
draw_rectangle_outline(Render_Target *target, Rect_f32 rect, f32 roundness, f32 thickness, u32 color){
    
    if ( rect_overlap(rect, target->current_clip_box) ) {
            
        if (roundness < epsilon_f32){
            roundness = 0.f;
        }
        thickness = clamp_bot(1.f, thickness);
        f32 half_thickness = thickness*0.5f;
        
        Render_Vertex vertices[6] = {};
        vertices[0].xy = V2f32(rect.x0, rect.y0);
        vertices[1].xy = V2f32(rect.x1, rect.y0);
        vertices[2].xy = V2f32(rect.x0, rect.y1);
        vertices[3].xy = V2f32(rect.x1, rect.y0);
        vertices[4].xy = V2f32(rect.x0, rect.y1);
        vertices[5].xy = V2f32(rect.x1, rect.y1);
        
        Vec2_f32 center = rect_center(rect);
        for (i32 i = 0; i < ArrayCount(vertices); i += 1){
            vertices[i].uvw = V3f32(center.x, center.y, roundness);
            vertices[i].color = color;
            vertices[i].half_thickness = half_thickness;
        }
        
        draw__write_vertices_in_current_group(target, vertices, ArrayCount(vertices));
    }
}

internal void
draw_rectangle(Render_Target *target, Rect_f32 rect, f32 roundness, u32 color){
    Vec2_f32 dim = rect_dim(rect);
    draw_rectangle_outline(target, rect, roundness, Max(dim.x, dim.y), color);
}

internal void
draw_font_glyph(Render_Target *target, Face *face, u32 codepoint, Vec2_f32 p,
                ARGB_Color color, Glyph_Flag flags, Vec2_f32 x_axis){
    draw__set_face_id(target, face->id);
    
    u16 glyph_index = 0;
    if (!codepoint_index_map_read(&face->advance_map.codepoint_to_index,
                                  codepoint, &glyph_index)){
        glyph_index = 0;
    }
    Glyph_Bounds bounds = face->bounds[glyph_index];
    Vec3_f32 texture_dim = face->texture_dim;
    
    Render_Vertex vertices[6] = {};
    
    Rect_f32 uv = bounds.uv;
    vertices[0].uvw = V3f32(uv.x0, uv.y0, bounds.w);
    vertices[1].uvw = V3f32(uv.x1, uv.y0, bounds.w);
    vertices[2].uvw = V3f32(uv.x0, uv.y1, bounds.w);
    vertices[5].uvw = V3f32(uv.x1, uv.y1, bounds.w);
    
    Vec2_f32 y_axis = V2f32(-x_axis.y, x_axis.x);
    Vec2_f32 x_min = bounds.xy_off.x0*x_axis;
    Vec2_f32 x_max = bounds.xy_off.x1*x_axis;
    Vec2_f32 y_min = bounds.xy_off.y0*y_axis;
    Vec2_f32 y_max = bounds.xy_off.y1*y_axis;
    Vec2_f32 p_x_min = p + x_min;
    Vec2_f32 p_x_max = p + x_max;
    vertices[0].xy = p_x_min + y_min;
    vertices[1].xy = p_x_max + y_min;
    vertices[2].xy = p_x_min + y_max;
    vertices[5].xy = p_x_max + y_max;
    
    /* NOTE simon (26/09/24): We don't use rect_overlap here because the text rect is not guaranteed to be axis aligned. */
    b32 draw = rect_contains_point( target->current_clip_box, vertices[ 0 ].xy );
    draw  = draw || rect_contains_point( target->current_clip_box, vertices[ 1 ].xy );
    draw  = draw || rect_contains_point( target->current_clip_box, vertices[ 2 ].xy );
    draw  = draw || rect_contains_point( target->current_clip_box, vertices[ 5 ].xy );
    
    if ( draw ) {
    
#if 0    
        Vec2_f32 xy_min = p + bounds.xy_off.x0*x_axis + bounds.xy_off.y0*y_axis;
        Vec2_f32 xy_max = p + bounds.xy_off.x1*x_axis + bounds.xy_off.y1*y_axis;
        
        vertices[0].xy = V2f32(xy_min.x, xy_min.y);
        vertices[1].xy = V2f32(xy_max.x, xy_min.y);
        vertices[2].xy = V2f32(xy_min.x, xy_max.y);
        vertices[5].xy = V2f32(xy_max.x, xy_max.y);
#endif
        
#if 0    
        if (!HasFlag(flags, GlyphFlag_Rotate90)){
            Rect_f32 xy = Rf32(p + bounds.xy_off.p0, p + bounds.xy_off.p1);
            
            vertices[0].xy  = V2f32(xy.x0, xy.y1);
            vertices[0].uvw = V3f32(uv.x0, uv.y1, bounds.w);
            vertices[1].xy  = V2f32(xy.x1, xy.y1);
            vertices[1].uvw = V3f32(uv.x1, uv.y1, bounds.w);
            vertices[2].xy  = V2f32(xy.x0, xy.y0);
            vertices[2].uvw = V3f32(uv.x0, uv.y0, bounds.w);
            vertices[5].xy  = V2f32(xy.x1, xy.y0);
            vertices[5].uvw = V3f32(uv.x1, uv.y0, bounds.w);
        }
        else{
            Rect_f32 xy = Rf32(p.x - bounds.xy_off.y1, p.y + bounds.xy_off.x0,
                               p.x - bounds.xy_off.y0, p.y + bounds.xy_off.x1);
            
            vertices[0].xy  = V2f32(xy.x0, xy.y1);
            vertices[0].uvw = V3f32(uv.x1, uv.y1, bounds.w);
            vertices[1].xy  = V2f32(xy.x1, xy.y1);
            vertices[1].uvw = V3f32(uv.x1, uv.y0, bounds.w);
            vertices[2].xy  = V2f32(xy.x0, xy.y0);
            vertices[2].uvw = V3f32(uv.x0, uv.y1, bounds.w);
            vertices[5].xy  = V2f32(xy.x1, xy.y0);
            vertices[5].uvw = V3f32(uv.x0, uv.y0, bounds.w);
        }
#endif
        
        vertices[3] = vertices[1];
        vertices[4] = vertices[2];
        
        for (i32 i = 0; i < ArrayCount(vertices); i += 1){
            vertices[i].color = color;
            vertices[i].half_thickness = 0.f;
        }
        
        draw__write_vertices_in_current_group(target, vertices, ArrayCount(vertices));
    }
}

////////////////////////////////

internal Vec2_f32
floor32(Vec2_f32 point){
    point.x = f32_floor32(point.x);
    point.y = f32_floor32(point.y);
    return(point);
}

internal f32
draw_string(Render_Target *target, Face *face, String_Const_u8 string, Vec2_f32 point,
            ARGB_Color color, u32 flags, Vec2_f32 delta){
    f32 total_delta = 0.f;
    if (face != 0){
        point = floor32(point);
        
        f32 byte_advance = face->metrics.byte_advance;
        f32 *byte_sub_advances = face->metrics.byte_sub_advances;
        
        u8 *str = (u8*)string.str;
        u8 *str_end = str + string.size;
        
        Translation_State tran = {};
        Translation_Emits emits = {};
        
        for (u32 i = 0; str < str_end; ++str, ++i){
            translating_fully_process_byte(&tran, *str, i, (i32)string.size, &emits);
            
            for (TRANSLATION_DECL_EMIT_LOOP(J, emits)){
                TRANSLATION_DECL_GET_STEP(step, behavior, J, emits);
                
                if (behavior.do_codepoint_advance){
                    u32 codepoint = step.value;
                    if (color != 0){
                        u32 draw_codepoint = step.value;
                        if (draw_codepoint == '\t'){
                            draw_codepoint = ' ';
                        }
                        draw_font_glyph(target, face, draw_codepoint, point, color, flags, delta);
                    }
                    local_const f32 internal_tab_width = 4.f;
                    f32 d = font_get_glyph_advance(&face->advance_map, &face->metrics, codepoint, internal_tab_width);
                    point += d*delta;
                    total_delta += d;
                }
                else if (behavior.do_number_advance){
                    u8 n = (u8)(step.value);
                    if (color != 0){
                        u8 cs[3];
                        cs[0] = '\\';
                        u8 nh = (n >> 4);
                        u8 nl = (n & 0xF);
                        u8 ch = '0' + nh;
                        u8 cl = '0' + nl;
                        if (nh > 0x9){
                            ch = ('A' - 0xA) + nh;
                        }
                        if (nl > 0x9){
                            cl = ('A' - 0xA) + nl;
                        }
                        cs[1] = ch;
                        cs[2] = cl;
                        
                        Vec2_f32 pp = point;
                        for (u32 j = 0; j < 3; ++j){
                            draw_font_glyph(target, face, cs[j], pp, color, flags, delta);
                            pp += delta*byte_sub_advances[j];
                        }
                    }
                    point += byte_advance*delta;
                    total_delta += byte_advance;
                }
            }
        }
    }
    
    return(total_delta);
}

internal f32
draw_string(Render_Target *target, Face *face, String_Const_u8 string, Vec2_f32 point, u32 color){
    return(draw_string(target, face, string, point, color, 0, V2f32(1.f, 0.f)));
}

internal f32
draw_string(Render_Target *target, Face *face, u8 *str, Vec2_f32 point, u32 color, u32 flags, Vec2_f32 delta){
    return(draw_string(target, face, SCu8(str), point, color, flags, delta));
}

internal f32
draw_string(Render_Target *target, Face *face, u8 *str, Vec2_f32 point, u32 color){
    return(draw_string(target, face, SCu8(str), point, color, 0, V2f32(1.f, 0.f)));
}

internal f32
font_string_width(Render_Target *target, Face *face, String_Const_u8 str){
    return(draw_string(target, face, str, V2f32(0, 0), 0, 0, V2f32(0, 0)));
}

internal f32
font_string_width(Render_Target *target, Face *face, u8 *str){
    return(draw_string(target, face, SCu8(str), V2f32(0, 0), 0, 0, V2f32(0, 0)));
}

// BOTTOM



// end --- 4ed_render_target.cpp --- 



// begin --- 4ed_buffer.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 06.01.2017
 *
 * The 4coder base buffer data structure.
 *
 */

// TOP

//
// Buffer low level operations
//

internal void
write_cursor_with_index(Cursor_With_Index *positions, i32 *count, i64 pos){
    positions[*count].index = *count;
    positions[*count].pos = pos;
    ++(*count);
}

internal void
buffer_quick_sort_cursors(Cursor_With_Index *positions, i32 first, i32 one_past_last){
    if (first + 1 < one_past_last){
        i32 pivot = one_past_last - 1;
        i64 pivot_pos = positions[pivot].pos;
        i32 j = first;
        for (i32 i = first; i < pivot; i += 1){
            i64 pos = positions[i].pos;
            if (pos < pivot_pos){
                Swap(Cursor_With_Index, positions[j], positions[i]);
                j += 1;
            }
        }
        Swap(Cursor_With_Index, positions[j], positions[pivot]);
        buffer_quick_sort_cursors(positions, first, j);
        buffer_quick_sort_cursors(positions, j + 1, one_past_last);
    }
}

internal void
buffer_sort_cursors(Cursor_With_Index *positions, i32 count){
    if (count > 0){
        buffer_quick_sort_cursors(positions, 0, count);
    }
}

internal void
buffer_unsort_cursors(Cursor_With_Index *positions, i32 count){
    if (count > 0){
        i32 i = 0;
        for (;;){
            if (positions[i].index == i){
                i += 1;
                if (i >= count){
                    break;
                }
            }
            else{
                i32 j = positions[i].index;
                Swap(Cursor_With_Index, positions[i], positions[j]);
            }
        }
    }
}

#if 0
function void
buffer_sort_batch(Edit *batch, i32 first, i32 one_past_last){
    if (first + 1 < one_past_last){
        i32 pivot = one_past_last - 1;
        i64 pivot_pos = batch[pivot].range.first;
        i32 j = first;
        for (i32 i = first; i < pivot; i += 1){
            i64 pos = batch[i].range.first;
            if (pos < pivot_pos){
                Swap(Edit, batch[j], batch[i]);
                j += 1;
            }
        }
        Swap(Edit, batch[j], batch[pivot]);
        buffer_sort_batch(batch, first, j);
        buffer_sort_batch(batch, j + 1, one_past_last);
    }
}

function Edit_Array
buffer_batch_array_from_linked_list(Arena *arena, Batch_Edit *batch, i32 count){
    Edit_Array result = {};
    result.count = count;
    result.vals = push_array(arena, Edit, count);
    i32 counter = 0;
    for (Batch_Edit *node = batch;
         counter < count && node != 0;
         node = node->next){
        result.vals[counter] = node->edit;
        counter += 1;
    }
    return(result);
}

function Edit_Array
buffer_sort_batch(Arena *arena, Batch_Edit *batch, i32 count){
    Edit_Array result = buffer_batch_array_from_linked_list(arena, batch, count);
    buffer_sort_batch(result.vals, 0, result.count);
    return(result);
}
#endif

internal void
buffer_update_cursors_lean_l(Cursor_With_Index *sorted_positions, i32 count,
                             Batch_Edit *batch){
    Cursor_With_Index *pos = sorted_positions;
    Cursor_With_Index *end_pos = sorted_positions + count;
    i64 shift_amount = 0;
    for (; batch != 0 && pos < end_pos;
         batch = batch->next){
        Range_i64 range = batch->edit.range;
        i64 len = batch->edit.text.size;
        if (shift_amount != 0){
            for (;pos < end_pos && pos->pos < range.first; pos += 1){
                pos->pos += shift_amount;
            }
        }
        else{
            for (;pos < end_pos && pos->pos < range.first; pos += 1);
        }
        i64 new_pos = range.first + shift_amount;
        for (;pos < end_pos && pos->pos <= range.one_past_last; pos += 1){
            pos->pos = new_pos;
        }
        shift_amount += len - (range.one_past_last - range.first);
    }
    if (shift_amount != 0){
        for (;pos < end_pos; pos += 1){
            pos->pos += shift_amount;
        }
    }
}

internal void
buffer_update_cursors_lean_r(Cursor_With_Index *sorted_positions, i32 count,
                             Batch_Edit *batch){
    Cursor_With_Index *pos = sorted_positions;
    Cursor_With_Index *end_pos = sorted_positions + count;
    i64 shift_amount = 0;
    for (; batch != 0 && pos < end_pos;
         batch = batch->next){
        Range_i64 range = batch->edit.range;
        i64 len = batch->edit.text.size;
        if (shift_amount != 0){
            for (;pos < end_pos && pos->pos < range.first; pos += 1){
                pos->pos += shift_amount;
            }
        }
        else{
            for (;pos < end_pos && pos->pos < range.first; pos += 1);
        }
        i64 new_pos = range.first + len + shift_amount;
        for (;pos < end_pos && pos->pos < range.one_past_last; pos += 1){
            pos->pos = new_pos;
        }
        shift_amount += len - (range.one_past_last - range.first);
    }
    if (shift_amount != 0){
        for (;pos < end_pos; pos += 1){
            pos->pos += shift_amount;
        }
    }
}

//////////////////////////////////////

internal b32
buffer_good(Gap_Buffer *buffer){
    return(buffer->data != 0);
}

internal i64
buffer_size(Gap_Buffer *buffer){
    return(buffer->size1 + buffer->size2);
}

internal i64
buffer_line_count(Gap_Buffer *buffer){
    return(buffer->line_start_count - 1);
}

internal void
buffer_init(Gap_Buffer *buffer, u8 *data, u64 size, Base_Allocator *allocator){
    block_zero_struct(buffer);
    
    buffer->allocator = allocator;
    
    u64 capacity = round_up_u64(size*2, KB(4));
    String_Const_u8 memory = base_allocate(allocator, capacity);
    buffer->data = (u8*)memory.str;
    buffer->size1 = size/2;
    buffer->gap_size = capacity - size;
    buffer->size2 = size - buffer->size1;
    buffer->max = capacity;
    
    block_copy(buffer->data, data, buffer->size1);
    block_copy(buffer->data + buffer->size1 + buffer->gap_size, data + buffer->size1, buffer->size2);
}

internal b32
buffer_replace_range(Gap_Buffer *buffer, Range_i64 range, String_Const_u8 text, i64 shift_amount){
    i64 size = buffer_size(buffer);
    Assert(0 <= range.start);
    Assert(range.start <= range.end);
    Assert(range.end <= size);
    
    if (shift_amount + size > buffer->max){
        i64 new_max = round_up_i64(2*(shift_amount + size), KB(4));
        i64 new_gap_size = new_max - size;
        String_Const_u8 new_memory_data = base_allocate(buffer->allocator, new_max);
        u8 *new_memory = (u8*)new_memory_data.str;
        block_copy(new_memory, buffer->data, buffer->size1);
        block_copy(new_memory + buffer->size1 + new_gap_size, buffer->data + buffer->size1 + buffer->gap_size,
                   buffer->size2);
        base_free(buffer->allocator, buffer->data);
        buffer->data = new_memory;
        buffer->gap_size = new_gap_size;
        buffer->max = new_max;
    }
    
    Assert(shift_amount + size <= buffer->max);
    
    b32 result = false;
    
    if (range.end < buffer->size1){
        i64 move_size = buffer->size1 - range.end;
        block_copy(buffer->data + buffer->size1 + buffer->gap_size - move_size,
                   buffer->data + range.end,
                   move_size);
        buffer->size1 -= move_size;
        buffer->size2 += move_size;
    }
    if (range.start > buffer->size1){
        i64 move_size = range.start - buffer->size1;
        block_copy(buffer->data + buffer->size1,
                   buffer->data + buffer->size1 + buffer->gap_size,
                   move_size);
        buffer->size1 += move_size;
        buffer->size2 -= move_size;
    }
    
    block_copy(buffer->data + range.start, text.str, text.size);
    buffer->size2 = size - range.end;
    buffer->size1 = range.start + text.size;
    buffer->gap_size -= shift_amount;
    
    Assert(buffer->size1 + buffer->size2 == size + shift_amount);
    Assert(buffer->size1 + buffer->gap_size + buffer->size2 == buffer->max);
    
    return(result);
}

////////////////////////////////

internal List_String_Const_u8
buffer_get_chunks(Arena *arena, Gap_Buffer *buffer){
    List_String_Const_u8 list = {};
    if (buffer->size1 > 0){
        string_list_push(arena, &list, SCu8(buffer->data, buffer->size1));
    }
    if (buffer->size2 > 0){
        u64 gap_2_pos = buffer->size1 + buffer->gap_size;
        string_list_push(arena, &list, SCu8(buffer->data + gap_2_pos, buffer->size2));
    }
    return(list);
}

internal void
buffer_chunks_clamp(List_String_Const_u8 *chunks, Range_i64 range){
    i64 p = 0;
    List_String_Const_u8 list = {};
    for (Node_String_Const_u8 *node = chunks->first, *next = 0;
         node != 0;
         node = next){
        next = node->next;
        Range_i64 node_range = Ii64(p, p + node->string.size);
        if (range_overlap(range, node_range)){
            i64 first = Max(node_range.first, range.first) - node_range.first;
            i64 one_past_last = Min(node_range.one_past_last, range.one_past_last) - node_range.first;
            String_Const_u8 s = string_prefix(node->string, one_past_last);
            node->string = string_skip(s, first);
            sll_queue_push(list.first, list.last, node);
            list.total_size += node->string.size;
            list.node_count += 1;
        }
        p = node_range.one_past_last;
    }
    *chunks = list;
}

internal String_Const_u8
buffer_stringify(Arena *arena, Gap_Buffer *buffer, Range_i64 range){
    List_String_Const_u8 list = buffer_get_chunks(arena, buffer);
    buffer_chunks_clamp(&list, range);
    return(string_list_flatten(arena, list, StringFill_NullTerminate));
}

internal String_Const_u8
buffer_eol_convert_out(Arena *arena, Gap_Buffer *buffer, Range_i64 range){
    List_String_Const_u8 list = buffer_get_chunks(arena, buffer);
    buffer_chunks_clamp(&list, range);
    u64 cap = list.total_size*2;
    u8 *memory = push_array(arena, u8, cap);
    u8 *memory_opl = memory + cap;
    u8 *ptr = memory;
    for (Node_String_Const_u8 *node = list.first;
         node != 0;
         node = node->next){
        u8 *byte = node->string.str;
        u8 *byte_opl = byte + node->string.size;
        for (;byte < byte_opl; byte += 1){
            if (*byte == '\n'){
                *ptr = '\r';
                ptr += 1;
                *ptr = '\n';
                ptr += 1;
            }
            else{
                *ptr = *byte;
                ptr += 1;
            }
        }
    }
    linalloc_pop(arena, (memory_opl - ptr));
    push_align(arena, 8);
    return(SCu8(memory, ptr));
}

#if 0
internal i64
buffer_count_newlines(Arena *scratch, Gap_Buffer *buffer, i64 start, i64 end){
    Temp_Memory temp = begin_temp(scratch);
    List_String_Const_u8 list = buffer_get_chunks(scratch, buffer);
    buffer_chunks_clamp(&list, Ii64(start, end));
    
    i64 count = 0;
    for (Node_String_Const_u8 *node = list.first;
         node != 0;
         node = node->next){
        u8 *byte = node->string.str;
        u8 *byte_opl = byte + node->string.size;
        for (;byte < byte_opl; byte += 1){
            if (*byte == '\n'){
                count += 1;
            }
        }
    }
    
    end_temp(temp);
    
    return(count);
}
#endif

internal void
buffer_starts__ensure_max_size(Gap_Buffer *buffer, i64 max_size){
    if (max_size > buffer->line_start_max){
        i64 new_max = round_up_i64(max_size*2, KB(1));
        String_Const_u8 memory = base_allocate(buffer->allocator, sizeof(*buffer->line_starts)*new_max);
        i64 *new_line_starts = (i64*)memory.str;
        block_copy_dynamic_array(new_line_starts, buffer->line_starts, buffer->line_start_count);
        buffer->line_start_max = new_max;
        base_free(buffer->allocator, buffer->line_starts);
        buffer->line_starts = new_line_starts;
    }
}

internal void
buffer_measure_starts__write(Gap_Buffer *buffer, i64 pos){
    buffer_starts__ensure_max_size(buffer, buffer->line_start_count + 1);
    buffer->line_starts[buffer->line_start_count] = pos;
    buffer->line_start_count += 1;
}

internal void
buffer_measure_starts(Arena *scratch, Gap_Buffer *buffer){
    Temp_Memory temp = begin_temp(scratch);
    List_String_Const_u8 list = buffer_get_chunks(scratch, buffer);
    buffer->line_start_count = 0;
    buffer_measure_starts__write(buffer, 0);
    i64 index = 0;
    for (Node_String_Const_u8 *node = list.first;
         node != 0;
         node = node->next){
        u8 *byte = node->string.str;
        u8 *byte_opl = byte + node->string.size;
        for (;byte < byte_opl; byte += 1){
            index += 1;
            if (*byte == '\n'){
                buffer_measure_starts__write(buffer, index);
            }
        }
    }
    buffer_measure_starts__write(buffer, buffer_size(buffer));
    end_temp(temp);
}

internal i64
buffer_get_line_index(Gap_Buffer *buffer, i64 pos){
    i64 i = 0;
    if (buffer->line_start_count > 2){
        i64 start = 0;
        i64 one_past_last = buffer->line_start_count - 1;
        i64 *array = buffer->line_starts;
        pos = clamp_bot(0, pos);
        for (;;){
            i = (start + one_past_last) >> 1;
            if (array[i] < pos){
                start = i;
            }
            else if (array[i] > pos){
                one_past_last = i;
            }
            else{
                break;
            }
            if (start + 1 >= one_past_last){
                i = start;
                break;
            }
        }
    }
    return(i);
}

Line_Move*
push_line_move(Arena *arena, Line_Move *moves, i64 new_line_first,
               i64 old_line_first, i64 old_line_opl, i64 text_shift){
    Line_Move *move = push_array(arena, Line_Move, 1);
    move->next = moves;
    move->kind = LineMove_ShiftOldValues;
    move->new_line_first = new_line_first;
    move->old_line_first = old_line_first;
    move->old_line_opl = old_line_opl;
    move->text_shift = text_shift;
    return(move);
}

Line_Move*
push_line_move(Arena *arena, Line_Move *moves, i64 new_line_first,
               String_Const_u8 string, i64 text_base){
    Line_Move *move = push_array(arena, Line_Move, 1);
    move->next = moves;
    move->kind = LineMove_MeasureString;
    move->new_line_first = new_line_first;
    move->string = string;
    move->text_base = text_base;
    return(move);
}

function i64
count_lines(String_Const_u8 string){
    i64 result = 0;
    for (u64 i = 0; i < string.size; i += 1){
        if (string.str[i] == '\n'){
            result += 1;
        }
    }
    return(result);
}

function void
fill_line_starts(i64 *lines_starts, String_Const_u8 string, i64 text_base){
    i64 *ptr = lines_starts;
    for (u64 i = 0; i < string.size; i += 1){
        if (string.str[i] == '\n'){
            *ptr = text_base + i + 1;
            ptr += 1;
        }
    }
}

function void
buffer_remeasure_starts(Thread_Context *tctx, Gap_Buffer *buffer, Batch_Edit *batch){
    Scratch_Block scratch(tctx);
    
    i64 line_start_count = buffer_line_count(buffer) + 1;
    
    Line_Move *moves = 0;
    i64 current_line = 0;
    i64 text_shift = 0;
    i64 line_shift = 0;
    for (Batch_Edit *node = batch;
         node != 0;
         node = node->next){
        i64 first_line = buffer_get_line_index(buffer, node->edit.range.first);
        i64 opl_line = buffer_get_line_index(buffer, node->edit.range.one_past_last);
        i64 new_line_count = count_lines(node->edit.text);
        i64 deleted_line_count = opl_line - first_line;
        
        Assert(first_line <= opl_line);
        Assert(opl_line <= line_start_count);
        
        if (current_line <= first_line &&
            (text_shift != 0 || line_shift != 0)){
            moves = push_line_move(scratch, moves, current_line + line_shift,
                                   current_line, first_line + 1, text_shift);
        }
        
        if (new_line_count != 0){
            moves = push_line_move(scratch, moves, first_line + 1 + line_shift,
                                   node->edit.text, node->edit.range.first + text_shift);
        }
        
        text_shift += node->edit.text.size - range_size(node->edit.range);
        line_shift += new_line_count - deleted_line_count;
        current_line = opl_line + 1;
    }
    
    moves = push_line_move(scratch, moves, current_line + line_shift,
                           current_line, line_start_count, text_shift);
    line_start_count = line_start_count + line_shift;
    
    buffer_starts__ensure_max_size(buffer, line_start_count + 1);
    buffer->line_start_count = line_start_count;
    
    i64 *array = buffer->line_starts;
    
    for (Line_Move *node = moves;
         node != 0;
         node = node->next){
        if (node->kind == LineMove_ShiftOldValues){
            i64 line_index_shift = node->new_line_first - node->old_line_first;
            i64 move_text_shift = node->text_shift;
            if (line_index_shift > 0){
                for (i64 i = node->old_line_opl - 1;
                     i >= node->old_line_first;
                     i -= 1){
                    array[i + line_index_shift] = array[i] + move_text_shift;
                }
            }
            else{
                for (i64 i = node->old_line_first;
                     i < node->old_line_opl;
                     i += 1){
                    array[i + line_index_shift] = array[i] + move_text_shift;
                }
            }
        }
    }
    
    for (Line_Move *node = moves;
         node != 0;
         node = node->next){
        if (node->kind == LineMove_MeasureString){
            fill_line_starts(array + node->new_line_first, node->string, node->text_base);
        }
    }
}

internal Range_i64
buffer_get_pos_range_from_line_number(Gap_Buffer *buffer, i64 line_number){
    Range_i64 result = {};
    if (1 <= line_number && line_number < buffer->line_start_count){
        result.first = buffer->line_starts[line_number - 1];
        result.one_past_last = buffer->line_starts[line_number];
    }
    return(result);
}

internal i64
buffer_get_first_pos_from_line_number(Gap_Buffer *buffer, i64 line_number){
    i64 result = 0;
    if (line_number < 1){
        result = 0;
    }
    else if (line_number >= buffer->line_start_count){
        result = buffer_size(buffer);
    }
    else{
        result = buffer->line_starts[line_number - 1];
    }
    return(result);
}

internal i64
buffer_get_last_pos_from_line_number(Gap_Buffer *buffer, i64 line_number){
    i64 result = 0;
    if (line_number < 1){
        result = 0;
    }
    else if (line_number >= buffer->line_start_count - 1){
        result = buffer_size(buffer);
    }
    else{
        result = buffer->line_starts[line_number] - 1;
    }
    return(result);
}

internal Buffer_Cursor
buffer_cursor_from_pos(Gap_Buffer *buffer, i64 pos){
    i64 size = buffer_size(buffer);
    pos = clamp(0, pos, size);
    i64 line_index = buffer_get_line_index(buffer, pos);
    
    Buffer_Cursor result = {};
    result.pos = pos;
    result.line = line_index + 1;
    result.col = pos - buffer->line_starts[line_index] + 1;
    return(result);
}

internal Buffer_Cursor
buffer_cursor_from_line_col(Gap_Buffer *buffer, i64 line, i64 col){
    i64 size = buffer_size(buffer);
    i64 line_index = line - 1;
    i64 line_count = buffer_line_count(buffer);
    line_index = clamp(0, line_index, line_count - 1);
    
    i64 this_start = buffer->line_starts[line_index];
    i64 max_col = (buffer->line_starts[line_index + 1] - this_start);
    if (line_index + 1 == line_count){
        max_col += 1;
    }
    max_col = clamp_bot(1, max_col);
    
    if (col < 0){
        if (-col > max_col){
            col = 1;
        }
        else{
            col = max_col + col + 1;
        }
    }
    else if (col == 0){
        col = 1;
    }
    else{
        col = clamp_top(col, max_col);
    }
    Assert(col > 0);
    i64 adjusted_pos = col - 1;
    
    i64 pos = this_start + adjusted_pos;
    
    Buffer_Cursor result = {};
    result.pos = pos;
    result.line = line_index + 1;
    result.col = col;
    return(result);
}

internal String_Const_u8
buffer_invert_edit_shift(Arena *arena, Gap_Buffer *buffer, Edit edit, Edit *inv, i64 shift_amount){
    String_Const_u8 string = buffer_stringify(arena, buffer, edit.range);
    inv->text = string;
    inv->range = Ii64(edit.range.start + shift_amount, edit.range.start + edit.text.size + shift_amount);
    return(string);
}

internal b32
buffer_invert_batch(Arena *arena, Gap_Buffer *buffer, Edit *edits, Edit *inverse, i64 count){
    b32 result = false;
    i64 pos = 0;
    i64 shift_amount = 0;
    Edit *edit = edits;
    Edit *inv_edit = inverse;
    for (i64 i = 0; i < count; i += 1, edit += 1, inv_edit += 1){
        String_Const_u8 inv_str = buffer_invert_edit_shift(arena, buffer, *edit, inv_edit, shift_amount);
        shift_amount += replace_range_shift(edit->range, edit->text.size);
        pos += inv_str.size;
    }
    return(result);
}

internal Buffer_Chunk_Position
buffer_get_chunk_position(String_Const_u8_Array chunks, i64 buffer_size, i64 real_pos){
    Buffer_Chunk_Position pos = {};
    pos.real_pos = real_pos;
    pos.chunk_pos = real_pos;
    if (pos.real_pos != buffer_size){
        for (;(i64)(chunks.vals[pos.chunk_index].size) <= pos.chunk_pos;){
            Assert(pos.chunk_index < chunks.count);
            pos.chunk_pos -= (i32)chunks.vals[pos.chunk_index].size;
            pos.chunk_index += 1;
        }
    }
    else{
        pos.chunk_index = chunks.count - 1;
        pos.chunk_pos = (i32)chunks.vals[pos.chunk_index].size;
    }
    return(pos);
}

internal i32
buffer_chunk_position_iterate(String_Const_u8_Array chunks, Buffer_Chunk_Position *pos, Scan_Direction direction){
    i32 past_end = 0;
    pos->real_pos += direction;
    pos->chunk_pos += direction;
    if (pos->chunk_pos < 0){
        if (pos->chunk_index == 0){
            past_end = -1;
        }
        else{
            pos->chunk_index -= 1;
            pos->chunk_pos = (i32)chunks.vals[pos->chunk_index].size - 1;
        }
    }
    else if (pos->chunk_pos >= (i64)(chunks.vals[pos->chunk_index].size)){
        pos->chunk_index += 1;
        if (pos->chunk_index == chunks.count){
            past_end = 1;
        }
        else{
            pos->chunk_pos = 0;
        }
    }
    return(past_end);
}

// BOTTOM



// end --- 4ed_buffer.cpp --- 



// begin --- 4ed_string_matching.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 16.06.2019
 *
 * Routines for string matching within chunked streams.
 *
 */

// TOP

internal u64_Array
string_compute_prefix_table(Arena *arena, String_Const_u8 string, Scan_Direction direction){
    u64_Array array = {};
    array.count = (i32)(string.size);
    array.vals = push_array(arena, u64, array.count);
    
    u8 *str = string.str;
    if (direction == Scan_Backward){
        str = string.str + string.size - 1;
    }
    
    array.vals[0] = 0;
    for (u64 i = 1; i < string.size; i += 1){
        u64 previous_longest_prefix = array.vals[i - 1];
        for (;;){
            u8 *a = str + previous_longest_prefix;
            u8 *b = str + i;
            if (direction == Scan_Backward){
                a = str - previous_longest_prefix;
                b = str - i;
            }
            if (character_to_upper(*a) == character_to_upper(*b)){
                array.vals[i] = previous_longest_prefix + 1;
                break;
            }
            if (previous_longest_prefix == 0){
                array.vals[i] = 0;
                break;
            }
            previous_longest_prefix = array.vals[previous_longest_prefix - 1];
        }
    }
    
    return(array);
}

internal u64_Array
string_compute_needle_jump_table(Arena *arena, u64_Array longest_prefixes){
    u64_Array array = {};
    array.count = longest_prefixes.count + 1;
    array.vals = push_array(arena, u64, array.count);
    array.vals[0] = 0;
    for (u64 i = 1; i < array.count; i += 1){
        array.vals[i] = i - longest_prefixes.vals[i - 1];
    }
    return(array);
}

internal u64_Array
string_compute_needle_jump_table(Arena *arena, String_Const_u8 needle, Scan_Direction direction){
    u64_Array prefix_table = string_compute_prefix_table(arena, needle, direction);
    return(string_compute_needle_jump_table(arena, prefix_table));
}

#define character_predicate_check_character(p, c) (((p).b[(c)/8] & (1 << ((c)%8))) != 0)

internal String_Match_List
find_all_matches_forward(Arena *arena, i32 maximum_output_count,
                         List_String_Const_u8 chunks, String_Const_u8 needle,
                         u64_Array jump_table, Character_Predicate *predicate,
                         u64 base_index, Buffer_ID buffer, i32 string_id){
    String_Match_List list = {};
    
    if (chunks.node_count > 0){
        u64 i = 0;
        u64 j = 0;
        b8 current_l = false;
        i64 last_insensitive = -1;
        i64 last_boundary = -1;
        
        Node_String_Const_u8 *node = chunks.first;
        i64 chunk_pos = 0;
        
        i32 jump_back_code = 0;
        
        u8 c = 0;
        u64 n = 0;
        u8 needle_c = 0;
        u64 jump = 0;
        
        if (false){
            iterate_forward:
            i += 1;
            chunk_pos += 1;
            if (chunk_pos >= (i64)node->string.size){
                last_boundary = i;
                chunk_pos = 0;
                node = node->next;
            }
            
            switch (jump_back_code){
                case 0:
                {
                    goto jump_back_0;
                }break;
                case 1:
                {
                    goto jump_back_1;
                }break;
            }
        }
        
        for (;node != 0;){
            c = node->string.str[chunk_pos];
            n = i - j;
            needle_c = needle.str[n];
            if (character_to_upper(c) == character_to_upper(needle_c)){
                if (c != needle_c){
                    last_insensitive = i;
                }
                
                jump_back_code = 0;
                goto iterate_forward;
                jump_back_0:
                
                if (n + 1 == needle.size){
                    String_Match_Flag flags = 0;
                    if (!(last_insensitive >= 0 &&
                          j <= (u64)last_insensitive &&
                          (u64)last_insensitive < j + needle.size)){
                        AddFlag(flags, StringMatch_CaseSensitive);
                    }
                    if (!(last_boundary >= 0 &&
                          j <= (u64)last_boundary &&
                          (u64)last_boundary < j + needle.size)){
                        AddFlag(flags, StringMatch_Straddled);
                    }
                    if (node != 0){
                        u8 next_c = node->string.str[chunk_pos];
                        if (character_predicate_check_character(*predicate, next_c)){
                            AddFlag(flags, StringMatch_RightSideSloppy);
                        }
                    }
                    if (current_l){
                        AddFlag(flags, StringMatch_LeftSideSloppy);
                    }
                    string_match_list_push(arena, &list, buffer, string_id, flags,
                                           base_index + j, needle.size);
                    if (list.count >= maximum_output_count){
                        break;
                    }
                    jump = jump_table.vals[n + 1];
                    current_l = character_predicate_check_character(*predicate, needle.str[jump - 1]);
                    j += jump;
                }
                
            }
            else{
                jump = jump_table.vals[n];
                if (jump == 0){
                    current_l = character_predicate_check_character(*predicate, c);
                    
                    jump_back_code = 1;
                    goto iterate_forward;
                    jump_back_1:
                    
                    j += 1;
                }
                else{
                    u8 prev_c = needle.str[jump - 1];
                    current_l = character_predicate_check_character(*predicate, prev_c);
                    j += jump;
                }
            }
        }
    }
    
    return(list);
}

internal String_Match_List
find_all_matches_backward(Arena *arena, i32 maximum_output_count,
                          List_String_Const_u8 chunks, String_Const_u8 needle,
                          u64_Array jump_table, Character_Predicate *predicate,
                          u64 base_index, Buffer_ID buffer, i32 string_id){
    String_Match_List list = {};
    
    string_list_reverse(&chunks);
    
    if (chunks.node_count > 0){
        i64 size = (i64)chunks.total_size;
        
        i64 i = size - 1;
        i64 j = size - 1;
        b8 current_r = false;
        i64 last_insensitive = size;
        i64 last_boundary = size;
        
        Node_String_Const_u8 *node = chunks.first;
        i64 chunk_pos = node->string.size - 1;
        
        i32 jump_back_code = 0;
        
        u8 c = 0;
        u64 n = 0;
        u8 needle_c = 0;
        u64 jump = 0;
        
        if (false){
            iterate_backward:
            i -= 1;
            chunk_pos -= 1;
            if (chunk_pos < 0){
                last_boundary = i;
                node = node->next;
                if (node != 0){
                    chunk_pos = node->string.size - 1;
                }
            }
            
            switch (jump_back_code){
                case 0:
                {
                    goto jump_back_0;
                }break;
                case 1:
                {
                    goto jump_back_1;
                }break;
            }
        }
        
        for (;node != 0;){
            c = node->string.str[chunk_pos];
            n = j - i;
            needle_c = needle.str[needle.size - 1 - n];
            if (character_to_upper(c) == character_to_upper(needle_c)){
                if (c != needle_c){
                    last_insensitive = i;
                }
                
                jump_back_code = 0;
                goto iterate_backward;
                jump_back_0:
                
                if (n + 1 == needle.size){
                    String_Match_Flag flags = 0;
                    if (!(last_insensitive < size &&
                          j >= last_insensitive &&
                          last_insensitive > j - (i64)needle.size)){
                        AddFlag(flags, StringMatch_CaseSensitive);
                    }
                    if (!(last_boundary < size &&
                          j >= last_boundary &&
                          last_boundary > j - (i64)needle.size)){
                        AddFlag(flags, StringMatch_Straddled);
                    }
                    if (node != 0){
                        u8 next_c = node->string.str[chunk_pos];
                        if (character_predicate_check_character(*predicate, next_c)){
                            AddFlag(flags, StringMatch_LeftSideSloppy);
                        }
                    }
                    if (current_r){
                        AddFlag(flags, StringMatch_RightSideSloppy);
                    }
                    string_match_list_push(arena, &list, buffer, string_id, flags,
                                           base_index + (j - (needle.size - 1)), needle.size);
                    if (list.count >= maximum_output_count){
                        break;
                    }
                    jump = jump_table.vals[n + 1];
                    u64 m = needle.size - jump;
                    u8 needle_m = needle.str[m];
                    current_r = character_predicate_check_character(*predicate, needle_m);
                    j -= jump;
                }
                
            }
            else{
                jump = jump_table.vals[n];
                if (jump == 0){
                    current_r = character_predicate_check_character(*predicate, c);
                    
                    jump_back_code = 1;
                    goto iterate_backward;
                    jump_back_1:
                    
                    j -= 1;
                }
                else{
                    u64 m = needle.size - jump;
                    u8 needle_m = needle.str[m];
                    current_r = character_predicate_check_character(*predicate, needle_m);
                    j -= jump;
                }
            }
        }
    }
    
    string_list_reverse(&chunks);
    
    return(list);
}

internal String_Match_List
find_all_matches(Arena *arena, i32 maximum_output_count,
                 List_String_Const_u8 chunks, String_Const_u8 needle,
                 u64_Array jump_table, Character_Predicate *predicate,
                 Scan_Direction direction,
                 u64 base_index, Buffer_ID buffer, i32 string_id){
    String_Match_List list = {};
    switch (direction){
        case Scan_Forward:
        {
            list = find_all_matches_forward(arena, maximum_output_count,
                                            chunks, needle, jump_table, predicate,
                                            base_index, buffer, string_id);
        }break;
        
        case Scan_Backward:
        {
            list = find_all_matches_backward(arena, maximum_output_count,
                                             chunks, needle, jump_table, predicate,
                                             base_index, buffer, string_id);
        }break;
    }
    return(list);
}

// BOTTOM



// end --- 4ed_string_matching.cpp --- 



// begin --- 4ed_history.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 24.03.2018
 *
 * History
 */

// TOP

internal Node*
history__to_node(Node *sentinel, i32 index){
    Node *result = 0;
    i32 counter = 0;
    Node *it = sentinel;
    do{
        if (counter == index){
            result = it;
            break;
        }
        counter += 1;
        it = it->next;
    } while (it != sentinel);
    return(result);
}

internal void
history__push_back_record_ptr(Base_Allocator *allocator, Record_Ptr_Lookup_Table *lookup, Record *record){
    if (lookup->records == 0 || lookup->count == lookup->max){
        i32 new_max = clamp_bot(1024, lookup->max*2);
        String_Const_u8 new_memory = base_allocate(allocator, sizeof(Record*)*new_max);
        Record **new_records = (Record**)new_memory.str;
        block_copy(new_records, lookup->records, sizeof(*new_records)*lookup->count);
        if (lookup->records != 0){
            base_free(allocator, lookup->records);
        }
        lookup->records = new_records;
        lookup->max = new_max;
    }
    Assert(lookup->count < lookup->max);
    lookup->records[lookup->count] = record;
    lookup->count += 1;
}

internal void
history__shrink_array(Record_Ptr_Lookup_Table *lookup, i32 new_count){
    Assert(0 <= new_count && new_count <= lookup->count);
    lookup->count = new_count;
}

internal void
history__merge_record_ptr_range_to_one_ptr(Record_Ptr_Lookup_Table *lookup, i32 first_one_based, i32 last_one_based, Record *record){
    i32 first = first_one_based - 1;
    i32 one_past_last = last_one_based;
    Assert(0 <= first && first <= one_past_last && one_past_last <= lookup->count);
    if (first < one_past_last){
        i32 shift = 1 + first - one_past_last;
        block_copy(lookup->records + one_past_last + shift, lookup->records + one_past_last, lookup->count - one_past_last);
        lookup->count += shift;
    }
    lookup->records[first] = record;
}

internal Node*
history__to_node(History *history, i32 index){
    Node *result = 0;
    if (index == 0){
        result = &history->records;
    }
    else if (0 < index && index <= history->record_count){
        Record_Ptr_Lookup_Table *lookup = &history->record_lookup;
        Assert(lookup->count == history->record_count);
        result = &lookup->records[index - 1]->node;
    }
    return(result);
}

////////////////////////////////

internal Record*
history__allocate_record(History *history){
    Node *sentinel = &history->free_records;
    Node *new_node = sentinel->next;
    if (new_node == sentinel){
        i32 new_record_count = 1024;
        String_Const_u8 new_memory = base_allocate(&history->heap_wrapper, sizeof(Record)*new_record_count);
        void *memory = new_memory.str;
        
        Record *new_record = (Record*)memory;
        sentinel->next = &new_record->node;
        new_record->node.prev = sentinel;
        for (i32 i = 1; i < new_record_count; i += 1, new_record += 1){
            new_record[0].node.next = &new_record[1].node;
            new_record[1].node.prev = &new_record[0].node;
        }
        new_record[0].node.next = sentinel;
        sentinel->prev = &new_record[0].node;
        
        new_node = &((Record*)memory)->node;
    }
    dll_remove(new_node);
    Record *record = CastFromMember(Record, node, new_node);
    block_zero_struct(record);
    return(record);
}

internal void
global_history_init(Global_History *global_history){
    global_history->edit_number_counter = 0;
    global_history->edit_grouping_counter = 0;
}

internal i32
global_history_get_edit_number(Global_History *global_history){
    i32 result = global_history->edit_number_counter;
    if (global_history->edit_grouping_counter == 0){
        global_history->edit_number_counter += 1;
    }
    return(result);
}

internal void
global_history_adjust_edit_grouping_counter(Global_History *global_history, i32 adjustment){
    i32 original = global_history->edit_grouping_counter;
    global_history->edit_grouping_counter = clamp_bot(0, global_history->edit_grouping_counter + adjustment);
    if (global_history->edit_grouping_counter == 0 && original > 0){
        global_history->edit_number_counter += 1;
    }
}

internal void
history_init(Thread_Context *tctx, Models *models, History *history){
    history->activated = true;
    history->arena = make_arena_system();
    heap_init(&history->heap, tctx->allocator);
    history->heap_wrapper = base_allocator_on_heap(&history->heap);
    dll_init_sentinel(&history->free_records);
    dll_init_sentinel(&history->records);
    history->record_count = 0;
    block_zero_struct(&history->record_lookup);
}

internal b32
history_is_activated(History *history){
    return(history->activated);
}

internal void
history_free(Thread_Context *tctx, History *history){
    if (history->activated){
        linalloc_clear(&history->arena);
        heap_free_all(&history->heap);
        block_zero_struct(history);
    }
}

internal i32
history_get_record_count(History *history){
    i32 result = 0;
    if (history->activated){
        result = history->record_count;
    }
    return(result);
}

internal Record*
history_get_record(History *history, i32 index){
    Record *result = 0;
    if (history->activated){
        Node *node = history__to_node(history, index);
        if (node != 0){
            result = CastFromMember(Record, node, node);
        }
    }
    return(result);
}

internal Record*
history_get_sub_record(Record *record, i32 sub_index_one_based){
    Record *result = 0;
    if (record->kind == RecordKind_Group){
        if (0 < sub_index_one_based && sub_index_one_based <= record->group.count){
            Node *node = history__to_node(&record->group.children, sub_index_one_based);
            if (node != 0){
                result = CastFromMember(Record, node, node);
            }
        }
    }
    return(result);
}

internal Record*
history_get_dummy_record(History *history){
    Record *result = 0;
    if (history->activated){
        result = CastFromMember(Record, node, &history->records);
    }
    return(result);
}

internal void
history__stash_record(History *history, Record *new_record){
    Assert(history->record_lookup.count == history->record_count);
    dll_insert_back(&history->records, &new_record->node);
    history->record_count += 1;
    history__push_back_record_ptr(&history->heap_wrapper, &history->record_lookup, new_record);
    Assert(history->record_lookup.count == history->record_count);
}

internal void
history__free_single_node(History *history, Node *node){
    dll_remove(node);
    dll_insert(&history->free_records, node);
}

internal void
history__free_nodes(History *history, i32 first_index, Node *first_node, Node *last_node){
    if (first_node == last_node){
        history__free_single_node(history, first_node);
    }
    else{
        {
            Node *left = first_node->prev;
            Node *right = last_node->next;
            left->next = right;
            right->prev = left;
        }
        
        {
            Node *left = &history->free_records;
            Node *right = left->next;
            left->next = first_node;
            first_node->prev = left;
            right->prev = last_node;
            last_node->next = right;
        }
    }
    Assert(first_index != 0);
    history->record_count = first_index - 1;
    history__shrink_array(&history->record_lookup, history->record_count);
}

internal void
history_record_edit(Global_History *global_history, History *history, Gap_Buffer *buffer,
                    i64 pos_before_edit, Edit edit){
    if (history->activated){
        Assert(history->record_lookup.count == history->record_count);
        
        Record *new_record = history__allocate_record(history);
        history__stash_record(history, new_record);
        
        new_record->restore_point = begin_temp(&history->arena);
        if (pos_before_edit >= 0){
            new_record->pos_before_edit = pos_before_edit;
        }
        else{
            new_record->pos_before_edit = edit.range.min;
        }
        
        new_record->edit_number = global_history_get_edit_number(global_history);
        
        new_record->kind = RecordKind_Single;
        
        new_record->single.forward_text = push_string_copy(&history->arena, edit.text);
        new_record->single.backward_text = buffer_stringify(&history->arena, buffer, edit.range);
        new_record->single.first = edit.range.first;
        
        Assert(history->record_lookup.count == history->record_count);
    }
}

internal void
history_dump_records_after_index(History *history, i32 index){
    if (history->activated){
        Assert(history->record_lookup.count == history->record_count);
        
        Assert(0 <= index && index <= history->record_count);
        if (index < history->record_count){
            Node *node = history__to_node(history, index);
            Node *first_node_to_clear = node->next;
            
            Node *sentinel = &history->records;
            Assert(first_node_to_clear != sentinel);
            
            Record *first_record_to_clear = CastFromMember(Record, node, first_node_to_clear);
            end_temp(first_record_to_clear->restore_point);
            
            Node *last_node_to_clear = sentinel->prev;
            
            history__free_nodes(history, index + 1, first_node_to_clear, last_node_to_clear);
        }
        
        Assert(history->record_lookup.count == history->record_count);
    }
}

internal void
history__optimize_group(Arena *scratch, History *history, Record *record){
    Assert(record->kind == RecordKind_Group);
    for (;;){
        Record *right = CastFromMember(Record, node, record->group.children.prev);
        if (record->group.count == 1){
            Record *child = right;
            record->restore_point = child->restore_point;
            record->pos_before_edit = child->pos_before_edit;
            record->edit_number = child->edit_number;
            record->kind = RecordKind_Single;
            record->single = child->single;
            // NOTE(allen): don't use "free" because the child node is no longer linked
            // to a valid sentinel, and removing it first (as free does) will mess with
            // the data in record->single
            dll_insert(&history->free_records, &child->node);
            break;
        }
        Record *left  = CastFromMember(Record, node, right->node.prev);
        if (right->kind == RecordKind_Single && left->kind == RecordKind_Single){
            b32 do_merge = false;
            
            Temp_Memory temp = begin_temp(scratch);
            i64 new_length_forward  = left->single.forward_text.size  + right->single.forward_text.size ;
            i64 new_length_backward = left->single.backward_text.size + right->single.backward_text.size;
            
            String_Const_u8 merged_forward = {};
            String_Const_u8 merged_backward = {};
            
            i64 merged_first = 0;
            if (left->single.first + (i64)left->single.forward_text.size == right->single.first){
                do_merge = true;
                merged_forward = push_u8_stringf(scratch, "%.*s%.*s",
                                                 string_expand(left->single.forward_text),
                                                 string_expand(right->single.forward_text));
                merged_backward = push_u8_stringf(scratch, "%.*s%.*s",
                                                  string_expand(left->single.backward_text),
                                                  string_expand(right->single.backward_text));
                merged_first = left->single.first;
            }
            else if (right->single.first + (i64)right->single.backward_text.size == left->single.first){
                do_merge = true;
                merged_forward = push_u8_stringf(scratch, "%.*s%.*s",
                                                 string_expand(right->single.forward_text),
                                                 string_expand(left->single.forward_text));
                merged_backward = push_u8_stringf(scratch, "%.*s%.*s",
                                                  string_expand(right->single.backward_text),
                                                  string_expand(left->single.backward_text));
                merged_first = right->single.first;
            }
            else{
                break;
            }
            
            if (do_merge){
                end_temp(left->restore_point);
                
                left->edit_number = right->edit_number;
                left->single.first = merged_first;
                left->single.forward_text  = push_string_copy(&history->arena, merged_forward);
                left->single.backward_text = push_string_copy(&history->arena, merged_backward);
                
                history__free_single_node(history, &right->node);
                record->group.count -= 1;
            }
            
            end_temp(temp);
        }
        else{
            break;
        }
    }
}

internal void
history_merge_records(Arena *scratch, History *history, i32 first_index, i32 last_index){
    if (history->activated){
        Assert(history->record_lookup.count == history->record_count);
        Assert(first_index < last_index);
        Node *first_node = history__to_node(history, first_index);
        Node *last_node  = history__to_node(history, last_index );
        Assert(first_node != &history->records && first_node != 0);
        Assert(last_node  != &history->records && last_node  != 0);
        
        Record *new_record = history__allocate_record(history);
        
        // NOTE(allen): here we remove (last_index - first_index + 1) nodes, and insert 1 node
        // which simplifies to this:
        history->record_count -= last_index - first_index;
        
        Node *left = first_node->prev;
        dll_remove_multiple(first_node, last_node);
        dll_insert(left, &new_record->node);
        
        Record *first_record = CastFromMember(Record, node, first_node);
        Record *last_record  = CastFromMember(Record, node, last_node);
        
        new_record->restore_point = first_record->restore_point;
        new_record->pos_before_edit = first_record->pos_before_edit;
        new_record->edit_number = last_record->edit_number;
        new_record->kind = RecordKind_Group;
        
        Node *new_sentinel = &new_record->group.children;
        dll_init_sentinel(new_sentinel);
        
        i32 count = 0;
        for (Node *node = first_node, *next = 0;
             node != 0;
             node = next){
            next = node->next;
            Record *record = CastFromMember(Record, node, node);
            switch (record->kind){
                case RecordKind_Single:
                {
                    dll_insert_back(new_sentinel, &record->node);
                    count += 1;
                }break;
                
                case RecordKind_Group:
                {
                    Node *first = record->group.children.next;
                    Node *last  = record->group.children.prev;
                    Assert(first != &record->group.children);
                    Assert(last  != &record->group.children);
                    
                    dll_insert_multiple_back(new_sentinel, first, last);
                    count += record->group.count;
                    
                    // TODO(allen): free the record for the old group!?
                }break;
                
                default:
                {
                    InvalidPath;
                }break;
            }
        }
        
        new_record->group.count = count;
        
        history__merge_record_ptr_range_to_one_ptr(&history->record_lookup, first_index, last_index, new_record);
        Assert(history->record_lookup.count == history->record_count);
        
        if (first_index == history->record_count){
            history__optimize_group(scratch, history, new_record);
        }
    }
}

// BOTTOM



// end --- 4ed_history.cpp --- 



// begin --- 4ed_file.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 03.01.2017
 *
 * File layer for 4coder
 *
 */

// TOP

internal String_Const_u8
string_from_file_name(Editing_File_Name *name){
    return(SCu8(name->name_space, name->name_size));
}

////////////////////////////////

internal void
file_edit_positions_set_cursor(File_Edit_Positions *edit_pos, i64 pos){
    edit_pos->cursor_pos = pos;
    edit_pos->last_set_type = EditPos_CursorSet;
}

internal void
file_edit_positions_set_scroll(File_Edit_Positions *edit_pos, Buffer_Scroll scroll){
    edit_pos->scroll = scroll;
    edit_pos->last_set_type = EditPos_ScrollSet;
}

internal void
file_edit_positions_push(Editing_File *file, File_Edit_Positions edit_pos){
    if (file->state.edit_pos_stack_top + 1 < ArrayCount(file->state.edit_pos_stack)){
        file->state.edit_pos_stack_top += 1;
        file->state.edit_pos_stack[file->state.edit_pos_stack_top] = edit_pos;
    }
}

internal File_Edit_Positions
file_edit_positions_pop(Editing_File *file){
    File_Edit_Positions edit_pos = {};
    if (file->state.edit_pos_stack_top >= 0){
        edit_pos = file->state.edit_pos_stack[file->state.edit_pos_stack_top];
        file->state.edit_pos_stack_top -= 1;
    }
    else{
        edit_pos = file->state.edit_pos_most_recent;
    }
    return(edit_pos);
}

////////////////////////////////

internal Face*
file_get_face(Models *models, Editing_File *file){
    return(font_set_face_from_id(&models->font_set, file->settings.face_id));
}

internal Access_Flag
file_get_access_flags(Editing_File *file){
    Access_Flag flags = Access_Read|Access_Visible;
    if (!file->settings.read_only){
        flags |= Access_Write;
    }
    return(flags);
}

internal b32
file_needs_save(Editing_File *file){
    b32 result = false;
    if (HasFlag(file->state.dirty, DirtyState_UnsavedChanges)){
        result = true;
    }
    return(result);
}

internal b32
file_can_save(Editing_File *file){
    b32 result = false;
    if (HasFlag(file->state.dirty, DirtyState_UnsavedChanges) ||
        HasFlag(file->state.dirty, DirtyState_UnloadedChanges)){
        result = true;
    }
    return(result);
}

internal void
file_set_unimportant(Editing_File *file, b32 val){
    if (val){
        file->state.dirty = DirtyState_UpToDate;
    }
    file->settings.unimportant = (b8)(val);
}

internal void
file_add_dirty_flag(Editing_File *file, Dirty_State state){
    if (!file->settings.unimportant){
        file->state.dirty |= state;
    }
    else{
        file->state.dirty = DirtyState_UpToDate;
    }
}

internal void
file_clear_dirty_flags(Editing_File *file){
    file->state.dirty = DirtyState_UpToDate;
}

////////////////////////////////

internal void
file_name_terminate(Editing_File_Name *name){
    u64 size = name->name_size;
    size = clamp_top(size, sizeof(name->name_space) - 1);
    name->name_space[size] = 0;
    name->name_size = size;
}

////////////////////////////////

// TODO(allen): file_name should be String_Const_u8
internal b32
save_file_to_name(Thread_Context *tctx, Models *models, Editing_File *file, u8 *file_name){
    b32 result = false;
    b32 using_actual_file_name = false;
    
    if (file_name == 0){
        file_name_terminate(&file->canon);
        file_name = file->canon.name_space;
        using_actual_file_name = true;
    }
    
    if (file_name != 0){
        if (models->save_file != 0){
            Application_Links app = {};
            app.tctx = tctx;
            app.cmd_context = models;
            models->save_file(&app, file->id);
        }
        
        Gap_Buffer *buffer = &file->state.buffer;
        b32 dos_write_mode = file->settings.dos_write_mode;
        
        Scratch_Block scratch(tctx);
        
        if (!using_actual_file_name){
            String_Const_u8 s_file_name = SCu8(file_name);
            String_Const_u8 canonical_file_name = system_get_canonical(scratch, s_file_name);
            if (string_match(canonical_file_name, string_from_file_name(&file->canon))){
                using_actual_file_name = true;
            }
        }
        
        String_Const_u8 saveable_string = buffer_stringify(scratch, buffer, Ii64(0, buffer_size(buffer)));
        
        File_Attributes new_attributes = system_save_file(scratch, (char*)file_name, saveable_string);
        if (new_attributes.last_write_time > 0 &&
            using_actual_file_name){
            file->state.saved_record_index = file->state.current_record_index;
            file->state.save_state = FileSaveState_SavedWaitingForNotification;
            file_clear_dirty_flags(file);
        }
        LogEventF(log_string(M), scratch, file->id, 0, system_thread_get_id(),
                  "save file [last_write_time=0x%llx]", new_attributes.last_write_time);
    }
    
    return(result);
}

////////////////////////////////

internal Buffer_Cursor
file_compute_cursor(Editing_File *file, Buffer_Seek seek){
    Buffer_Cursor result = {};
    switch (seek.type){
        case buffer_seek_pos:
        {
            result = buffer_cursor_from_pos(&file->state.buffer, seek.pos);
        }break;
        case buffer_seek_line_col:
        {
            result = buffer_cursor_from_line_col(&file->state.buffer, seek.line, seek.col);
        }break;
    }
    return(result);
}

////////////////////////////////

function Layout_Function*
file_get_layout_func(Editing_File *file){
    return(file->settings.layout_func);
}

internal void
file_create_from_string(Thread_Context *tctx, Models *models, Editing_File *file, String_Const_u8 val, File_Attributes attributes){
    Scratch_Block scratch(tctx);
    
    Base_Allocator *allocator = tctx->allocator;
    block_zero_struct(&file->state);
    buffer_init(&file->state.buffer, val.str, val.size, allocator);
    
    if (buffer_size(&file->state.buffer) < (i64)val.size){
        file->settings.dos_write_mode = true;
    }
    file_clear_dirty_flags(file);
    file->attributes = attributes;
    
    file->settings.layout_func = models->layout_func;
    file->settings.face_id = models->global_face_id;
    
    buffer_measure_starts(scratch, &file->state.buffer);
    
    file->lifetime_object = lifetime_alloc_object(&models->lifetime_allocator, DynamicWorkspace_Buffer, file);
    history_init(tctx, models, &file->state.history);
    
    file->state.cached_layouts_arena = make_arena(allocator);
    file->state.line_layout_table = make_table_Data_u64(allocator, 500);
    
    file->settings.is_initialized = true;
    
    {
        Temp_Memory temp = begin_temp(scratch);
        String_Const_u8 name = SCu8(file->unique_name.name_space, file->unique_name.name_size);
        name = string_escape(scratch, name);
        LogEventF(log_string(M), scratch, file->id, 0, system_thread_get_id(),
                  "init file [lwt=0x%llx] [name=\"%.*s\"]",
                  attributes.last_write_time, string_expand(name));
        end_temp(temp);
    }
    
    ////////////////////////////////
    
    if (models->begin_buffer != 0){
        Application_Links app = {};
        app.tctx = tctx;
        app.cmd_context = models;
        models->begin_buffer(&app, file->id);
    }
}

internal void
file_free(Thread_Context *tctx, Models *models, Editing_File *file){
    Lifetime_Allocator *lifetime_allocator = &models->lifetime_allocator;
    Working_Set *working_set = &models->working_set;
    
    lifetime_free_object(lifetime_allocator, file->lifetime_object);
    
    Gap_Buffer *buffer = &file->state.buffer;
    if (buffer->data){
        base_free(buffer->allocator, buffer->data);
        base_free(buffer->allocator, buffer->line_starts);
    }
    
    history_free(tctx, &file->state.history);
    
    linalloc_clear(&file->state.cached_layouts_arena);
    table_free(&file->state.line_layout_table);
}

////////////////////////////////

internal i32
file_get_current_record_index(Editing_File *file){
    return(file->state.current_record_index);
}

internal Managed_Scope
file_get_managed_scope(Editing_File *file){
    Managed_Scope scope = 0;
    if (file != 0){
        Assert(file->lifetime_object != 0);
        scope = (Managed_Scope)file->lifetime_object->workspace.scope_id;
    }
    return(scope);
}

////////////////////////////////

internal Layout_Item_List
file_get_line_layout(Thread_Context *tctx, Models *models, Editing_File *file,
                     Layout_Function *layout_func, f32 width, Face *face, i64 line_number){
    Layout_Item_List result = {};
    
    i64 line_count = buffer_line_count(&file->state.buffer);
    if (1 <= line_number && line_number <= line_count){
        Line_Layout_Key key = {};
        key.face_id = face->id;
        key.face_version_number = face->version_number;
        key.width = width;
        key.line_number = line_number;
        
        String_Const_u8 key_data = make_data_struct(&key);
        
        Layout_Item_List *list = 0;
        
        Table_Lookup lookup = table_lookup(&file->state.line_layout_table, key_data);
        if (lookup.found_match){
            u64 val = 0;
            table_read(&file->state.line_layout_table, lookup, &val);
            list = (Layout_Item_List*)IntAsPtr(val);
        }
        else{
            list = push_array(&file->state.cached_layouts_arena, Layout_Item_List, 1);
            Range_i64 line_range = buffer_get_pos_range_from_line_number(&file->state.buffer, line_number);
            
            Application_Links app = {};
            app.tctx = tctx;
            app.cmd_context = models;
            *list = layout_func(&app, &file->state.cached_layouts_arena,
                                file->id, line_range, face->id, width);
            key_data = push_data_copy(&file->state.cached_layouts_arena, key_data);
            table_insert(&file->state.line_layout_table, key_data, (u64)PtrAsInt(list));
        }
        block_copy_struct(&result, list);
    }
    
    return(result);
}

internal void
file_clear_layout_cache(Editing_File *file){
    linalloc_clear(&file->state.cached_layouts_arena);
    table_clear(&file->state.line_layout_table);
}

internal Line_Shift_Vertical
file_line_shift_y(Thread_Context *tctx, Models *models, Editing_File *file,
                  Layout_Function *layout_func, f32 width, Face *face,
                  i64 line_number, f32 y_delta){
    Line_Shift_Vertical result = {};
    
    f32 line_y = 0.f;
    
    if (y_delta < 0.f){
        // NOTE(allen): Iterating upward
        b32 has_result = false;
        for (;;){
            if (line_y <= y_delta){
                has_result = true;
                result.line = line_number;
                result.y_delta = line_y;
                break;
            }
            line_number -= 1;
            if (line_number <= 0){
                line_number = 1;
                break;
            }
            Layout_Item_List line = file_get_line_layout(tctx, models, file, layout_func,
                                                         width, face, line_number);
            line_y -= line.height;
        }
        if (!has_result){
            result.line = line_number;
            result.y_delta = line_y;
        }
    }
    else{
        // NOTE(allen): Iterating downward
        b32 has_result = false;
        i64 line_count = buffer_line_count(&file->state.buffer);
        for (;;line_number += 1){
            Layout_Item_List line = file_get_line_layout(tctx, models, file, layout_func,
                                                         width, face, line_number);
            f32 next_y = line_y + line.height;
            if (y_delta < next_y){
                has_result = true;
                result.line = line_number;
                result.y_delta = line_y;
                break;
            }
            if (line_number >= line_count){
                break;
            }
            line_y = next_y;
        }
        if (!has_result){
            result.line = line_number;
            result.y_delta = line_y;
        }
    }
    
    return(result);
}

internal f32
file_line_y_difference(Thread_Context *tctx, Models *models, Editing_File *file,
                       Layout_Function *layout_func, f32 width, Face *face,
                       i64 line_a, i64 line_b){
    f32 result = 0.f;
    if (line_a != line_b){
        Range_i64 line_range = Ii64(line_a, line_b);
        for (i64 i = line_range.min; i < line_range.max; i += 1){
            Layout_Item_List line = file_get_line_layout(tctx, models, file, layout_func, width, face, i);
            result += line.height;
        }
        if (line_a < line_b){
            result *= -1.f;
        }
    }
    return(result);
}

internal i64
file_pos_at_relative_xy(Thread_Context *tctx, Models *models, Editing_File *file,
                        Layout_Function *layout_func, f32 width, Face *face,
                        i64 base_line, Vec2_f32 relative_xy){
    Line_Shift_Vertical shift = file_line_shift_y(tctx, models, file, layout_func, width, face, base_line, relative_xy.y);
    relative_xy.y -= shift.y_delta;
    Layout_Item_List line = file_get_line_layout(tctx, models, file, layout_func, width, face, shift.line);
    return(layout_nearest_pos_to_xy(line, relative_xy));
}

internal Rect_f32
file_relative_box_of_pos(Thread_Context *tctx, Models *models, Editing_File *file,
                         Layout_Function *layout_func, f32 width, Face *face,
                         i64 base_line, i64 pos){
    i64 line_number = buffer_get_line_index(&file->state.buffer, pos) + 1;
    Layout_Item_List line = file_get_line_layout(tctx, models, file, layout_func, width, face, line_number);
    Rect_f32 result = layout_box_of_pos(line, pos);
    
    f32 y_difference = file_line_y_difference(tctx, models, file, layout_func, width, face, line_number, base_line);
    result.y0 += y_difference;
    result.y1 += y_difference;
    
    return(result);
}

function Vec2_f32
file_relative_xy_of_pos(Thread_Context *tctx, Models *models, Editing_File *file,
                        Layout_Function *layout_func, f32 width, Face *face,
                        i64 base_line, i64 pos){
    Rect_f32 rect = file_relative_box_of_pos(tctx, models, file, layout_func, width, face, base_line, pos);
    return(rect_center(rect));
}

function Rect_f32
file_padded_box_of_pos(Thread_Context *tctx, Models *models, Editing_File *file,
                       Layout_Function *layout_func, f32 width, Face *face,
                       i64 base_line, i64 pos){
    i64 line_number = buffer_get_line_index(&file->state.buffer, pos) + 1;
    Layout_Item_List line = file_get_line_layout(tctx, models, file, layout_func, width, face, line_number);
    Rect_f32 result = layout_padded_box_of_pos(line, pos);
    
    f32 y_difference = file_line_y_difference(tctx, models, file, layout_func, width, face, line_number, base_line);
    result.y0 += y_difference;
    result.y1 += y_difference;
    
    return(result);
}

internal Buffer_Point
file_normalize_buffer_point(Thread_Context *tctx, Models *models, Editing_File *file,
                            Layout_Function *layout_func, f32 width, Face *face,
                            Buffer_Point point){
    Line_Shift_Vertical shift = file_line_shift_y(tctx, models, file, layout_func, width, face, point.line_number, point.pixel_shift.y);
    point.line_number = shift.line;
    point.pixel_shift.y -= shift.y_delta;
    point.pixel_shift.x = clamp_bot(0.f, point.pixel_shift.x);
    point.pixel_shift.y = clamp_bot(0.f, point.pixel_shift.y);
    return(point);
}

internal Vec2_f32
file_buffer_point_difference(Thread_Context *tctx, Models *models, Editing_File *file,
                             Layout_Function *layout_func, f32 width, Face *face,
                             Buffer_Point a, Buffer_Point b){
    f32 y_difference = file_line_y_difference(tctx, models, file, layout_func, width, face, a.line_number, b.line_number);
    Vec2_f32 result = a.pixel_shift - b.pixel_shift;
    result.y += y_difference;
    return(result);
}

internal Line_Shift_Character
file_line_shift_characters(Thread_Context *tctx, Models *models, Editing_File *file, Layout_Function *layout_func, f32 width, Face *face, i64 line_number, i64 character_delta){
    Line_Shift_Character result = {};
    
    i64 line_character = 0;
    
    if (character_delta < 0){
        // NOTE(allen): Iterating upward
        b32 has_result = false;
        for (;;){
            if (line_character <= character_delta){
                has_result = true;
                result.line = line_number;
                result.character_delta = line_character;
                break;
            }
            line_number -= 1;
            if (line_number <= 0){
                line_number = 1;
                break;
            }
            Layout_Item_List line = file_get_line_layout(tctx, models, file, layout_func, width, face, line_number);
            line_character -= line.character_count;
        }
        if (!has_result){
            result.line = line_number;
            result.character_delta = line_character;
        }
    }
    else{
        // NOTE(allen): Iterating downward
        b32 has_result = false;
        i64 line_count = buffer_line_count(&file->state.buffer);
        for (;;line_number += 1){
            Layout_Item_List line = file_get_line_layout(tctx, models, file, layout_func, width, face, line_number);
            i64 next_character = line_character + line.character_count;
            if (character_delta < next_character){
                has_result = true;
                result.line = line_number;
                result.character_delta = line_character;
                break;
            }
            if (line_number >= line_count){
                break;
            }
            line_character = next_character;
        }
        if (!has_result){
            result.line = line_number;
            result.character_delta = line_character;
        }
    }
    
    return(result);
}

internal i64
file_line_character_difference(Thread_Context *tctx, Models *models, Editing_File *file, Layout_Function *layout_func, f32 width, Face *face, i64 line_a, i64 line_b){
    i64 result = 0;
    if (line_a != line_b){
        Range_i64 line_range = Ii64(line_a, line_b);
        for (i64 i = line_range.min; i < line_range.max; i += 1){
            Layout_Item_List line = file_get_line_layout(tctx, models, file, layout_func, width, face, i);
            result += line.character_count;
        }
        if (line_a < line_b){
            result *= -1;
        }
    }
    return(result);
}

internal i64
file_pos_from_relative_character(Thread_Context *tctx, Models *models, Editing_File *file,
                                 Layout_Function *layout_func, f32 width, Face *face,
                                 i64 base_line, i64 relative_character){
    Line_Shift_Character shift = file_line_shift_characters(tctx, models, file, layout_func, width, face, base_line, relative_character);
    relative_character -= shift.character_delta;
    Layout_Item_List line = file_get_line_layout(tctx, models, file, layout_func, width, face, shift.line);
    return(layout_get_pos_at_character(line, relative_character));
}

internal i64
file_relative_character_from_pos(Thread_Context *tctx, Models *models, Editing_File *file, Layout_Function *layout_func, f32 width, Face *face,
                                 i64 base_line, i64 pos){
    i64 line_number = buffer_get_line_index(&file->state.buffer, pos) + 1;
    Layout_Item_List line = file_get_line_layout(tctx, models, file, layout_func, width, face, line_number);
    i64 result = layout_character_from_pos(line, pos);
    result += file_line_character_difference(tctx, models, file, layout_func, width, face, line_number, base_line);
    return(result);
}

// BOTTOM



// end --- 4ed_file.cpp --- 



// begin --- 4ed_working_set.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 03.01.2017
 *
 * Working_Set data structure
 *
 */

// TOP

internal void
working_set_file_default_settings(Working_Set *working_set, Editing_File *file){
    block_zero_struct(&file->settings);
}

////////////////////////////////

internal void
file_change_notification_check(Arena *scratch, Working_Set *working_set, Editing_File *file){
    if (file->canon.name_size > 0 && !file->settings.unimportant){
        String_Const_u8 name = SCu8(file->canon.name_space, file->canon.name_size);
        File_Attributes attributes = system_quick_file_attributes(scratch, name);
        if ((attributes.last_write_time > file->attributes.last_write_time) ||
            (attributes.last_write_time == 0 && file->attributes.last_write_time > 0)){
            if (file->state.save_state == FileSaveState_SavedWaitingForNotification){
                file->state.save_state = FileSaveState_Normal;
                file->attributes = attributes;
            }
            else{
                file_add_dirty_flag(file, DirtyState_UnloadedChanges);
                if (file->external_mod_node.next == 0){
                    LogEventF(log_string(M), &working_set->arena, file->id, 0, system_thread_get_id(),
                              "external modification [lwt=0x%llx]", attributes.last_write_time);
                    dll_insert_back(&working_set->has_external_mod_sentinel, &file->external_mod_node);
                    system_signal_step(0);
                }
            }
        }
        file->attributes = attributes;
    }
}

internal void
file_change_notification_thread_main(void *ptr){
    Models *models = (Models*)ptr;
    Arena arena = make_arena_system();
    Working_Set *working_set = &models->working_set;
    for (;;){
        system_sleep(Thousand(250));
        Mutex_Lock lock(working_set->mutex);
        if (working_set->active_file_count > 0){
            i32 check_count = working_set->active_file_count/16;
            check_count = clamp(1, check_count, 100);
            Node *used = &working_set->active_file_sentinel;
            Node *node = working_set->sync_check_iterator;
            if (node == 0 || node == used){
                node = used->next;
            }
            for (i32 i = 0; i < check_count; i += 1){
                Editing_File *file = CastFromMember(Editing_File, main_chain_node, node);
                node = node->next;
                if (node == used){
                    node = node->next;
                }
                file_change_notification_check(&arena, working_set, file);
            }
            working_set->sync_check_iterator = node;
        }
    }
}

////////////////////////////////

internal Editing_File*
working_set_allocate_file(Working_Set *working_set, Lifetime_Allocator *lifetime_allocator){
    Editing_File *file = working_set->free_files;
    if (file == 0){
        file = push_array(&working_set->arena, Editing_File, 1);
    }
    else{
        sll_stack_pop(working_set->free_files);
    }
    block_zero_struct(file);
    
    dll_insert_back(&working_set->active_file_sentinel, &file->main_chain_node);
    dll_insert_back(&working_set->touch_order_sentinel, &file->touch_node);
    working_set->active_file_count += 1;
    
    file->id = working_set->id_counter;
    working_set->id_counter += 1;
    
    working_set_file_default_settings(working_set, file);
    
    table_insert(&working_set->id_to_ptr_table,
                 (u64)file->id, (u64)(PtrAsInt(file)));
    
    return(file);
}

internal void
working_set_free_file(Heap *heap, Working_Set *working_set, Editing_File *file){
    if (working_set->sync_check_iterator == &file->main_chain_node){
        working_set->sync_check_iterator = working_set->sync_check_iterator->next;
    }
    dll_remove(&file->main_chain_node);
    dll_remove(&file->touch_node);
    working_set->active_file_count -= 1;
    table_erase(&working_set->id_to_ptr_table, file->id);
    sll_stack_push(working_set->free_files, file);
}

internal Editing_File*
working_set_get_file(Working_Set *working_set, Buffer_ID id){
    Editing_File *result = 0;
    u64 val = 0;
    if (table_read(&working_set->id_to_ptr_table, id, &val)){
        result = (Editing_File*)(IntAsPtr(val));
    }
    return(result);
}

internal void
working_set_init(Models *models, Working_Set *working_set){
    block_zero_struct(working_set);
    working_set->arena = make_arena_system();
    
    working_set->id_counter = 1;
    
    dll_init_sentinel(&working_set->active_file_sentinel);
    dll_init_sentinel(&working_set->touch_order_sentinel);
    
    local_const i32 slot_count = 128;
    Base_Allocator *allocator = get_base_allocator_system();
    working_set->id_to_ptr_table = make_table_u64_u64(allocator, slot_count);
    working_set->canon_table = make_table_Data_u64(allocator, slot_count);
    working_set->name_table = make_table_Data_u64(allocator, slot_count);
    
    dll_init_sentinel(&working_set->has_external_mod_sentinel);
    working_set->mutex = system_mutex_make();
    working_set->file_change_thread = system_thread_launch(file_change_notification_thread_main, models);
}

internal Editing_File*
working_set_contains__generic(Working_Set *working_set, Table_Data_u64 *table, String_Const_u8 name){
    Editing_File *result = 0;
    u64 val = 0;
    if (table_read(table, make_data(name.str, name.size), &val)){
        result = working_set_get_file(working_set, (Buffer_ID)val);
    }
    return(result);
}

internal b32
working_set_add__generic(Table_Data_u64 *table, Buffer_ID id, String_Const_u8 name){
    return(table_insert(table, make_data(name.str, name.size), id));
}

internal void
working_set_remove__generic(Table_Data_u64 *table, String_Const_u8 name){
    table_erase(table, make_data(name.str, name.size));
}

internal Editing_File*
working_set_contains_canon(Working_Set *working_set, String_Const_u8 name){
    return(working_set_contains__generic(working_set, &working_set->canon_table, name));
}

internal b32
working_set_canon_add(Working_Set *working_set, Editing_File *file, String_Const_u8 name){
    return(working_set_add__generic(&working_set->canon_table, file->id, name));
}

internal void
working_set_canon_remove(Working_Set *working_set, String_Const_u8 name){
    working_set_remove__generic(&working_set->canon_table, name);
}

internal Editing_File*
working_set_contains_name(Working_Set *working_set, String_Const_u8 name){
    return(working_set_contains__generic(working_set, &working_set->name_table, name));
}

internal b32
working_set_add_name(Working_Set *working_set, Editing_File *file, String_Const_u8 name){
    return(working_set_add__generic(&working_set->name_table, file->id, name));
}

internal void
working_set_remove_name(Working_Set *working_set, String_Const_u8 name){
    working_set_remove__generic(&working_set->name_table, name);
}

internal Editing_File*
get_file_from_identifier(Working_Set *working_set, Buffer_Identifier buffer){
    Editing_File *file = 0;
    if (buffer.id != 0){
        file = working_set_get_file(working_set, buffer.id);
    }
    else if (buffer.name != 0){
        String_Const_u8 name = SCu8(buffer.name, buffer.name_len);
        file = working_set_contains_name(working_set, name);
    }
    return(file);
}

////////////////////////////////

#if 0
// TODO(allen): Bring the clipboard fully to the custom side.
internal void
working_set_clipboard_clear(Heap *heap, Working_Set *working){
    String_Const_u8 *str = working->clipboards;
    for (i32 i = 0; i < working->clipboard_size; i += 1, str += 1){
        heap_free(heap, str->str);
        block_zero_struct(str);
    }
    working->clipboard_size = 0;
    working->clipboard_current = 0;
}

internal String_Const_u8*
working_set_next_clipboard_string(Heap *heap, Working_Set *working, u64 str_size){
    i32 clipboard_current = working->clipboard_current;
    if (working->clipboard_size == 0){
        clipboard_current = 0;
        working->clipboard_size = 1;
    }
    else{
        ++clipboard_current;
        if (clipboard_current >= working->clipboard_max_size){
            clipboard_current = 0;
        }
        else if (working->clipboard_size <= clipboard_current){
            working->clipboard_size = clipboard_current + 1;
        }
    }
    String_Const_u8 *result = &working->clipboards[clipboard_current];
    working->clipboard_current = clipboard_current;
    if (result->str != 0){
        heap_free(heap, result->str);
    }
    u8 *new_str = (u8*)heap_allocate(heap, (i32)(str_size + 1));
    *result = SCu8(new_str, str_size);
    return(result);
}

internal String_Const_u8*
working_set_clipboard_index(Working_Set *working, i32 index){
    String_Const_u8 *result = 0;
    i32 size = working->clipboard_size;
    i32 current = working->clipboard_current;
    if (index >= 0 && size > 0){
        index = index % size;
        index = current + size - index;
        index = index % size;
        result = &working->clipboards[index];
    }
    return(result);
}
#endif

////////////////////////////////

// TODO(allen): get rid of this???
internal b32
get_canon_name(Arena *scratch, String_Const_u8 file_name, Editing_File_Name *canon_name){
    Temp_Memory temp = begin_temp(scratch);
    String_Const_u8 canonical = system_get_canonical(scratch, file_name);
    u64 size = Min(sizeof(canon_name->name_space), canonical.size);
    block_copy(canon_name->name_space, canonical.str, size);
    canon_name->name_size = size;
    end_temp(temp);
    file_name_terminate(canon_name);
    return(canon_name->name_size > 0);
}

internal void
file_bind_file_name(Working_Set *working_set, Editing_File *file, String_Const_u8 canon_file_name){
    Assert(file->unique_name.name_size == 0);
    Assert(file->canon.name_size == 0);
    u64 size = canon_file_name.size;
    size = clamp_top(size, sizeof(file->canon.name_space) - 1);
    file->canon.name_size = size;
    block_copy(file->canon.name_space, canon_file_name.str, size);
    file_name_terminate(&file->canon);
    b32 result = working_set_canon_add(working_set, file, string_from_file_name(&file->canon));
    Assert(result);
}

internal void
buffer_unbind_file(Working_Set *working_set, Editing_File *file){
    Assert(file->unique_name.name_size == 0);
    Assert(file->canon.name_size != 0);
    working_set_canon_remove(working_set, string_from_file_name(&file->canon));
    file->canon.name_size = 0;
}

internal b32
buffer_name_has_conflict(Working_Set *working_set, String_Const_u8 base_name){
    b32 hit_conflict = false;
    Node *used_nodes = &working_set->active_file_sentinel;
    for (Node *node = used_nodes->next;
         node != used_nodes;
         node = node->next){
        Editing_File *file_ptr = CastFromMember(Editing_File, main_chain_node, node);
        if (file_ptr && string_match(base_name, string_from_file_name(&file_ptr->unique_name))){
            hit_conflict = true;
            break;
        }
    }
    return(hit_conflict);
}

internal void
buffer_resolve_name_low_level(Arena *scratch, Working_Set *working_set, Editing_File_Name *name, String_Const_u8 base_name){
    u64 size = base_name.size;
    size = clamp_top(size, sizeof(name->name_space));
    block_copy(name->name_space, base_name.str, size);
    String_u8 string = Su8(name->name_space, size, sizeof(name->name_space));
    u64 original_size = string.size;
    u64 file_x = 0;
    for (b32 hit_conflict = true; hit_conflict;){
        hit_conflict = buffer_name_has_conflict(working_set, string.string);
        if (hit_conflict){
            file_x += 1;
            string.size = original_size;
            Temp_Memory temp = begin_temp(scratch);
            String_Const_u8 int_str = string_from_integer(scratch, file_x, 10);
            string_append(&string, string_u8_litexpr(" ("));
            string_append(&string, int_str);
            string_append(&string, string_u8_litexpr(")"));
            end_temp(temp);
        }
    }
    name->name_size = string.size;
}

internal void
buffer_bind_name_low_level(Arena *scratch, Working_Set *working_set, Editing_File *file, String_Const_u8 base_name, String_Const_u8 name){
    Assert(file->base_name.name_size == 0);
    Assert(file->unique_name.name_size == 0);
    
    Editing_File_Name new_name = {};
    buffer_resolve_name_low_level(scratch, working_set, &new_name, name);
    
    {
        u64 size = base_name.size;
        size = clamp_top(size, sizeof(file->base_name.name_space));
        block_copy(file->base_name.name_space, base_name.str, size);
        file->base_name.name_size = size;
    }
    
    {
        u64 size = new_name.name_size;
        block_copy(file->unique_name.name_space, new_name.name_space, size);
        file->unique_name.name_size = size;
    }
    
    b32 result = working_set_add_name(working_set, file, string_from_file_name(&file->unique_name));
    Assert(result);
}

internal void
buffer_unbind_name_low_level(Working_Set *working_set, Editing_File *file){
    Assert(file->base_name.name_size != 0);
    Assert(file->unique_name.name_size != 0);
    working_set_remove_name(working_set, string_from_file_name(&file->unique_name));
    file->base_name.name_size = 0;
    file->unique_name.name_size = 0;
}

internal void
buffer_bind_name(Thread_Context *tctx, Models *models, Arena *scratch, Working_Set *working_set, Editing_File *file, String_Const_u8 base_name){
    Temp_Memory temp = begin_temp(scratch);
    
    // List of conflict files.
    struct Node_Ptr{
        Node_Ptr *next;
        Editing_File *file_ptr;
    };
    Node_Ptr *conflict_first = 0;
    Node_Ptr *conflict_last = 0;
    i32 conflict_count = 0;
    
    {
        Node_Ptr *node = push_array(scratch, Node_Ptr, 1);
        sll_queue_push(conflict_first, conflict_last, node);
        node->file_ptr = file;
        conflict_count += 1;
    }
    
    Node *used_nodes = &working_set->active_file_sentinel;
    for (Node *node = used_nodes->next;
         node != used_nodes;
         node = node->next){
        Editing_File *file_ptr = CastFromMember(Editing_File, main_chain_node, node);
        if (file_ptr != 0 && string_match(base_name, string_from_file_name(&file_ptr->base_name))){
            Node_Ptr *new_node = push_array(scratch, Node_Ptr, 1);
            sll_queue_push(conflict_first, conflict_last, new_node);
            new_node->file_ptr = file_ptr;
            conflict_count += 1;
        }
    }
    
    // Fill conflict array.
    Buffer_Name_Conflict_Entry *conflicts = push_array(scratch, Buffer_Name_Conflict_Entry, conflict_count);
    
    {
        i32 i = 0;
        for (Node_Ptr *node = conflict_first;
             node != 0;
             node = node->next, i += 1){
            Editing_File *file_ptr = node->file_ptr;
            Buffer_Name_Conflict_Entry *entry = &conflicts[i];
            entry->buffer_id = file_ptr->id;
            
            entry->file_name = push_string_copy(scratch, string_from_file_name(&file_ptr->canon));
            entry->base_name = push_string_copy(scratch, base_name);
            
            String_Const_u8 b = base_name;
            if (i > 0){
                b = string_from_file_name(&file_ptr->unique_name);
            }
            u64 unique_name_capacity = 256;
            u8 *unique_name_buffer = push_array(scratch, u8, unique_name_capacity);
            Assert(b.size <= unique_name_capacity);
            block_copy(unique_name_buffer, b.str, b.size);
            entry->unique_name_in_out = unique_name_buffer;
            entry->unique_name_len_in_out = b.size;
            entry->unique_name_capacity = unique_name_capacity;
        }
    }
    
    // Get user's resolution data.
    if (models->buffer_name_resolver != 0){
        Application_Links app = {};
        app.tctx = tctx;
        app.cmd_context = models;
        models->buffer_name_resolver(&app, conflicts, conflict_count);
    }
    
    // Re-bind all of the files
    {
        i32 i = 0;
        for (Node_Ptr *node = conflict_first;
             node != 0;
             node = node->next, i += 1){
            Editing_File *file_ptr = node->file_ptr;
            if (file_ptr->unique_name.name_size > 0){
                buffer_unbind_name_low_level(working_set, file_ptr);
            }
        }
    }
    
    {
        i32 i = 0;
        for (Node_Ptr *node = conflict_first;
             node != 0;
             node = node->next, i += 1){
            Editing_File *file_ptr = node->file_ptr;
            Buffer_Name_Conflict_Entry *entry = &conflicts[i];
            String_Const_u8 unique_name = SCu8(entry->unique_name_in_out, entry->unique_name_len_in_out);
            buffer_bind_name_low_level(scratch, working_set, file_ptr, base_name, unique_name);
        }
    }
    
    end_temp(temp);
}

////////////////////////////////

internal void
file_touch(Working_Set *working_set, Editing_File *file){
    Assert(file != 0);
    dll_remove(&file->touch_node);
    dll_insert(&working_set->touch_order_sentinel, &file->touch_node);
}

internal Editing_File*
file_get_next(Working_Set *working_set, Editing_File *file){
    if (file != 0){
        Node *node = file->touch_node.next;
        file = CastFromMember(Editing_File, touch_node, node);
        if (node == &working_set->touch_order_sentinel){
            file = 0;
        }
    }
    else{
        if (working_set->active_file_count > 0){
            Node *node = working_set->touch_order_sentinel.next;
            file = CastFromMember(Editing_File, touch_node, node);
        }
    }
    return(file);
}

////////////////////////////////

internal Editing_File*
imp_get_file(Models *models, Buffer_ID buffer_id){
    Working_Set *working_set = &models->working_set;
    return(working_set_get_file(working_set, buffer_id));
}

// BOTTOM





// end --- 4ed_working_set.cpp --- 



// begin --- 4ed_hot_directory.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 03.01.2017
 *
 * Hot_Directory data structure for 4coder
 *
 */

// TOP

internal void
hot_directory_clean_end(Hot_Directory *hot_directory){
    String_Const_u8 str = hot_directory->string;
    if (!character_is_slash(string_get_character(str, str.size - 1))){
        hot_directory->string = string_remove_last_folder(str);
    }
}

internal i32
hot_directory_quick_partition(File_Info **infos, i32 start, i32 pivot){
    File_Info **p = infos + pivot;
    File_Info **a = infos + start;
    for (i32 i = start; i < pivot; ++i, ++a){
        b32 p_folder = (HasFlag((**p).attributes.flags, FileAttribute_IsDirectory));
        b32 a_folder = (HasFlag((**a).attributes.flags, FileAttribute_IsDirectory));
        i32 comp = p_folder - a_folder;
        if (comp == 0){
            comp = string_compare((**a).file_name, (**p).file_name);
        }
        if (comp < 0){
            Swap(File_Info*, *a, infos[start]);
            ++start;
        }
    }
    Swap(File_Info*, *p, infos[start]);
    return(start);
}

internal void
hot_directory_quick_sort(File_Info **infos, i32 start, i32 pivot){
    i32 mid = hot_directory_quick_partition(infos, start, pivot);
    if (start < mid-1) hot_directory_quick_sort(infos, start, mid-1);
    if (mid+1 < pivot) hot_directory_quick_sort(infos, mid+1, pivot);
}

internal void
hot_directory_fixup(Hot_Directory *hot_directory){
    File_List *files = &hot_directory->file_list;
    if (files->count >= 2){
        hot_directory_quick_sort(files->infos, 0, files->count - 1);
    }
}

internal void
hot_directory_set(Hot_Directory *hot_directory, String_Const_u8 str){
    linalloc_clear(&hot_directory->arena);
    hot_directory->string = push_string_copy(&hot_directory->arena, str);
    hot_directory->canonical = system_get_canonical(&hot_directory->arena, str);
    hot_directory->file_list = system_get_file_list(&hot_directory->arena, hot_directory->canonical);
}

internal void
hot_directory_reload(Arena *scratch, Hot_Directory *hot_directory){
    Temp_Memory temp = begin_temp(scratch);
    String_Const_u8 string = push_string_copy(scratch, hot_directory->string);
    hot_directory_set(hot_directory, string);
    end_temp(temp);
}

internal void
hot_directory_init(Arena *scratch, Hot_Directory *hot_directory, String_Const_u8 directory){
    hot_directory->arena = make_arena_system();
    Temp_Memory temp = begin_temp(scratch);
    String_Const_u8 dir = directory;
    if (!character_is_slash(string_get_character(directory, directory.size - 1))){
        dir = push_u8_stringf(scratch, "%.*s/", string_expand(directory));
    }
    hot_directory_set(hot_directory, dir);
    end_temp(temp);
}

// BOTTOM



// end --- 4ed_hot_directory.cpp --- 



// begin --- 4ed_cli.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 17.07.2017
 *
 * CLI handling code.
 *
 */

// TOP

internal void
child_process_container_init(Base_Allocator *allocator, Child_Process_Container *container){
    container->arena = make_arena(allocator);
    dll_init_sentinel(&container->child_process_active_list);
    dll_init_sentinel(&container->child_process_free_list);
    container->active_child_process_count = 0;
    container->child_process_id_counter = 0;
    container->id_to_ptr_table = make_table_u64_u64(allocator, 10);
    container->id_to_return_code_table = make_table_u64_u64(allocator, 10);
}

internal void
child_process_container_release(Child_Process_Container *container, Models *models){
    linalloc_clear(&container->arena);
    table_free(&container->id_to_ptr_table);
    block_zero_struct(container);
}

internal Child_Process_And_ID
child_process_alloc_new(Models *models, Child_Process_Container *container){
    Child_Process_And_ID result = {};
    Child_Process *new_process = 0;
    if (container->child_process_free_list.next != &container->child_process_free_list){
        Node *new_node = container->child_process_free_list.next;
        dll_remove(new_node);
        new_process = CastFromMember(Child_Process, node, new_node);
    }
    else{
        new_process = push_array(&container->arena, Child_Process, 1);
    }
    
    u32 new_id = ++container->child_process_id_counter;
    block_zero_struct(new_process);
    dll_insert_back(&container->child_process_active_list, &new_process->node);
    new_process->id = new_id;
    table_insert(&container->id_to_ptr_table, new_id, (u64)PtrAsInt(new_process));
    container->active_child_process_count += 1;
    
    result.process = new_process;
    result.id = new_id;
    return(result);
}

internal Child_Process*
child_process_from_id(Child_Process_Container *container, Child_Process_ID id){
    Table_Lookup lookup = table_lookup(&container->id_to_ptr_table, id);
    Child_Process *process = 0;
    if (lookup.found_match){
        u64 val = 0;
        table_read(&container->id_to_ptr_table, lookup, &val);
        process = (Child_Process*)IntAsPtr(val);
    }
    return(process);
}

internal b32
child_process_free(Child_Process_Container *container, Child_Process_ID id){
    b32 result = false;
    Child_Process *process = child_process_from_id(container, id);
    if (process != 0){
        table_erase(&container->id_to_ptr_table, id);
        dll_remove(&process->node);
        dll_insert(&container->child_process_free_list, &process->node);
        container->active_child_process_count -= 1;
        result = true;
    }
    return(result);
}

internal b32
child_process_set_return_code(Models *models, Child_Process_Container *container, Child_Process_ID id, i64 val){
    table_insert(&container->id_to_return_code_table, id, val);
    return(true);
}

internal b32
child_process_lookup_return_code(Child_Process_Container *container, Child_Process_ID id, i64 *out){
    b32 result = false;
    Table_Lookup lookup = table_lookup(&container->id_to_return_code_table, id);
    if (lookup.found_match){
        table_read(&container->id_to_return_code_table, lookup, (u64*)out);
        result = true;
    }
    return(result);
}

////////////////////////////////

internal b32
child_process_call(Thread_Context *tctx, Models *models, String_Const_u8 path, String_Const_u8 command, Child_Process_ID *id_out){
    b32 result = false;
    Scratch_Block scratch(tctx);
    String_Const_u8 path_n = push_string_copy(scratch, path);
    String_Const_u8 command_n = push_string_copy(scratch, command);
    CLI_Handles cli_handles = {};
    if (system_cli_call(scratch, (char*)path_n.str, (char*)command_n.str, &cli_handles)){
        Child_Process_And_ID new_process = child_process_alloc_new(models, &models->child_processes);
        *id_out = new_process.id;
        new_process.process->cli = cli_handles;
        result = true;
    }
    return(result);
}

internal b32
child_process_set_target_buffer(Models *models, Child_Process *child_process, Editing_File *file, Child_Process_Set_Target_Flags flags){
    b32 result = false;
    b32 fail_if_process_has_buffer = HasFlag(flags, ChildProcessSet_FailIfProcessAlreadyAttachedToABuffer);
    b32 fail_if_buffer_has_process = HasFlag(flags, ChildProcessSet_FailIfBufferAlreadyAttachedToAProcess);
    b32 process_has_buffer = (child_process->out_file != 0);
    b32 buffer_has_process = (file->state.attached_child_process != 0);
    b32 fail = ((process_has_buffer && fail_if_process_has_buffer) ||
                (buffer_has_process && fail_if_buffer_has_process));
    if (!fail){
        if (process_has_buffer){
            child_process->out_file->state.attached_child_process = 0;
        }
        if (buffer_has_process){
            Child_Process *attached_child_process = child_process_from_id(&models->child_processes, file->state.attached_child_process);
            if (attached_child_process != 0){
                attached_child_process->out_file = 0;
            }
        }
        child_process->out_file = file;
        child_process->cursor_at_end = HasFlag(flags, ChildProcessSet_CursorAtEnd);
        file->state.attached_child_process = child_process->id;
        result = true;
    }
    return(result);
}

internal Process_State
child_process_get_state(Child_Process_Container *child_processes, Child_Process_ID child_process_id){
    Child_Process *child_process = child_process_from_id(child_processes, child_process_id);
    Process_State result = {};
    if (child_processes != 0){
        result.valid = true;
        result.is_updating = true;
    }
    else if (child_process_lookup_return_code(child_processes, child_process_id, &result.return_code)){
        result.valid = true;
    }
    return(result);
}

// BOTTOM



// end --- 4ed_cli.cpp --- 



// begin --- 4ed_layout.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 19.08.2015
 *
 * Panel layout functions
 *
 */

// TOP

internal Panel_Split
make_panel_split(Panel_Split_Kind kind, i32 v){
    Panel_Split split = {};
    split.kind = kind;
    split.v_i32 = v;
    return(split);
}

internal Panel_Split
make_panel_split(Panel_Split_Kind kind, f32 v){
    Panel_Split split = {};
    split.kind = kind;
    split.v_f32 = v;
    return(split);
}

internal Panel_Split
make_panel_split_50_50(void){
    return(make_panel_split(PanelSplitKind_Ratio_Min, 0.5f));
}

internal Panel*
layout__alloc_panel(Layout *layout){
    Panel *panel = 0;
    Node *node = layout->free_panels.next;
    if (node != &layout->free_panels){
        dll_remove(node);
        panel = CastFromMember(Panel, node, node);
    }
    return(panel);
}

internal void
layout__free_panel(Layout *layout, Panel *panel){
    Assert(panel != layout->active_panel);
    Assert(panel != layout->root);
    dll_remove(&panel->node);
    dll_insert(&layout->free_panels, &panel->node);
    panel->kind = PanelKind_Unused;
}

internal void
layout__set_panel_rectangle(Layout *layout, Panel *panel, Rect_i32 rect){
    panel->rect_full = rect;
    panel->rect_inner = rect_inner(rect, layout->margin);
}

internal i32
layout__evaluate_split(Panel_Split split, i32 v0, i32 v1){
    i32 v = 0;
    switch (split.kind){
        case PanelSplitKind_Ratio_Min:
        {
            v = i32_round32(lerp((f32)v0, split.v_f32, (f32)v1));
        }break;
        case PanelSplitKind_Ratio_Max:
        {
            v = i32_round32(lerp((f32)v1, split.v_f32, (f32)v0));
        }break;
        case PanelSplitKind_FixedPixels_Min:
        {
            v = clamp_top(v0 + split.v_i32, v1);
        }break;
        case PanelSplitKind_FixedPixels_Max:
        {
            v = clamp_bot(v0, v1 - split.v_i32);
        }break;
    }
    return(v);
}

internal void
layout_propogate_sizes_down_from_node(Layout *layout, Panel *panel){
    if (panel->kind == PanelKind_Intermediate){
        Panel *tl_panel = panel->tl_panel;
        Panel *br_panel = panel->br_panel;
        
        Rect_i32 r1 = panel->rect_full;
        Rect_i32 r2 = panel->rect_full;
        
        if (panel->vertical_split){
            i32 x_pos = layout__evaluate_split(panel->split, r1.x0, r1.x1);
            r1.x1 = x_pos;
            r2.x0 = x_pos;
        }
        else{
            i32 y_pos = layout__evaluate_split(panel->split, r1.y0, r1.y1);
            r1.y1 = y_pos;
            r2.y0 = y_pos;
        }
        
        layout__set_panel_rectangle(layout, tl_panel, r1);
        layout__set_panel_rectangle(layout, br_panel, r2);
        
        layout_propogate_sizes_down_from_node(layout, tl_panel);
        layout_propogate_sizes_down_from_node(layout, br_panel);
    }
}

internal i32
layout_get_open_panel_count(Layout *layout){
    return(layout->open_panel_count);
}

internal Panel*
layout_get_first_open_panel(Layout *layout){
    Panel *panel = CastFromMember(Panel, node, layout->open_panels.next);
    if (panel != 0 && &panel->node == &layout->open_panels){
        panel = 0;
    }
    AssertImplies(panel != 0, panel->kind == PanelKind_Final);
    return(panel);
}

internal Panel*
layout_get_last_open_panel(Layout *layout){
    Panel *panel = CastFromMember(Panel, node, layout->open_panels.prev);
    if (panel != 0 && &panel->node == &layout->open_panels){
        panel = 0;
    }
    AssertImplies(panel != 0, panel->kind == PanelKind_Final);
    return(panel);
}

internal Panel*
layout_get_next_open_panel(Layout *layout, Panel *panel){
    panel = CastFromMember(Panel, node, panel->node.next);
    if (&panel->node == &layout->open_panels){
        panel = 0;
    }
    AssertImplies(panel != 0, panel->kind == PanelKind_Final);
    return(panel);
}

internal Panel*
layout_get_prev_open_panel(Layout *layout, Panel *panel){
    panel = CastFromMember(Panel, node, panel->node.prev);
    if (&panel->node == &layout->open_panels){
        panel = 0;
    }
    AssertImplies(panel != 0, panel->kind == PanelKind_Final);
    return(panel);
}

internal Panel*
layout_get_active_panel(Layout *layout){
    return(layout->active_panel);
}

internal b32
layout_split_panel(Layout *layout, Panel *panel, b32 vertical_split, Panel **new_panel_out){
    b32 result = false;
    if (layout->open_panel_count < layout->open_panel_max_count){
        Panel *min_panel = layout__alloc_panel(layout);
        Panel *max_panel = layout__alloc_panel(layout);
        
        if (panel->kind == PanelKind_Final){
            dll_remove(&panel->node);
            dll_insert(&layout->intermediate_panels, &panel->node);
            
            // init min_panel
            dll_insert(&layout->open_panels, &min_panel->node);
            
            panel->view->panel = min_panel;
            min_panel->parent = panel;
            min_panel->kind = PanelKind_Final;
            min_panel->view = panel->view;
        }
        else{
            // init min_panel
            dll_insert(&layout->intermediate_panels, &min_panel->node);
            
            panel->tl_panel->parent = min_panel;
            panel->br_panel->parent = min_panel;
            min_panel->parent = panel;
            min_panel->kind = PanelKind_Intermediate;
            min_panel->tl_panel = panel->tl_panel;
            min_panel->br_panel = panel->br_panel;
            min_panel->vertical_split = panel->vertical_split;
            min_panel->split = panel->split;
        }
        
        // init max_panel
        dll_insert(&layout->open_panels, &max_panel->node);
        
        *new_panel_out = max_panel;
        max_panel->parent = panel;
        max_panel->kind = PanelKind_Final;
        max_panel->view = 0;
        
        // modify panel
        panel->kind = PanelKind_Intermediate;
        panel->tl_panel = min_panel;
        panel->br_panel = max_panel;
        panel->vertical_split = vertical_split;
        panel->split = make_panel_split_50_50();
        
        // propogate rectangle sizes down from the new intermediate to
        // resize the panel and the new panel.
        layout_propogate_sizes_down_from_node(layout, panel);
        
        // update layout state
        layout->open_panel_count += 1;
        layout->active_panel = max_panel;
        layout->panel_state_dirty = true;
        
        result = true;
    }
    return(result);
}

internal b32
layout_close_panel(Layout *layout, Panel *panel){
    b32 result = false;
    if (layout->open_panel_count > 1){
        Panel *parent = panel->parent;
        Assert(parent != 0);
        
        // find sibling
        Panel *sibling = 0;
        if (parent->tl_panel == panel){
            sibling = parent->br_panel;
        }
        else{
            Assert(parent->br_panel == panel);
            sibling = parent->tl_panel;
        }
        
        // update layout state
        if (layout->active_panel == panel){
            Panel *new_active = sibling;
            for (;new_active->kind == PanelKind_Intermediate;){
                new_active = new_active->br_panel;
            }
            layout->active_panel = new_active;
        }
        layout->panel_state_dirty = true;
        layout->open_panel_count -= 1;
        
        // link grand parent and sibling
        Panel *g_parent = parent->parent;
        sibling->parent = g_parent;
        if (g_parent != 0){
            if (g_parent->tl_panel == parent){
                g_parent->tl_panel = sibling;
            }
            else{
                Assert(g_parent->br_panel == parent);
                g_parent->br_panel = sibling;
            }
        }
        else{
            Assert(parent == layout->root);
            layout->root = sibling;
        }
        
        // set sibling's size
        sibling->screen_region = parent->screen_region;
        
        // set the sizes down stream of sibling
        layout_propogate_sizes_down_from_node(layout, sibling);
        
        // free panel and parent
        layout__free_panel(layout, panel);
        layout__free_panel(layout, parent);
        
        result = true;
    }
    return(result);
}

internal Panel*
layout_initialize(Arena *arena, Layout *layout){
    i32 panel_alloc_count = MAX_VIEWS*2 - 1;
    Panel *panels = push_array(arena, Panel, panel_alloc_count);
    block_zero(panels, sizeof(*panels)*panel_alloc_count);
    
    layout->panel_first = panels;
    layout->panel_one_past_last = panels + panel_alloc_count;
    
    layout->margin = 3;
    layout->open_panel_count = 0;
    layout->open_panel_max_count = MAX_VIEWS;
    
    dll_init_sentinel(&layout->open_panels);
    dll_init_sentinel(&layout->intermediate_panels);
    
    Panel *panel = panels;
    layout->free_panels.next = &panel->node;
    panel->node.prev = &layout->free_panels;
    for (i32 i = 1; i < panel_alloc_count; i += 1, panel += 1){
        panel[1].node.prev = &panel[0].node;
        panel[0].node.next = &panel[1].node;
    }
    panel->node.next = &layout->free_panels;
    layout->free_panels.prev = &panel->node;
    
    panel = layout__alloc_panel(layout);
    panel->parent = 0;
    panel->kind = PanelKind_Final;
    panel->view = 0;
    block_zero_struct(&panel->screen_region);
    
    dll_insert(&layout->open_panels, &panel->node);
    layout->open_panel_count += 1;
    layout->root = panel;
    layout->active_panel = panel;
    layout->panel_state_dirty = true;
    
    return(panel);
}

internal void
layout_set_margin(Layout *layout, i32 margin){
    if (layout->margin != margin){
        layout->margin = margin;
        layout__set_panel_rectangle(layout, layout->root, Ri32(0, 0, layout->full_dim.x, layout->full_dim.y));
        layout_propogate_sizes_down_from_node(layout, layout->root);
        layout->panel_state_dirty = true;
    }
}

internal void
layout_set_root_size(Layout *layout, Vec2_i32 dim){
    if (layout->full_dim != dim){
        layout->full_dim = dim;
        layout__set_panel_rectangle(layout, layout->root, Ri32(0, 0, dim.x, dim.y));
        layout_propogate_sizes_down_from_node(layout, layout->root);
        layout->panel_state_dirty = true;
    }
}

internal Vec2_i32
layout_get_root_size(Layout *layout){
    return(layout->full_dim);
}

internal i32
layout_get_absolute_position_of_split(Panel *panel){
    i32 pos = 0;
    if (panel->vertical_split){
        pos = layout__evaluate_split(panel->split, panel->rect_full.x0, panel->rect_full.x1);
    }
    else{
        pos = layout__evaluate_split(panel->split, panel->rect_full.y0, panel->rect_full.y1);
    }
    return(pos);
}

internal Range_i32
layout__get_limiting_range_on_split_children(i32 mid, b32 vertical_split, Panel *panel, Range_i32 range){
    if (panel->kind == PanelKind_Intermediate){
        if (vertical_split == panel->vertical_split){
            i32 pos = layout_get_absolute_position_of_split(panel);
            if (mid < pos && pos < range.max){
                range.max = pos;
            }
            else if (range.min < pos && pos < mid){
                range.min = pos;
            }
        }
        range = layout__get_limiting_range_on_split_children(mid, vertical_split, panel->tl_panel, range);
        range = layout__get_limiting_range_on_split_children(mid, vertical_split, panel->br_panel, range);
    }
    return(range);
}

internal Range_i32
layout_get_limiting_range_on_split(Layout *layout, Panel *panel){
    // root level min max
    Range_i32 range = {};
    if (panel->vertical_split){
        range.max = layout->full_dim.x;
    }
    else{
        range.max = layout->full_dim.y;
    }
    
    // get mid
    i32 mid = layout_get_absolute_position_of_split(panel);
    
    // parents min max
    for (Panel *panel_it = panel;
         panel_it != 0;
         panel_it = panel_it->parent){
        if (panel->vertical_split == panel_it->vertical_split){
            i32 pos = layout_get_absolute_position_of_split(panel_it);
            if (mid < pos && pos < range.max){
                range.max = pos;
            }
            else if (range.min < pos && pos < mid){
                range.min = pos;
            }
        }
    }
    
    // children min max
    if (panel->kind == PanelKind_Intermediate){
        range = layout__get_limiting_range_on_split_children(mid, panel->vertical_split, panel->tl_panel, range);
        range = layout__get_limiting_range_on_split_children(mid, panel->vertical_split, panel->br_panel, range);
    }
    
    return(range);
}

internal void
layout__reverse_evaluate_panel_split(Panel *panel, i32 position){
    i32 v0 = 0;
    i32 v1 = 0;
    if (panel->vertical_split){
        v0 = panel->rect_full.x0;
        v1 = panel->rect_full.x1;
    }
    else{
        v0 = panel->rect_full.y0;
        v1 = panel->rect_full.y1;
    }
    switch (panel->split.kind){
        case PanelSplitKind_Ratio_Min:
        {
            panel->split.v_f32 = unlerp((f32)v0, (f32)position, (f32)v1);
        }break;
        case PanelSplitKind_Ratio_Max:
        {
            panel->split.v_f32 = unlerp((f32)v1, (f32)position, (f32)v0);
        }break;
        case PanelSplitKind_FixedPixels_Min:
        {
            panel->split.v_i32 = clamp(v0, position, v1) - v0;
        }break;
        case PanelSplitKind_FixedPixels_Max:
        {
            panel->split.v_i32 = v1 - clamp(v0, position, v1);
        }break;
    }
}

internal void
layout__set_split_absolute_position_inner(Panel *panel){
    if (panel->kind == PanelKind_Intermediate){
        Rect_i32 r = panel->rect_full;
        i32 position = 0;
        if (panel->vertical_split){
            position = layout__evaluate_split(panel->split, r.x0, r.x1);
        }
        else{
            position = layout__evaluate_split(panel->split, r.y0, r.y1);
        }
        layout__reverse_evaluate_panel_split(panel, position);
    }
}

internal void
layout_set_split_absolute_position(Layout *layout, Panel *panel, i32 absolute_position){
    if (panel->kind == PanelKind_Intermediate){
        layout__reverse_evaluate_panel_split(panel, absolute_position);
        layout__set_split_absolute_position_inner(panel->tl_panel);
        layout__set_split_absolute_position_inner(panel->br_panel);
        layout_propogate_sizes_down_from_node(layout, panel);
        layout->panel_state_dirty = true;
    }
}

internal Panel_ID
panel_get_id(Layout *layout, Panel *panel){
    Panel_ID id = 0;
    if (layout->panel_first <= panel && panel < layout->panel_one_past_last){
        id = (Panel_ID)(panel - layout->panel_first) + 1;
    }
    return(id);
}

////////////////////////////////

internal Panel*
imp_get_panel(Models *models, Panel_ID panel_id){
    Layout *layout = &models->layout;
    Panel *panel = layout->panel_first + panel_id - 1;
    if (!(layout->panel_first <= panel && panel < layout->panel_one_past_last)){
        panel = 0;
    }
    return(panel);
}

// BOTTOM



// end --- 4ed_layout.cpp --- 



// begin --- 4ed_view.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 19.08.2015
 *
 * Viewing
 *
 */

// TOP

function void
begin_handling_input(Models *models, User_Input *input){
    block_copy_struct(&models->current_input, input);
    models->current_input_sequence_number += 1;
}

////////////////////////////////

internal void
init_query_set(Query_Set *set){
    Query_Slot *slot = set->slots;
    set->free_slot = slot;
    set->used_slot = 0;
    for (i32 i = 0; i+1 < ArrayCount(set->slots); ++i, ++slot){
        slot->next = slot + 1;
    }
}

internal Query_Slot*
alloc_query_slot(Query_Set *set){
    Query_Slot *slot = set->free_slot;
    if (slot != 0){
        set->free_slot = slot->next;
        slot->next = set->used_slot;
        set->used_slot = slot;
    }
    return(slot);
}

internal void
free_query_slot(Query_Set *set, Query_Bar *match_bar){
    Query_Slot *slot = 0;
    Query_Slot *prev = 0;
    
    for (slot = set->used_slot; slot != 0; slot = slot->next){
        if (slot->query_bar == match_bar) break;
        prev = slot;
    }
    
    if (slot){
        if (prev){
            prev->next = slot->next;
        }
        else{
            set->used_slot = slot->next;
        }
        slot->next = set->free_slot;
        set->free_slot = slot;
    }
}

function void
free_all_queries(Query_Set *set){
    for (;set->used_slot != 0;){
        Query_Slot *slot = set->used_slot;
        set->used_slot = slot->next;
        slot->next = set->free_slot;
        set->free_slot = slot;
    }
}

////////////////////////////////

internal Access_Flag
view_get_access_flags(View *view){
    Access_Flag result = file_get_access_flags(view->file);
    View_Context_Node *node = view->ctx;
    b32 hides_buffer = (node != 0 && node->ctx.hides_buffer);
    if (hides_buffer){
        RemFlag(result, Access_Visible);
    }
    return(result);
}

internal i32
view_get_index(Live_Views *live_set, View *view){
    return((i32)(view - live_set->views));
}

internal View_ID
view_get_id(Live_Views *live_set, View *view){
    return((View_ID)(view - live_set->views) + 1);
}

internal View*
live_set_alloc_view(Lifetime_Allocator *lifetime_allocator, Live_Views *live_set, Panel *panel){
    Assert(live_set->count < live_set->max);
    ++live_set->count;
    
    View *result = live_set->free_sentinel.next;
    dll_remove(result);
    block_zero_struct(result);
    
    result->in_use = true;
    init_query_set(&result->query_set);
    result->lifetime_object = lifetime_alloc_object(lifetime_allocator, DynamicWorkspace_View, result);
    panel->view = result;
    result->panel = panel;
    
    return(result);
}

internal void
live_set_free_view(Lifetime_Allocator *lifetime_allocator, Live_Views *live_set, View *view){
    Assert(live_set->count > 0);
    --live_set->count;
    
    view->next = live_set->free_sentinel.next;
    view->prev = &live_set->free_sentinel;
    live_set->free_sentinel.next = view;
    view->next->prev = view;
    view->in_use = false;
    
    lifetime_free_object(lifetime_allocator, view->lifetime_object);
}

////////////////////////////////

internal File_Edit_Positions
view_get_edit_pos(View *view){
    return(view->edit_pos_);
}

internal void
view_set_edit_pos(View *view, File_Edit_Positions edit_pos){
    edit_pos.scroll.position.line_number = clamp_bot(1, edit_pos.scroll.position.line_number);
    edit_pos.scroll.target.line_number = clamp_bot(1, edit_pos.scroll.target.line_number);
    view->edit_pos_ = edit_pos;
    view->file->state.edit_pos_most_recent = edit_pos;
}

////////////////////////////////

internal Rect_f32
view_get_buffer_rect(Thread_Context *tctx, Models *models, View *view){
    Rect_f32 region = Rf32(view->panel->rect_full);
    if (models->buffer_region != 0){
        Rect_f32 rect = region;
        Rect_f32 sub_region = Rf32(V2f32(0, 0), rect_dim(rect));
        Application_Links app = {};
        app.tctx = tctx;
        app.cmd_context = models;
        sub_region = models->buffer_region(&app, view_get_id(&models->view_set, view), sub_region);
        region.p0 = rect.p0 + sub_region.p0;
        region.p1 = rect.p0 + sub_region.p1;
        region.x1 = clamp_top(region.x1, rect.x1);
        region.y1 = clamp_top(region.y1, rect.y1);
        region.x0 = clamp_top(region.x0, region.x1);
        region.y0 = clamp_top(region.y0, region.y1);
    }
    return(region);
}

internal f32
view_width(Thread_Context *tctx, Models *models, View *view){
    return(rect_width(view_get_buffer_rect(tctx, models, view)));
}

internal f32
view_height(Thread_Context *tctx, Models *models, View *view){
    return(rect_height(view_get_buffer_rect(tctx, models, view)));
}

////////////////////////////////

internal Layout_Item_List
view_get_line_layout(Thread_Context *tctx, Models *models, View *view, i64 line_number){
    Editing_File *file = view->file;
    Face *face = file_get_face(models, file);
    f32 width = view_width(tctx, models, view);
    Layout_Function *layout_func = file_get_layout_func(file);
    return(file_get_line_layout(tctx, models, file, layout_func, width, face, line_number));
}

internal Line_Shift_Vertical
view_line_shift_y(Thread_Context *tctx, Models *models, View *view,
                  i64 line_number, f32 y_delta){
    Editing_File *file = view->file;
    Face *face = file_get_face(models, file);
    f32 width = view_width(tctx, models, view);
    Layout_Function *layout_func = file_get_layout_func(file);
    return(file_line_shift_y(tctx, models, file, layout_func, width, face,
                             line_number, y_delta));
}

internal f32
view_line_y_difference(Thread_Context *tctx, Models *models, View *view,
                       i64 line_a, i64 line_b){
    Editing_File *file = view->file;
    Face *face = file_get_face(models, file);
    f32 width = view_width(tctx, models, view);
    Layout_Function *layout_func = file_get_layout_func(file);
    return(file_line_y_difference(tctx, models, file,
                                  layout_func, width, face, line_a, line_b));
}

internal i64
view_pos_at_relative_xy(Thread_Context *tctx, Models *models, View *view,
                        i64 base_line, Vec2_f32 relative_xy){
    Editing_File *file = view->file;
    Face *face = file_get_face(models, file);
    f32 width = view_width(tctx, models, view);
    Layout_Function *layout_func = file_get_layout_func(file);
    return(file_pos_at_relative_xy(tctx, models, file,
                                   layout_func, width, face, base_line, relative_xy));
}

internal Rect_f32
view_relative_box_of_pos(Thread_Context *tctx, Models *models, View *view,
                         i64 base_line, i64 pos){
    Editing_File *file = view->file;
    Face *face = file_get_face(models, file);
    f32 width = view_width(tctx, models, view);
    Layout_Function *layout_func = file_get_layout_func(file);
    return(file_relative_box_of_pos(tctx, models, file,
                                    layout_func, width, face, base_line, pos));
}

internal Vec2_f32
view_relative_xy_of_pos(Thread_Context *tctx, Models *models, View *view,
                        i64 base_line, i64 pos){
    Rect_f32 rect = view_relative_box_of_pos(tctx, models, view, base_line, pos);
    return(rect_center(rect));
}

function Rect_f32
view_padded_box_of_pos(Thread_Context *tctx, Models *models, View *view,
                       i64 base_line, i64 pos){
    Editing_File *file = view->file;
    Face *face = file_get_face(models, file);
    f32 width = view_width(tctx, models, view);
    Layout_Function *layout_func = file_get_layout_func(file);
    return(file_padded_box_of_pos(tctx, models, file,
                                  layout_func, width, face, base_line, pos));
}

internal Buffer_Point
view_normalize_buffer_point(Thread_Context *tctx, Models *models, View *view,
                            Buffer_Point point){
    Editing_File *file = view->file;
    Face *face = file_get_face(models, file);
    f32 width = view_width(tctx, models, view);
    Layout_Function *layout_func = file_get_layout_func(file);
    return(file_normalize_buffer_point(tctx, models, file,
                                       layout_func, width, face, point));
}

internal Vec2_f32
view_buffer_point_difference(Thread_Context *tctx, Models *models, View *view,
                             Buffer_Point a, Buffer_Point b){
    Editing_File *file = view->file;
    Face *face = file_get_face(models, file);
    f32 width = view_width(tctx, models, view);
    Layout_Function *layout_func = file_get_layout_func(file);
    return(file_buffer_point_difference(tctx, models, file,
                                        layout_func, width, face, a, b));
}

internal Buffer_Point
view_move_buffer_point(Thread_Context *tctx, Models *models, View *view,
                       Buffer_Point buffer_point, Vec2_f32 delta){
    delta += buffer_point.pixel_shift;
    Line_Shift_Vertical shift = view_line_shift_y(tctx, models, view, buffer_point.line_number, delta.y);
    buffer_point.line_number = shift.line;
    buffer_point.pixel_shift = V2f32(delta.x, delta.y - shift.y_delta);
    return(buffer_point);
}

internal Line_Shift_Character
view_line_shift_characters(Thread_Context *tctx, Models *models, View *view,
                           i64 line_number, i64 character_delta){
    Editing_File *file = view->file;
    Face *face = file_get_face(models, file);
    f32 width = view_width(tctx, models, view);
    Layout_Function *layout_func = file_get_layout_func(file);
    return(file_line_shift_characters(tctx, models, file,
                                      layout_func, width, face, line_number, character_delta));
}

internal i64
view_line_character_difference(Thread_Context *tctx, Models *models, View *view,
                               i64 line_a, i64 line_b){
    Editing_File *file = view->file;
    Face *face = file_get_face(models, file);
    f32 width = view_width(tctx, models, view);
    Layout_Function *layout_func = file_get_layout_func(file);
    return(file_line_character_difference(tctx, models, file, layout_func, width, face,
                                          line_a, line_b));
}

internal i64
view_pos_from_relative_character(Thread_Context *tctx, Models *models, View *view,
                                 i64 base_line, i64 relative_character){
    Editing_File *file = view->file;
    Face *face = file_get_face(models, file);
    f32 width = view_width(tctx, models, view);
    Layout_Function *layout_func = file_get_layout_func(file);
    return(file_pos_from_relative_character(tctx, models, file, layout_func, width, face,
                                            base_line, relative_character));
}

internal i64
view_relative_character_from_pos(Thread_Context *tctx, Models *models, View *view,
                                 i64 base_line, i64 pos){
    Editing_File *file = view->file;
    Face *face = file_get_face(models, file);
    f32 width = view_width(tctx, models, view);
    Layout_Function *layout_func = file_get_layout_func(file);
    return(file_relative_character_from_pos(tctx, models, file,
                                            layout_func, width, face, base_line, pos));
}

internal Buffer_Cursor
view_compute_cursor(View *view, Buffer_Seek seek){
    Editing_File *file = view->file;
    return(file_compute_cursor(file, seek));
}

////////////////////////////////

internal b32
view_move_view_to_cursor(Thread_Context *tctx, Models *models, View *view, Buffer_Scroll *scroll){
    Editing_File *file = view->file;
    Face *face = file_get_face(models, file);
    Rect_f32 rect = view_get_buffer_rect(tctx, models, view);
    Vec2_f32 view_dim = rect_dim(rect);
    
    Layout_Function *layout_func = file_get_layout_func(file);
    
    File_Edit_Positions edit_pos = view_get_edit_pos(view);
    Vec2_f32 p = file_relative_xy_of_pos(tctx, models, file,
                                         layout_func, view_dim.x, face,
                                         scroll->target.line_number, edit_pos.cursor_pos);
    p -= scroll->target.pixel_shift;
    
    f32 line_height = face->metrics.line_height;
    f32 normal_advance = face->metrics.normal_advance;
    
    Vec2_f32 margin = view->cursor_margin;
    Vec2_f32 push_in = view->cursor_push_in_multiplier;
    
    Vec2_f32 lim_dim = view_dim*0.45f;
    margin.x = clamp_top(margin.x, lim_dim.x);
    margin.y = clamp_top(margin.y, lim_dim.y);
    
    Vec2_f32 push_in_lim_dim = hadamard(lim_dim, V2f32(1.f/line_height, 1.f/normal_advance)) - margin;
	push_in_lim_dim.x = clamp_bot(0.f, push_in_lim_dim.x);
	push_in_lim_dim.y = clamp_bot(0.f, push_in_lim_dim.y);
    push_in.x = clamp_top(push_in.x, push_in_lim_dim.x);
    push_in.y = clamp_top(push_in.y, push_in_lim_dim.y);
    
    Vec2_f32 target_p_relative = {};
    if (p.y < margin.y){
        target_p_relative.y = p.y - margin.y - line_height*push_in.y;
    }
    else if (p.y > view_dim.y - margin.y){
        target_p_relative.y = (p.y + margin.y + line_height*push_in.y) - view_dim.y;
    }
    if (p.x < margin.x){
        target_p_relative.x = p.x - margin.x - normal_advance*push_in.x;
    }
    else if (p.x > view_dim.x - margin.x){
        target_p_relative.x = (p.x + margin.x + normal_advance*push_in.x) - view_dim.x;
    }
    scroll->target.pixel_shift += target_p_relative;
    scroll->target = view_normalize_buffer_point(tctx, models, view, scroll->target);
    scroll->target.pixel_shift.x = f32_round32(scroll->target.pixel_shift.x);
    scroll->target.pixel_shift.y = f32_round32(scroll->target.pixel_shift.y);
    
    return(target_p_relative != V2f32(0.f, 0.f));
}

internal b32
view_move_cursor_to_view(Thread_Context *tctx, Models *models, View *view, Buffer_Scroll scroll, i64 *pos_in_out, f32 preferred_x){
    Editing_File *file = view->file;
    Face *face = file_get_face(models, file);
    Rect_f32 rect = view_get_buffer_rect(tctx, models, view);
    Vec2_f32 view_dim = rect_dim(rect);
    
    Layout_Function *layout_func = file_get_layout_func(file);
    
    Vec2_f32 p = file_relative_xy_of_pos(tctx, models, file,
                                         layout_func, view_dim.x, face,
                                         scroll.target.line_number, *pos_in_out);
    p -= scroll.target.pixel_shift;
    
    f32 line_height = face->metrics.line_height;
    
    b32 adjusted_y = true;
    if (p.y < 0.f){
        p.y = line_height*1.5f;
    }
    else if (p.y > view_dim.y){
        p.y = view_dim.y - line_height*1.5f;
    }
    else{
        adjusted_y = false;
    }
    
    b32 result = false;
    if (adjusted_y){
        p += scroll.target.pixel_shift;
        *pos_in_out = file_pos_at_relative_xy(tctx, models, file,
                                              layout_func, view_dim.x, face,
                                              scroll.target.line_number, p);
        result = true;
    }
    
    return(result);
}

internal void
view_set_cursor(Thread_Context *tctx, Models *models, View *view, i64 pos){
    File_Edit_Positions edit_pos = view_get_edit_pos(view);
    file_edit_positions_set_cursor(&edit_pos, pos);
    view_set_edit_pos(view, edit_pos);
    Buffer_Scroll scroll = edit_pos.scroll;
    if (view_move_view_to_cursor(tctx, models, view, &scroll)){
        edit_pos.scroll = scroll;
        view_set_edit_pos(view, edit_pos);
    }
}

internal void
view_set_scroll(Thread_Context *tctx, Models *models, View *view, Buffer_Scroll scroll){
    File_Edit_Positions edit_pos = view_get_edit_pos(view);
    file_edit_positions_set_scroll(&edit_pos, scroll);
    view_set_edit_pos(view, edit_pos);
    if (view_move_cursor_to_view(tctx, models, view, edit_pos.scroll, &edit_pos.cursor_pos, view->preferred_x)){
        view_set_edit_pos(view, edit_pos);
    }
}

internal void
view_set_cursor_and_scroll(Thread_Context *tctx, Models *models, View *view, i64 pos, Buffer_Scroll scroll){
    File_Edit_Positions edit_pos = view_get_edit_pos(view);
    file_edit_positions_set_cursor(&edit_pos, pos);
    Buffer_Cursor cursor = view_compute_cursor(view, seek_pos(pos));
    Vec2_f32 p = view_relative_xy_of_pos(tctx, models, view, cursor.line, pos);
    view->preferred_x = p.x;
    file_edit_positions_set_scroll(&edit_pos, scroll);
    edit_pos.last_set_type = EditPos_None;
    view_set_edit_pos(view, edit_pos);
}

////////////////////////////////

internal void
view_set_file(Thread_Context *tctx, Models *models, View *view, Editing_File *file){
    Assert(file != 0);
    
    Editing_File *old_file = view->file;
    
    if (models->view_change_buffer != 0){
        Application_Links app = {};
        app.tctx = tctx;
        app.cmd_context = models;
        models->view_change_buffer(&app, view_get_id(&models->view_set, view),
                                   (old_file != 0)?old_file->id:0, file->id);
    }
    
    if (old_file != 0){
        file_touch(&models->working_set, old_file);
        file_edit_positions_push(old_file, view_get_edit_pos(view));
    }
    
    view->file = file;
    
    File_Edit_Positions edit_pos = file_edit_positions_pop(file);
    view_set_edit_pos(view, edit_pos);
    view->mark = edit_pos.cursor_pos;
    Buffer_Cursor cursor = view_compute_cursor(view, seek_pos(edit_pos.cursor_pos));
    Vec2_f32 p = view_relative_xy_of_pos(tctx, models, view, cursor.line, edit_pos.cursor_pos);
    view->preferred_x = p.x;
    
    models->layout.panel_state_dirty = true;
}

////////////////////////////////

function void
view_push_context(View *view, View_Context *ctx){
    Temp_Memory pop_me = begin_temp(&view->node_arena);
    View_Context_Node *node = push_array_zero(&view->node_arena, View_Context_Node, 1);
    sll_stack_push(view->ctx, node);
    node->pop_me = pop_me;
    block_copy_struct(&node->ctx, ctx);
    node->delta_rule_memory = push_array_zero(&view->node_arena, u8, ctx->delta_rule_memory_size);
}

function void
view_alter_context(View *view, View_Context *ctx){
    View_Context_Node *node = view->ctx;
    Assert(node != 0);
    block_copy_struct(&node->ctx, ctx);
}

function void
view_pop_context(View *view){
    View_Context_Node *node = view->ctx;
    if (node != 0 && node->next != 0){
        sll_stack_pop(view->ctx);
        end_temp(node->pop_me);
    }
}

function View_Context_Node*
view_current_context_node(View *view){
    return(view->ctx);
}

function View_Context
view_current_context(View *view){
    View_Context ctx = {};
    View_Context_Node *node = view->ctx;
    if (node != 0){
        block_copy_struct(&ctx, &node->ctx);
    }
    return(ctx);
}

////////////////////////////////

internal Coroutine*
co_handle_request(Thread_Context *tctx, Models *models, Coroutine *co, Co_Out *out){
    Coroutine *result = 0;
    switch (out->request){
        case CoRequest_NewFontFace:
        {
            Face_Description *description = out->face_description;
            Face *face = font_set_new_face(&models->font_set, description);
            Co_In in = {};
            in.face_id = (face != 0)?face->id:0;
            result = coroutine_run(&models->coroutines, co, &in, out);
        }break;
        
        case CoRequest_ModifyFace:
        {
            Face_Description *description = out->face_description;
            Face_ID face_id = out->face_id;
            Co_In in = {};
            in.success = font_set_modify_face(&models->font_set, face_id, description);
            result = coroutine_run(&models->coroutines, co, &in, out);
        }break;
        
        case CoRequest_AcquireGlobalFrameMutex:
        {
            system_acquire_global_frame_mutex(tctx);
            result = coroutine_run(&models->coroutines, co, 0, out);
        }break;
        
        case CoRequest_ReleaseGlobalFrameMutex:
        {
            system_release_global_frame_mutex(tctx);
            result = coroutine_run(&models->coroutines, co, 0, out);
        }break;
    }
    return(result);
}

internal Coroutine*
co_run(Thread_Context *tctx, Models *models, Coroutine *co, Co_In *in, Co_Out *out){
    Coroutine *result = coroutine_run(&models->coroutines, co, in, out);
    for (;result != 0 && out->request != CoRequest_None;){
        result = co_handle_request(tctx, models, result, out);
    }
    return(result);
}

internal void
view_event_context_base__inner(Coroutine *coroutine){
    Co_In *in = (Co_In*)coroutine->in;
    Models *models = in->models;
    Custom_Command_Function *event_context_base = in->event_context_base;
    Assert(event_context_base != 0);
    Application_Links app = {};
    app.tctx = coroutine->tctx;
    app.cmd_context = models;
    event_context_base(&app);
}

function void
view_init(Thread_Context *tctx, Models *models, View *view, Editing_File *initial_buffer,
          Custom_Command_Function *event_context_base){
    view_set_file(tctx, models, view, initial_buffer);
    
    view->node_arena = make_arena_system();
    
    View_Context first_ctx = {};
    first_ctx.render_caller = models->render_caller;
    first_ctx.delta_rule = models->delta_rule;
    first_ctx.delta_rule_memory_size = models->delta_rule_memory_size;
    view_push_context(view, &first_ctx);
    
    view->cursor_margin = V2f32(0.f, 0.f);
    view->cursor_push_in_multiplier = V2f32(1.5f, 1.5f);
    
    view->co = coroutine_create(&models->coroutines, view_event_context_base__inner);
    view->co->user_data = view;
    Co_In in = {};
    in.models = models;
    in.event_context_base = event_context_base;
    view->co = co_run(tctx, models, view->co, &in, &view->co_out);
    // TODO(allen): deal with this kind of problem!
    Assert(view->co != 0);
}

// TODO(allen): This doesn't make any sense!!!!!! COROUTINE SHUTDOWN? VIEW CLOSING? WADAFUQ?

function b32
view_close(Models *models, View *view){
    Layout *layout = &models->layout;
    b32 result = false;
    if (layout_close_panel(layout, view->panel)){
        if (view->co != 0){
            models_push_wind_down(models, view->co);
        }
        live_set_free_view(&models->lifetime_allocator, &models->view_set, view);
        result = true;
    }
    return(result);
}

internal void
view_check_co_exited(Models *models, View *view){
    if (view->co == 0){
        b32 result = view_close(models, view);
        // TODO(allen): Here it looks like the final view has
        // exited from it's event handler.  We should probably
        // have a failsafe restarter for the event handler when
        // this happens.
        Assert(result);
    }
}

// TODO(allen): This is dumb. Let's rethink view cleanup strategy.

internal void
co_single_abort(Thread_Context *tctx, Models *models, View *view){
    Coroutine *co = view->co;
    Co_In in = {};
    in.user_input.abort = true;
    view->co = co_run(tctx, models, co, &in, &view->co_out);
    view_check_co_exited(models, view);
}

internal void
co_full_abort(Thread_Context *tctx, Models *models, View *view){
    Coroutine *co = view->co;
    Co_In in = {};
    in.user_input.abort = true;
    for (u32 j = 0; j < 100 && co != 0; ++j){
        co  = co_run(tctx, models, co, &in, &view->co_out);
    }
    if (co != 0){
        Application_Links app = {};
        app.tctx = tctx;
        app.cmd_context = models;
#define M "SERIOUS ERROR: full stack abort did not complete"
        print_message(&app, string_u8_litexpr(M));
#undef M
    }
    view->co = 0;
    init_query_set(&view->query_set);
}

function b32
co_send_event(Thread_Context *tctx, Models *models, View *view, Input_Event *event){
    b32 event_was_handled = false;
    
    Coroutine *co = view->co;
    Co_Out *co_out = &view->co_out;
    
    {
        models->current_input_unhandled = false;
        Co_In in = {};
        in.user_input.event = *event;
        in.user_input.abort = false;
        begin_handling_input(models, &in.user_input);
        view->co = co_run(tctx, models, view->co, &in, &view->co_out);
        view_check_co_exited(models, view);
        if (!(event->kind == InputEventKind_Core && event->core.code == CoreCode_Animate)){
            models->animate_next_frame = true;
        }
        event_was_handled = !models->current_input_unhandled;
    }
    
    return(event_was_handled);
}

function b32
co_send_core_event(Thread_Context *tctx, Models *models, View *view, Core_Code code, String_Const_u8 string){
    Input_Event event = {};
    event.kind = InputEventKind_Core;
    event.core.code = code;
    event.core.string = string;
    return(co_send_event(tctx, models, view, &event));
}

function b32
co_send_core_event(Thread_Context *tctx, Models *models, View *view, Core_Code code, Buffer_ID id){
    Input_Event event = {};
    event.kind = InputEventKind_Core;
    event.core.code = code;
    event.core.id = id;
    return(co_send_event(tctx, models, view, &event));
}

function b32
co_send_core_event(Thread_Context *tctx, Models *models, View *view, Core_Code code){
    return(co_send_core_event(tctx, models, view, code, SCu8()));
}

function b32
co_send_event(Thread_Context *tctx, Models *models, Input_Event *event){
    Panel *active_panel = models->layout.active_panel;
    View *view = active_panel->view;
    return(co_send_event(tctx, models, view, event));
}

function b32
co_send_core_event(Thread_Context *tctx, Models *models, Core_Code code, String_Const_u8 string){
    Panel *active_panel = models->layout.active_panel;
    View *view = active_panel->view;
    return(co_send_core_event(tctx, models, view, code, string));
}

function b32
co_send_core_event(Thread_Context *tctx, Models *models, Core_Code code, Buffer_ID buffer_id){
    Panel *active_panel = models->layout.active_panel;
    View *view = active_panel->view;
    return(co_send_core_event(tctx, models, view, code, buffer_id));
}

function b32
co_send_core_event(Thread_Context *tctx, Models *models, Core_Code code){
    return(co_send_core_event(tctx, models, code, SCu8()));
}

////////////////////////////////

function void
view_quit_ui(Thread_Context *tctx, Models *models, View *view){
    for (u32 j = 0;; j += 1){
        if (j == 100){
            Application_Links app = {};
            app.tctx = tctx;
            app.cmd_context = models;
#define M "SERIOUS ERROR: view quit ui did not complete"
            print_message(&app, string_u8_litexpr(M));
#undef M
            break;
        }
        View_Context_Node *ctx = view->ctx;
        if (ctx->next == 0){
            break;
        }
        co_single_abort(tctx, models, view);
    }
}

////////////////////////////////

internal b32
file_is_viewed(Layout *layout, Editing_File *file){
    b32 is_viewed = false;
    for (Panel *panel = layout_get_first_open_panel(layout);
         panel != 0;
         panel = layout_get_next_open_panel(layout, panel)){
        View *view = panel->view;
        if (view->file == file){
            is_viewed = true;
            break;
        }
    }
    return(is_viewed);
}

internal void
adjust_views_looking_at_file_to_new_cursor(Thread_Context *tctx, Models *models, Editing_File *file){
    Layout *layout = &models->layout;
    for (Panel *panel = layout_get_first_open_panel(layout);
         panel != 0;
         panel = layout_get_next_open_panel(layout, panel)){
        View *view = panel->view;
        if (view->file == file){
            File_Edit_Positions edit_pos = view_get_edit_pos(view);
            view_set_cursor(tctx, models, view, edit_pos.cursor_pos);
        }
    }
}

internal void
global_set_font_and_update_files(Models *models, Face *new_global_face){
    for (Node *node = models->working_set.active_file_sentinel.next;
         node != &models->working_set.active_file_sentinel;
         node = node->next){
        Editing_File *file = CastFromMember(Editing_File, main_chain_node, node);
        file->settings.face_id = new_global_face->id;
    }
    models->global_face_id = new_global_face->id;
}

internal b32
release_font_and_update(Models *models, Face *face, Face *replacement_face){
    b32 success = false;
    Assert(replacement_face != 0 && replacement_face != face);
    if (font_set_release_face(&models->font_set, face->id)){
        for (Node *node = models->working_set.active_file_sentinel.next;
             node != &models->working_set.active_file_sentinel;
             node = node->next){
            Editing_File *file = CastFromMember(Editing_File, main_chain_node, node);
            if (file->settings.face_id == face->id){
                file->settings.face_id = replacement_face->id;
            }
        }
        if (models->global_face_id == face->id){
            models->global_face_id = replacement_face->id;
        }
        success = true;
    }
    return(success);
}

////////////////////////////////

internal View*
imp_get_view(Models *models, View_ID view_id){
    Live_Views *view_set = &models->view_set;
    View *view = 0;
    view_id -= 1;
    if (0 <= view_id && view_id < view_set->max){
        view = view_set->views + view_id;
        if (!view->in_use){
            view = 0;
        }
    }
    return(view);
}

// BOTTOM



// end --- 4ed_view.cpp --- 



// begin --- 4ed_edit.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 25.03.2018
 *
 * High level edit procedures
 *
 */

// TOP

function void
pre_edit_state_change(Models *models, Editing_File *file){
    file_add_dirty_flag(file, DirtyState_UnsavedChanges);
}

function void
pre_edit_history_prep(Editing_File *file, Edit_Behaviors behaviors){
    if (!behaviors.do_not_post_to_history){
        history_dump_records_after_index(&file->state.history,
                                         file->state.current_record_index);
    }
}

function void
post_edit_call_hook(Thread_Context *tctx, Models *models, Editing_File *file,
                    Range_i64 new_range, Range_Cursor old_cursor_range){
    // NOTE(allen): edit range hook
    if (models->buffer_edit_range != 0){
        Application_Links app = {};
        app.tctx = tctx;
        app.cmd_context = models;
        models->buffer_edit_range(&app, file->id, new_range, old_cursor_range);
    }
}

function void
edit_fix_markers__write_workspace_markers(Dynamic_Workspace *workspace, Buffer_ID buffer_id,
                                          Cursor_With_Index *cursors, Cursor_With_Index *r_cursors,
                                          i32 *cursor_count, i32 *r_cursor_count){
    for (Managed_Buffer_Markers_Header *node = workspace->buffer_markers_list.first;
         node != 0;
         node = node->next){
        if (node->buffer_id != buffer_id) continue;
        Marker *markers = (Marker*)(node + 1);
        Assert(sizeof(*markers) == node->std_header.item_size);
        i32 count = node->std_header.count;
        for (i32 i = 0; i < count; i += 1){
            if (markers[i].lean_right){
                write_cursor_with_index(r_cursors, r_cursor_count, markers[i].pos);
            }
            else{
                write_cursor_with_index(cursors  , cursor_count  , markers[i].pos);
            }
        }
    }
}

function void
edit_fix_markers__read_workspace_markers(Dynamic_Workspace *workspace, Buffer_ID buffer_id,
                                         Cursor_With_Index *cursors, Cursor_With_Index *r_cursors, i32 *cursor_count, i32 *r_cursor_count){
    for (Managed_Buffer_Markers_Header *node = workspace->buffer_markers_list.first;
         node != 0;
         node = node->next){
        if (node->buffer_id != buffer_id) continue;
        Marker *markers = (Marker*)(node + 1);
        Assert(sizeof(*markers) == node->std_header.item_size);
        i32 count = node->std_header.count;
        for (i32 i = 0; i < count; i += 1){
            if (markers[i].lean_right){
                markers[i].pos = r_cursors[(*r_cursor_count)++].pos;
            }
            else{
                markers[i].pos = cursors[(*cursor_count)++].pos;
            }
        }
    }
}

function f32
edit_fix_markers__compute_scroll_y(i32 line_height, f32 old_y_val, f32 new_y_val_aligned){
    f32 y_offset = mod_f32(old_y_val, line_height);
    f32 y_position = new_y_val_aligned + y_offset;
    return(y_position);
}

function i32
edit_fix_markers__compute_scroll_y(i32 line_height, i32 old_y_val, f32 new_y_val_aligned){
    return((i32)edit_fix_markers__compute_scroll_y(line_height, (f32)old_y_val, new_y_val_aligned));
}

function void
edit_fix_markers(Thread_Context *tctx, Models *models, Editing_File *file, Batch_Edit *batch){
    Layout *layout = &models->layout;
    
    Lifetime_Object *file_lifetime_object = file->lifetime_object;
    Buffer_ID file_id = file->id;
    Assert(file_lifetime_object != 0);
    
    i32 cursor_max = layout_get_open_panel_count(layout)*4;
    i32 total_marker_count = 0;
    {
        total_marker_count += file_lifetime_object->workspace.total_marker_count;
        
        i32 key_count = file_lifetime_object->key_count;
        i32 key_index = 0;
        for (Lifetime_Key_Ref_Node *key_node = file_lifetime_object->key_node_first;
             key_node != 0;
             key_node = key_node->next){
            i32 count = clamp_top(lifetime_key_reference_per_node, key_count - key_index);
            for (i32 i = 0; i < count; i += 1){
                Lifetime_Key *key = key_node->keys[i];
                total_marker_count += key->dynamic_workspace.total_marker_count;
            }
            key_index += count;
        }
    }
    cursor_max += total_marker_count;
    
    Scratch_Block scratch(tctx);
    
    Cursor_With_Index *cursors = push_array(scratch, Cursor_With_Index, cursor_max);
    Cursor_With_Index *r_cursors = push_array(scratch, Cursor_With_Index, cursor_max);
    i32 cursor_count = 0;
    i32 r_cursor_count = 0;
    Assert(cursors != 0);
    Assert(r_cursors != 0);
    
    for (Panel *panel = layout_get_first_open_panel(layout);
         panel != 0;
         panel = layout_get_next_open_panel(layout, panel)){
        View *view = panel->view;
        if (view->file == file){
            File_Edit_Positions edit_pos = view_get_edit_pos(view);
            write_cursor_with_index(cursors, &cursor_count, (i32)edit_pos.cursor_pos);
            write_cursor_with_index(cursors, &cursor_count, (i32)view->mark);
            Buffer_Cursor pos_cursor = file_compute_cursor(file, seek_line_col(edit_pos.scroll.position.line_number, 1));
            Buffer_Cursor targ_cursor = file_compute_cursor(file, seek_line_col(edit_pos.scroll.target.line_number, 1));
            write_cursor_with_index(cursors, &cursor_count, pos_cursor.pos);
            write_cursor_with_index(cursors, &cursor_count, targ_cursor.pos);
        }
    }
    
    edit_fix_markers__write_workspace_markers(&file_lifetime_object->workspace, file_id, cursors, r_cursors, &cursor_count, &r_cursor_count);
    
    {
        i32 key_count = file_lifetime_object->key_count;
        i32 key_index = 0;
        for (Lifetime_Key_Ref_Node *key_node = file_lifetime_object->key_node_first;
             key_node != 0;
             key_node = key_node->next){
            i32 count = clamp_top(lifetime_key_reference_per_node, key_count - key_index);
            for (i32 i = 0; i < count; i += 1){
                Lifetime_Key *key = key_node->keys[i];
                edit_fix_markers__write_workspace_markers(&key->dynamic_workspace, file_id, cursors, r_cursors, &cursor_count, &r_cursor_count);
            }
            key_index += count;
        }
    }
    
    buffer_remeasure_starts(tctx, &file->state.buffer, batch);
    
    if (cursor_count > 0 || r_cursor_count > 0){
        buffer_sort_cursors(  cursors,   cursor_count);
        buffer_sort_cursors(r_cursors, r_cursor_count);
        
        buffer_update_cursors_lean_l(  cursors,   cursor_count, batch);
        buffer_update_cursors_lean_r(r_cursors, r_cursor_count, batch);
        
        buffer_unsort_cursors(  cursors,   cursor_count);
        buffer_unsort_cursors(r_cursors, r_cursor_count);
        
        Face *face = file_get_face(models, file);
        
        cursor_count = 0;
        r_cursor_count = 0;
        for (Panel *panel = layout_get_first_open_panel(layout);
             panel != 0;
             panel = layout_get_next_open_panel(layout, panel)){
            View *view = panel->view;
            if (view->file == file){
                i64 cursor_pos = cursors[cursor_count++].pos;
                view->mark = cursors[cursor_count++].pos;
                File_Edit_Positions edit_pos = view_get_edit_pos(view);
                
                i64 scroll_pos = cursors[cursor_count++].pos;
                i64 scroll_targ = cursors[cursor_count++].pos;
                Buffer_Cursor pos_cursor = file_compute_cursor(file, seek_pos(scroll_pos));
                Buffer_Cursor targ_cursor = file_compute_cursor(file, seek_pos(scroll_targ));
                edit_pos.scroll.position.line_number = pos_cursor.line;
                edit_pos.scroll.target.line_number = targ_cursor.line;
                
                view_set_cursor_and_scroll(tctx, models, view, cursor_pos, edit_pos.scroll);
            }
        }
        
        edit_fix_markers__read_workspace_markers(&file_lifetime_object->workspace, file_id, cursors, r_cursors, &cursor_count, &r_cursor_count);
        
        i32 key_count = file_lifetime_object->key_count;
        i32 key_index = 0;
        for (Lifetime_Key_Ref_Node *key_node = file_lifetime_object->key_node_first;
             key_node != 0;
             key_node = key_node->next){
            i32 count = clamp_top(lifetime_key_reference_per_node, key_count - key_index);
            for (i32 i = 0; i < count; i += 1){
                Lifetime_Key *key = key_node->keys[i];
                edit_fix_markers__read_workspace_markers(&key->dynamic_workspace, file_id, cursors, r_cursors, &cursor_count, &r_cursor_count);
            }
            key_index += count;
        }
    }
}

function void
file_end_file(Thread_Context *tctx, Models *models, Editing_File *file){
    if (models->end_buffer != 0){
        Application_Links app = {};
        app.tctx = tctx;
        app.cmd_context = models;
        models->end_buffer(&app, file->id);
    }
    Lifetime_Allocator *lifetime_allocator = &models->lifetime_allocator;
    lifetime_free_object(lifetime_allocator, file->lifetime_object);
    file->lifetime_object = lifetime_alloc_object(lifetime_allocator, DynamicWorkspace_Buffer, file);
}

function void
edit__apply(Thread_Context *tctx, Models *models, Editing_File *file, Range_i64 range, String_Const_u8 string, Edit_Behaviors behaviors){
    Edit edit = {};
    edit.text = string;
    edit.range = range;
    
    Gap_Buffer *buffer = &file->state.buffer;
    Assert(0 <= edit.range.first);
    Assert(edit.range.first <= edit.range.one_past_last);
    Assert(edit.range.one_past_last <= buffer_size(buffer));
    
    // NOTE(allen): history update
    if (!behaviors.do_not_post_to_history){
        ProfileTLBlock(tctx, &models->profile_list, "edit apply history");
        history_record_edit(&models->global_history, &file->state.history, buffer,
                            behaviors.pos_before_edit, edit);
        file->state.current_record_index =
            history_get_record_count(&file->state.history);
    }
    
    {
        ProfileTLBlock(tctx, &models->profile_list, "edit apply replace range");
        i64 shift_amount = replace_range_shift(edit.range, (i64)edit.text.size);
        buffer_replace_range(buffer, edit.range, edit.text, shift_amount);
    }
}

function void
edit_single(Thread_Context *tctx, Models *models, Editing_File *file,
            Range_i64 range, String_Const_u8 string, Edit_Behaviors behaviors){
    Range_Cursor cursor_range = {};
    cursor_range.min = file_compute_cursor(file, seek_pos(range.min));
    cursor_range.max = file_compute_cursor(file, seek_pos(range.max));
    
    pre_edit_state_change(models, file);
    pre_edit_history_prep(file, behaviors);
    
    edit__apply(tctx, models, file, range, string, behaviors);
    
    file_clear_layout_cache(file);
    
    Batch_Edit batch = {};
    batch.edit.text = string;
    batch.edit.range = range;
    
    edit_fix_markers(tctx, models, file, &batch);
    post_edit_call_hook(tctx, models, file, Ii64_size(range.first, string.size), cursor_range);
}

function void
edit__apply_record_forward(Thread_Context *tctx, Models *models, Editing_File *file, Record *record, Edit_Behaviors behaviors_prototype){
    // NOTE(allen): // NOTE(allen): // NOTE(allen): // NOTE(allen): // NOTE(allen):
    // Whenever you change this also change the backward version!
    
    switch (record->kind){
        case RecordKind_Single:
        {
            String_Const_u8 str = record->single.forward_text;
            Range_i64 range = Ii64(record->single.first, record->single.first + record->single.backward_text.size);
            edit_single(tctx, models, file, range, str, behaviors_prototype);
        }break;
        
        case RecordKind_Group:
        {
            Node *sentinel = &record->group.children;
            for (Node *node = sentinel->next;
                 node != sentinel;
                 node = node->next){
                Record *sub_record = CastFromMember(Record, node, node);
                edit__apply_record_forward(tctx, models, file, sub_record, behaviors_prototype);
            }
        }break;
        
        default:
        {
            InvalidPath;
        }break;
    }
}

function void
edit__apply_record_backward(Thread_Context *tctx, Models *models, Editing_File *file, Record *record, Edit_Behaviors behaviors_prototype){
    // NOTE(allen): // NOTE(allen): // NOTE(allen): // NOTE(allen): // NOTE(allen):
    // Whenever you change this also change the forward version!
    
    switch (record->kind){
        case RecordKind_Single:
        {
            String_Const_u8 str = record->single.backward_text;
            Range_i64 range = Ii64(record->single.first, record->single.first + record->single.forward_text.size);
            edit_single(tctx, models, file, range, str, behaviors_prototype);
        }break;
        
        case RecordKind_Group:
        {
            Node *sentinel = &record->group.children;
            for (Node *node = sentinel->prev;
                 node != sentinel;
                 node = node->prev){
                Record *sub_record = CastFromMember(Record, node, node);
                edit__apply_record_backward(tctx, models, file, sub_record, behaviors_prototype);
            }
        }break;
        
        default:
        {
            InvalidPath;
        }break;
    }
}

function void
edit_change_current_history_state(Thread_Context *tctx, Models *models, Editing_File *file, i32 target_index){
    History *history = &file->state.history;
    if (history->activated && file->state.current_record_index != target_index){
        Assert(0 <= target_index && target_index <= history->record_count);
        
        i32 current = file->state.current_record_index;
        Record *record = history_get_record(history, current);
        Assert(record != 0);
        Record *dummy_record = history_get_dummy_record(history);
        
        Edit_Behaviors behaviors_prototype = {};
        behaviors_prototype.do_not_post_to_history = true;
        behaviors_prototype.pos_before_edit = -1;
        
        if (current < target_index){
            do{
                current += 1;
                record = CastFromMember(Record, node, record->node.next);
                Assert(record != dummy_record);
                edit__apply_record_forward(tctx, models, file, record, behaviors_prototype);
            } while (current != target_index);
        }
        else{
            do{
                Assert(record != dummy_record);
                edit__apply_record_backward(tctx, models, file, record, behaviors_prototype);
                current -= 1;
                record = CastFromMember(Record, node, record->node.prev);
            } while (current != target_index);
        }
        
        file->state.current_record_index = current;
        if (file->state.saved_record_index == current){
            RemFlag(file->state.dirty, DirtyState_UnsavedChanges);
        }
    }
}

function b32
edit_merge_history_range(Thread_Context *tctx, Models *models, Editing_File *file, History_Record_Index first_index, History_Record_Index last_index, Record_Merge_Flag flags){
    b32 result = false;
    History *history = &file->state.history;
    if (history_is_activated(history)){
        i32 max_index = history_get_record_count(history);
        first_index = clamp_bot(1, first_index);
        if (first_index <= last_index && last_index <= max_index){
            if (first_index < last_index){
                i32 current_index = file->state.current_record_index;
                if (first_index <= current_index && current_index < last_index){
                    u32 in_range_handler = (flags & bitmask_2);
                    switch (in_range_handler){
                        case RecordMergeFlag_StateInRange_MoveStateForward:
                        {
                            edit_change_current_history_state(tctx, models, file, last_index);
                            current_index = last_index;
                        }break;
                        
                        case RecordMergeFlag_StateInRange_MoveStateBackward:
                        {
                            edit_change_current_history_state(tctx, models, file, first_index);
                            current_index = first_index;
                        }break;
                        
                        case RecordMergeFlag_StateInRange_ErrorOut:
                        {
                            goto done;
                        }break;
                    }
                }
                Scratch_Block scratch(tctx);
                history_merge_records(scratch, history, first_index, last_index);
                if (current_index >= last_index){
                    current_index -= (last_index - first_index);
                }
                file->state.current_record_index = current_index;
            }
            result = true;
        }
    }
    done:;
    return(result);
}

function b32
edit_batch_check(Thread_Context *tctx, Profile_Global_List *list, Batch_Edit *batch){
    ProfileTLScope(tctx, list, "batch check");
    b32 result = true;
    Range_i64 prev_range = Ii64(-1, 0);
    for (;batch != 0;
         batch = batch->next){
        if (batch->edit.range.first <= prev_range.first ||
            batch->edit.range.first < prev_range.one_past_last){
            result = false;
            break;
        }
    }
    return(result);
}

function b32
edit_batch(Thread_Context *tctx, Models *models, Editing_File *file,
           Batch_Edit *batch, Edit_Behaviors behaviors){
    b32 result = true;
    if (batch != 0){
        if (!edit_batch_check(tctx, &models->profile_list, batch)){
            result = false;
        }
        else{
            ProfileTLScope(tctx, &models->profile_list, "batch apply");
            
            pre_edit_state_change(models, file);
            pre_edit_history_prep(file, behaviors);
            
            History_Record_Index start_index = 0;
            if (history_is_activated(&file->state.history)){
                start_index = file->state.current_record_index;
            }
            
            ProfileTLBlockNamed(tctx, &models->profile_list, "batch text edits", profile_edits);
            
            Range_i64 old_range = {};
            old_range.min = batch->edit.range.min;
            for (Batch_Edit *edit = batch;
                 edit != 0;
                 edit = edit->next){
                if (edit->next == 0){
                    old_range.max = edit->edit.range.max;
                }
            }
            Range_Cursor cursor_range = {};
            cursor_range.min = file_compute_cursor(file, seek_pos(old_range.min));
            cursor_range.max = file_compute_cursor(file, seek_pos(old_range.max));
            
            Range_i64 new_range = Ii64_neg_inf;
            Gap_Buffer *buffer = &file->state.buffer;
            
            i32 batch_count = 0;
            i64 shift = 0;
            for (Batch_Edit *edit = batch;
                 edit != 0;
                 edit = edit->next){
                String_Const_u8 insert_string = edit->edit.text;
                
                Range_i64 edit_range = edit->edit.range;
                edit_range.first += shift;
                edit_range.one_past_last += shift;
                
                new_range.min = Min(new_range.min, edit_range.min);
                i64 new_max = (i64)(edit_range.min + insert_string.size);
                new_range.max = Max(new_range.max, new_max);
                
                i64 size = buffer_size(buffer);
                if (0 <= edit_range.first &&
                    edit_range.first <= edit_range.one_past_last &&
                    edit_range.one_past_last <= size){
                    edit__apply(tctx, models, file, edit_range, insert_string,
                                behaviors);
                    shift += replace_range_shift(edit_range, insert_string.size);
                    batch_count += 1;
                }
                else{
                    result = false;
                    break;
                }
            }
            ProfileCloseNow(profile_edits);
            
            if (history_is_activated(&file->state.history)){
                History_Record_Index last_index = file->state.current_record_index;
                if (start_index + 1 < last_index){
                    edit_merge_history_range(tctx, models, file,
                                             start_index + 1, last_index,
                                             RecordMergeFlag_StateInRange_ErrorOut);
                }
            }
            
            file_clear_layout_cache(file);
            
            edit_fix_markers(tctx, models, file, batch);
            
            post_edit_call_hook(tctx, models, file, new_range, cursor_range);
        }
    }
    
    return(result);
}

////////////////////////////////

function Editing_File*
create_file(Thread_Context *tctx, Models *models, String_Const_u8 file_name, Buffer_Create_Flag flags){
    Editing_File *result = 0;
    
    if (file_name.size > 0){
        Working_Set *working_set = &models->working_set;
        Heap *heap = &models->heap;
        
        Scratch_Block scratch(tctx);
        
        Editing_File *file = 0;
        b32 do_empty_buffer = false;
        Editing_File_Name canon = {};
        b32 has_canon_name = false;
        b32 buffer_is_for_new_file = false;
        
        // NOTE(allen): Try to get the file by canon name.
        if (HasFlag(flags, BufferCreate_NeverAttachToFile) == 0){
            if (get_canon_name(scratch, file_name, &canon)){
                has_canon_name = true;
                file = working_set_contains_canon(working_set, string_from_file_name(&canon));
            }
            else{
                do_empty_buffer = true;
            }
        }
        
        // NOTE(allen): Try to get the file by buffer name.
        if ((flags & BufferCreate_MustAttachToFile) == 0){
            if (file == 0){
                file = working_set_contains_name(working_set, file_name);
            }
        }
        
        // NOTE(allen): If there is still no file, create a new buffer.
        if (file == 0){
            Plat_Handle handle = {};
            
            // NOTE(allen): Figure out whether this is a new file, or an existing file.
            if (!do_empty_buffer){
                if ((flags & BufferCreate_AlwaysNew) != 0){
                    do_empty_buffer = true;
                }
                else{
                    if (!system_load_handle(scratch, (char*)canon.name_space, &handle)){
                        do_empty_buffer = true;
                    }
                }
            }
            
            if (do_empty_buffer){
                if (has_canon_name){
                    buffer_is_for_new_file = true;
                }
                if (!HasFlag(flags, BufferCreate_NeverNew)){
                    file = working_set_allocate_file(working_set, &models->lifetime_allocator);
                    if (file != 0){
                        if (has_canon_name){
                            file_bind_file_name(working_set, file, string_from_file_name(&canon));
                        }
                        String_Const_u8 front = string_front_of_path(file_name);
                        buffer_bind_name(tctx, models, scratch, working_set, file, front);
                        File_Attributes attributes = {};
                        file_create_from_string(tctx, models, file, SCu8(""), attributes);
                        result = file;
                    }
                }
            }
            else{
                File_Attributes attributes = system_load_attributes(handle);
                b32 in_heap_mem = false;
                char *buffer = push_array(scratch, char, (i32)attributes.size);
                
                if (buffer == 0){
                    buffer = heap_array(heap, char, (i32)attributes.size);
                    Assert(buffer != 0);
                    in_heap_mem = true;
                }
                
                if (system_load_file(handle, buffer, (i32)attributes.size)){
                    system_load_close(handle);
                    file = working_set_allocate_file(working_set, &models->lifetime_allocator);
                    if (file != 0){
                        file_bind_file_name(working_set, file, string_from_file_name(&canon));
                        String_Const_u8 front = string_front_of_path(file_name);
                        buffer_bind_name(tctx, models, scratch, working_set, file, front);
                        file_create_from_string(tctx, models, file, SCu8(buffer, (i32)attributes.size), attributes);
                        result = file;
                    }
                }
                else{
                    system_load_close(handle);
                }
                
                if (in_heap_mem){
                    heap_free(heap, buffer);
                }
            }
        }
        else{
            result = file;
        }
        
        if (file != 0 && HasFlag(flags, BufferCreate_JustChangedFile)){
            file->state.save_state = FileSaveState_SavedWaitingForNotification;
        }
        
        if (file != 0 && HasFlag(flags, BufferCreate_AlwaysNew)){
            i64 size = buffer_size(&file->state.buffer);
            if (size > 0){
                Edit_Behaviors behaviors = {};
                edit_single(tctx, models, file, Ii64(0, size), string_u8_litexpr(""), behaviors);
                if (has_canon_name){
                    buffer_is_for_new_file = true;
                }
            }
        }
        
        if (file != 0 && buffer_is_for_new_file &&
            !HasFlag(flags, BufferCreate_SuppressNewFileHook) &&
            models->new_file != 0){
            Application_Links app = {};
            app.tctx = tctx;
            app.cmd_context = models;
            models->new_file(&app, file->id);
        }
    }
    
    return(result);
}

// BOTTOM



// end --- 4ed_edit.cpp --- 



// begin --- 4ed_text_layout.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 31.03.2019
 *
 * Text layout representation
 *
 */

// TOP

internal void
text_layout_init(Thread_Context *tctx, Text_Layout_Container *container){
    block_zero_struct(container);
    container->node_arena = make_arena_system();
    container->table = make_table_u64_u64(tctx->allocator, 20);
}

internal Text_Layout*
text_layout_new__alloc_layout(Text_Layout_Container *container){
    Text_Layout *node = container->free_nodes;
    if (node == 0){
        node = push_array(&container->node_arena, Text_Layout, 1);
    }
    else{
        sll_stack_pop(container->free_nodes);
    }
    return(node);
}

internal void
text_layout_release(Thread_Context *tctx, Models *models, Text_Layout_Container *container, Text_Layout *layout){
    Arena arena = *layout->arena;
    linalloc_clear(&arena);
    sll_stack_push(container->free_nodes, layout);
}

internal Text_Layout_ID
text_layout_new(Text_Layout_Container *container, Arena *arena,
                Buffer_ID buffer_id, Buffer_Point point,
                Range_i64 visible_range, Range_i64 visible_line_number_range,
                Rect_f32 rect, ARGB_Color *item_colors, Layout_Function *layout_func){
    Text_Layout *new_layout_data = text_layout_new__alloc_layout(container);
    new_layout_data->arena = arena;
    new_layout_data->buffer_id = buffer_id;
    new_layout_data->point = point;
    new_layout_data->visible_range = visible_range;
    new_layout_data->visible_line_number_range = visible_line_number_range;
    new_layout_data->rect = rect;
    new_layout_data->item_colors = item_colors;
    new_layout_data->layout_func = layout_func;
    Text_Layout_ID new_id = ++container->id_counter;
    table_insert(&container->table, new_id, (u64)PtrAsInt(new_layout_data));
    return(new_id);
}

internal Text_Layout*
text_layout_get(Text_Layout_Container *container, Text_Layout_ID id){
    Text_Layout *result = 0;
    Table_Lookup lookup = table_lookup(&container->table, id);
    if (lookup.found_match){
        u64 ptr_val = 0;
        table_read(&container->table, lookup, &ptr_val);
        result = (Text_Layout*)IntAsPtr(ptr_val);
    }
    return(result);
}

internal b32
text_layout_erase(Thread_Context *tctx, Models *models, Text_Layout_Container *container, Text_Layout_ID id){
    b32 result = false;
    Table_Lookup lookup = table_lookup(&container->table, id);
    if (lookup.found_match){
        u64 ptr_val = 0;
        table_read(&container->table, lookup, &ptr_val);
        Text_Layout *ptr = (Text_Layout*)IntAsPtr(ptr_val);
        text_layout_release(tctx, models, container, ptr);
        table_erase(&container->table, lookup);
        result = true;
    }
    return(result);
}

////////////////////////////////

internal void
text_layout_render(Thread_Context *tctx, Models *models, Text_Layout *layout,
                   ARGB_Color special_color, ARGB_Color ghost_color){
    Editing_File *file = imp_get_file(models, layout->buffer_id);
    if (file != 0){
        Render_Target *target = models->target;
        Face *face = file_get_face(models, file);
        f32 width = rect_width(layout->rect);
        
        Vec2_f32 delta = V2f32(1.f, 0.f);
        
        Vec2_f32 shift_p = layout->rect.p0 - layout->point.pixel_shift;
        i64 first_index = layout->visible_range.first;
        i64 line_number = layout->visible_line_number_range.min;
        i64 line_number_last = layout->visible_line_number_range.max;
        Layout_Function *layout_func = layout->layout_func;
        for (;line_number <= line_number_last; line_number += 1){
            Layout_Item_List line = file_get_line_layout(tctx, models, file,
                                                         layout_func, width, face,
                                                         line_number);
            for (Layout_Item_Block *block = line.first;
                 block != 0;
                 block = block->next){
                Layout_Item *item = block->items;
                i64 count = block->item_count;
                ARGB_Color *item_colors = layout->item_colors;
                for (i32 i = 0; i < count; i += 1, item += 1){
                    if (item->codepoint != 0){
                        ARGB_Color color = 0;
                        if (HasFlag(item->flags, LayoutItemFlag_Special_Character)){
                            color = special_color;
                        }
                        else if (HasFlag(item->flags, LayoutItemFlag_Ghost_Character)){
                            color = ghost_color;
                        }
                        else{
                            color = item_colors[item->index - first_index];
                        }
                        Vec2_f32 p = item->rect.p0 + shift_p;
                        draw_font_glyph(target, face, item->codepoint, p, color, GlyphFlag_None, delta);
                    }
                }
            }
            shift_p.y += line.height;
        }
    }
}

// BOTTOM


// end --- 4ed_text_layout.cpp --- 



// BOTTOM



// end --- 4ed_app_target.cpp --- 



// begin --- 4ed_font_api.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 02.10.2019
 *
 * Font API definition program.
 *
 */

// TOP

function API_Definition*
define_api(Arena *arena){
    API_Definition *api = begin_api(arena, "font");
    
    {
        API_Call *call = api_call(arena, api, "make_face", "Face*");
        api_param(arena, call, "Arena*", "arena");
        api_param(arena, call, "Face_Description*", "description");
        api_param(arena, call, "f32", "scale_factor");
    }
    
    return(api);
}

function Generated_Group
get_api_group(void){
    return(GeneratedGroup_Core);
}

// BOTTOM



// end --- 4ed_font_api.cpp --- 



// begin --- 4ed_font_provider_freetype.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 18.07.2017
 *
 * Freetype implementation of the font provider interface.
 *
 */

// TOP

// NOTE(allen): Thanks to insofaras.  This is copy-pasted from some work he originally did to get free type working on Linux.

#undef internal
#include <ft2build.h>
#include FT_FREETYPE_H
#define internal static

internal u32
ft__load_flags(b32 use_hinting){
    u32 ft_flags = FT_LOAD_RENDER;
    if (use_hinting){
        // NOTE(inso): FT_LOAD_TARGET_LIGHT does hinting only vertically, which looks nicer imo
        // maybe it could be exposed as an option for hinting, instead of just on/off.
        ft_flags |= (FT_LOAD_FORCE_AUTOHINT | FT_LOAD_TARGET_LIGHT);
    }
    else{
        ft_flags |= (FT_LOAD_NO_AUTOHINT | FT_LOAD_NO_HINTING);
    }
    return(ft_flags);
}

internal FT_Codepoint_Index_Pair_Array
ft__get_codepoint_index_pairs(Arena *arena, FT_Face face, u16 *maximum_index_out){
    FT_Long glyph_count = face->num_glyphs;
    
    FT_Codepoint_Index_Pair_Array array = {};
    array.count = glyph_count;
    array.vals = push_array(arena, FT_Codepoint_Index_Pair, glyph_count);
    
    u16 maximum_index = 0;
    
    i32 counter = 0;
    FT_UInt index = 0;
    FT_ULong codepoint = FT_Get_First_Char(face, &index);
    array.vals[counter].codepoint = codepoint;
    array.vals[counter].index = (u16)index;
    maximum_index = Max(maximum_index, (u16)index);
    counter += 1;
    for (;;){
        codepoint = FT_Get_Next_Char(face, codepoint, &index);
        array.vals[counter].codepoint = codepoint;
        array.vals[counter].index = (u16)index;
        maximum_index = Max(maximum_index, (u16)index);
        counter += 1;
        if (counter == glyph_count){
            break;
        }
    }
    
    *maximum_index_out = maximum_index;
    
    return(array);
}

internal Codepoint_Index_Map
ft__get_codepoint_index_map(Base_Allocator *base_allocator, FT_Face face){
    FT_Long glyph_count = face->num_glyphs;
    
    Codepoint_Index_Map map = {};
    map.zero_index = max_u16;
    map.table = make_table_u32_u16(base_allocator, glyph_count*4);
    
    u16 maximum_index = 0;
    
    i32 counter = 0;
    FT_UInt index = 0;
    FT_ULong codepoint = FT_Get_First_Char(face, &index);
    table_insert(&map.table, (u32)codepoint, (u16)index);
    maximum_index = Max(maximum_index, (u16)index);
    counter += 1;
    for (;;){
        codepoint = FT_Get_Next_Char(face, codepoint, &index);
        if (codepoint == 0){
            map.has_zero_index = true;
            map.zero_index = (u16)(index);
        }
        else{
            table_insert(&map.table, (u32)codepoint, (u16)index);
        }
        maximum_index = Max(maximum_index, (u16)index);
        counter += 1;
        if (counter == glyph_count){
            break;
        }
    }
    
    map.max_index = maximum_index;
    
    return(map);
}

struct Bad_Rect_Pack{
    Vec2_i32 max_dim;
    Vec3_i32 dim;
    Vec3_i32 p;
    i32 current_line_h;
};

internal void
ft__bad_rect_pack_init(Bad_Rect_Pack *pack, Vec2_i32 max_dim){
    pack->max_dim = max_dim;
    pack->dim = V3i32(0, 0, 1);
    pack->p = V3i32(0, 0, 0);
    pack->current_line_h = 0;
}

internal void
ft__bad_rect_pack_end_line(Bad_Rect_Pack *pack){
    pack->p.y += pack->current_line_h;
    pack->dim.y = Max(pack->dim.y, pack->p.y);
    pack->current_line_h = 0;
    pack->p.x = 0;
}

internal Vec3_i32
ft__bad_rect_pack_next(Bad_Rect_Pack *pack, Vec2_i32 dim){
    Vec3_i32 result = {};
    if (dim.x <= pack->max_dim.x && dim.y <= pack->max_dim.y){
        if (pack->current_line_h < dim.y){
            pack->current_line_h = dim.y;
        }
        if (pack->current_line_h > pack->max_dim.y){
            ft__bad_rect_pack_end_line(pack);
            pack->p.y = 0;
            pack->dim.z += 1;
            pack->p.z += 1;
        }
        else{
            if (pack->p.x + dim.x > pack->max_dim.x){
                ft__bad_rect_pack_end_line(pack);
            }
            result = pack->p;
            pack->p.x += dim.x;
            pack->current_line_h = Max(pack->current_line_h, dim.y);
            pack->dim.x = clamp_bot(pack->dim.x, pack->p.x);
        }
    }
    return(result);
}

internal void
ft__bad_rect_store_finish(Bad_Rect_Pack *pack){
    ft__bad_rect_pack_end_line(pack);
}

internal void
ft__glyph_bounds_store_uv_raw(Vec3_i32 p, Vec2_i32 dim, Glyph_Bounds *bounds){
    bounds->uv = Rf32((f32)p.x, (f32)p.y, (f32)dim.x, (f32)dim.y);
    bounds->w = (f32)p.z;
}

internal Face*
ft__font_make_face(Arena *arena, Face_Description *description, f32 scale_factor){
    String_Const_u8 file_name = push_string_copy(arena, description->font.file_name);
    
    FT_Library ft;
    FT_Init_FreeType(&ft);
    
    FT_Face ft_face;
    FT_Error error = FT_New_Face(ft, (char*)file_name.str, 0, &ft_face);
    
    Face *face = 0;
    if (error == 0){
        face = push_array_zero(arena, Face, 1);
        
        u32 pt_size_unscaled = Max(description->parameters.pt_size, 8); 
        u32 pt_size = (u32)(pt_size_unscaled*scale_factor);
        b32 hinting = description->parameters.hinting;
        
        FT_Size_RequestRec_ size = {};
        size.type   = FT_SIZE_REQUEST_TYPE_NOMINAL;
        size.height = (pt_size << 6);
        FT_Request_Size(ft_face, &size);
        
        face->description.font.file_name = file_name;
        face->description.parameters = description->parameters;
        
        Face_Metrics *met = &face->metrics;
        
        met->max_advance = f32_ceil32(ft_face->size->metrics.max_advance/64.f);
        met->ascent      = f32_ceil32(ft_face->size->metrics.ascender/64.f);
        met->descent     = f32_floor32(ft_face->size->metrics.descender/64.f);
        met->text_height = f32_ceil32(ft_face->size->metrics.height/64.f);
        met->line_skip   = met->text_height - (met->ascent - met->descent);
        met->line_skip   = clamp_bot(1.f, met->line_skip);
        met->line_height = met->text_height + met->line_skip;
        
        {
            f32 real_over_notional = met->line_height/(f32)ft_face->height;
            f32 relative_center = -1.f*real_over_notional*ft_face->underline_position;
            f32 relative_thickness = real_over_notional*ft_face->underline_thickness;
            
            f32 center    = f32_floor32(met->ascent + relative_center);
            f32 thickness = clamp_bot(1.f, relative_thickness);
            
            met->underline_yoff1 = center - thickness*0.5f;
            met->underline_yoff2 = center + thickness*0.5f;
        }
        
        face->advance_map.codepoint_to_index =
            ft__get_codepoint_index_map(arena->base_allocator, ft_face);
        u16 index_count =
            codepoint_index_map_count(&face->advance_map.codepoint_to_index);
        face->advance_map.index_count = index_count;
        face->advance_map.advance = push_array_zero(arena, f32, index_count);
        face->bounds = push_array(arena, Glyph_Bounds, index_count);
        
        Temp_Memory_Block temp_memory(arena);
        struct Bitmap{
            Vec2_i32 dim;
            u8 *data;
        };
        Bitmap *glyph_bitmaps = push_array(arena, Bitmap, index_count);
        
        u32 load_flags = ft__load_flags(hinting);
        for (u16 i = 0; i < index_count; i += 1){
            Bitmap *bitmap = &glyph_bitmaps[i];
            
            error = FT_Load_Glyph(ft_face, i, load_flags);
            if (error == 0){
                FT_GlyphSlot ft_glyph = ft_face->glyph;
                Vec2_i32 dim = V2i32(ft_glyph->bitmap.width, ft_glyph->bitmap.rows);
                bitmap->dim = dim;
                bitmap->data = push_array(arena, u8, dim.x*dim.y);
                
                face->bounds[i].xy_off.x0 = (f32)(ft_face->glyph->bitmap_left);
                face->bounds[i].xy_off.y0 = (f32)(met->ascent - ft_face->glyph->bitmap_top);
                face->bounds[i].xy_off.x1 = (f32)(face->bounds[i].xy_off.x0 + dim.x);
                face->bounds[i].xy_off.y1 = (f32)(face->bounds[i].xy_off.y0 + dim.y);
                
                switch (ft_glyph->bitmap.pixel_mode){
                    case FT_PIXEL_MODE_MONO:
                    {
                        NotImplemented;
                    }break;
                    
                    case FT_PIXEL_MODE_GRAY:
                    {
                        b32 aa_1bit_mono = (description->parameters.aa_mode == FaceAntialiasingMode_1BitMono);
                        
                        u8 *src_line = ft_glyph->bitmap.buffer;
                        if (ft_glyph->bitmap.pitch < 0){
                            src_line = ft_glyph->bitmap.buffer + (-ft_glyph->bitmap.pitch)*(dim.y - 1);
                        }
                        u8 *dst = bitmap->data;
                        for (i32 y = 0; y < dim.y; y += 1){
                            u8 *src_pixel = src_line;
                            for (i32 x = 0; x < dim.x; x += 1){
                                if (aa_1bit_mono){
                                    u8 s = *src_pixel;
                                    if (s > 0){
                                        s = 255;
                                    }
                                    *dst = s;
                                }
                                else{
                                    *dst = *src_pixel;
                                }
                                dst += 1;
                                src_pixel += 1;
                            }
                            src_line += ft_glyph->bitmap.pitch;
                        }
                    }break;
                    
                    default:
                    {
                        NotImplemented;
                    }break;
                }
                
                face->advance_map.advance[i] = f32_ceil32(ft_glyph->advance.x/64.0f);
            }
        }
        
        u8 white_data[16] = {
            0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF,
        };
        
        Bitmap white = {};
        white.dim = V2i32(4, 4);
        white.data = white_data;
        
        Bad_Rect_Pack pack = {};
        ft__bad_rect_pack_init(&pack, V2i32(1024, 1024));
        ft__glyph_bounds_store_uv_raw(ft__bad_rect_pack_next(&pack, white.dim), white.dim, &face->white);
        for (u16 i = 0; i < index_count; i += 1){
            Vec2_i32 dim = glyph_bitmaps[i].dim;
            ft__glyph_bounds_store_uv_raw(ft__bad_rect_pack_next(&pack, dim), dim, &face->bounds[i]);
        }
        ft__bad_rect_store_finish(&pack);
        
        Texture_Kind texture_kind = TextureKind_Mono;
        u32 texture = graphics_get_texture(pack.dim, texture_kind);
        face->texture_kind = texture_kind;
        face->texture = texture;
        
        Vec3_f32 texture_dim = V3f32(pack.dim);
        face->texture_dim = texture_dim;
        
        {
            Vec3_i32 p = V3i32((i32)face->white.uv.x0, (i32)face->white.uv.y0, (i32)face->white.w);
            Vec3_i32 dim = V3i32(white.dim.x, white.dim.y, 1);
            graphics_fill_texture(texture_kind, texture, p, dim, white.data);
            face->white.uv.x1 = (face->white.uv.x0 + face->white.uv.x1)/texture_dim.x;
            face->white.uv.y1 = (face->white.uv.y0 + face->white.uv.y1)/texture_dim.y;
            face->white.uv.x0 =  face->white.uv.x0/texture_dim.x;
            face->white.uv.y0 =  face->white.uv.y0/texture_dim.y;
            face->white.w /= texture_dim.z;
        }
        
        for (u16 i = 0; i < index_count; i += 1){
            Vec3_i32 p = V3i32((i32)face->bounds[i].uv.x0, (i32)face->bounds[i].uv.y0, (i32)face->bounds[i].w);
            Vec3_i32 dim = V3i32(glyph_bitmaps[i].dim.x, glyph_bitmaps[i].dim.y, 1);
            graphics_fill_texture(texture_kind, texture, p, dim, glyph_bitmaps[i].data);
            face->bounds[i].uv.x1 = (face->bounds[i].uv.x0 + face->bounds[i].uv.x1)/texture_dim.x;
            face->bounds[i].uv.y1 = (face->bounds[i].uv.y0 + face->bounds[i].uv.y1)/texture_dim.y;
            face->bounds[i].uv.x0 =  face->bounds[i].uv.x0/texture_dim.x;
            face->bounds[i].uv.y0 =  face->bounds[i].uv.y0/texture_dim.y;
            face->bounds[i].w /= texture_dim.z;
        }
        
        {
            Face_Advance_Map *advance_map = &face->advance_map;
            
            met->space_advance = font_get_glyph_advance(advance_map, met, ' ', 0);
            met->decimal_digit_advance =
                font_get_max_glyph_advance_range(advance_map, met, '0', '9', 0);
            met->hex_digit_advance =
                font_get_max_glyph_advance_range(advance_map, met, 'A', 'F', 0);
            met->hex_digit_advance =
                Max(met->hex_digit_advance, met->decimal_digit_advance);
            met->byte_sub_advances[0] =
                font_get_glyph_advance(advance_map, met, '\\', 0);
            met->byte_sub_advances[1] = met->hex_digit_advance;
            met->byte_sub_advances[2] = met->hex_digit_advance;
            met->byte_advance =
                met->byte_sub_advances[0] +
                met->byte_sub_advances[1] +
                met->byte_sub_advances[2];
            met->normal_lowercase_advance =
                font_get_average_glyph_advance_range(advance_map, met, 'a', 'z', 0);
            met->normal_uppercase_advance =
                font_get_average_glyph_advance_range(advance_map, met, 'A', 'Z', 0);
            met->normal_advance = (26*met->normal_lowercase_advance +
                                   26*met->normal_uppercase_advance +
                                   10*met->decimal_digit_advance)/62.f;
        }
    }
    
    FT_Done_FreeType(ft);
    
    return(face);
}

// BOTTOM



// end --- 4ed_font_provider_freetype.cpp --- 



// begin --- 4ed_generate_keycodes.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 09.10.2019
 *
 * Primary list for all key codes.
 *
 */

// TOP

#include <stdio.h>

////////////////////////////////

struct Event_Code{
    Event_Code *next;
    String_Const_u8 name;
};

struct Event_Code_List{
    Event_Code *first;
    Event_Code *last;
    i32 count;
    
    String_Const_u8 code_prefix;
    String_Const_u8 name_table;
};

////////////////////////////////

function void
generate_codes(Arena *scratch, Event_Code_List *list, FILE *out){
    String_Const_u8 code_prefix = list->code_prefix;
    String_Const_u8 name_table = list->name_table;
    
    fprintf(out, "enum{\n");
    i32 counter = 1;
    for (Event_Code *code = list->first;
         code != 0;
         code = code->next){
        fprintf(out, "    %.*s_%.*s = %d,\n",
                string_expand(code_prefix), string_expand(code->name), counter);
        counter += 1;
    }
    fprintf(out, "    %.*s_COUNT = %d,\n", string_expand(code_prefix), counter);
    fprintf(out, "};\n");
    
    fprintf(out, "global char* %.*s[%.*s_COUNT] = {\n",
            string_expand(name_table), string_expand(code_prefix));
    fprintf(out, "    \"None\",\n");
    for (Event_Code *code = list->first;
         code != 0;
         code = code->next){
        fprintf(out, "    \"%.*s\",\n", string_expand(code->name));
        counter += 1;
    }
    fprintf(out, "};\n");
}

////////////////////////////////

function Event_Code*
add_code(Arena *arena, Event_Code_List *list, String_Const_u8 name){
    Event_Code *code = push_array(arena, Event_Code, 1);
    sll_queue_push(list->first, list->last, code);
    list->count;
    code->name = push_string_copy(arena, name);
    return(code);
}

function Event_Code_List
make_key_list(Arena *arena){
    Event_Code_List list = {};
    list.code_prefix = string_u8_litexpr("KeyCode");
    list.name_table = string_u8_litexpr("key_code_name");
    for (u32 i = 'A'; i <= 'Z'; i += 1){
        u8 c = (u8)i;
        add_code(arena, &list, SCu8(&c, 1));
    }
    for (u32 i = '0'; i <= '9'; i += 1){
        u8 c = (u8)i;
        add_code(arena, &list, SCu8(&c, 1));
    }
    add_code(arena, &list, string_u8_litexpr("Space"));
    add_code(arena, &list, string_u8_litexpr("Tick"));
    add_code(arena, &list, string_u8_litexpr("Minus"));
    add_code(arena, &list, string_u8_litexpr("Equal"));
    add_code(arena, &list, string_u8_litexpr("LeftBracket"));
    add_code(arena, &list, string_u8_litexpr("RightBracket"));
    add_code(arena, &list, string_u8_litexpr("Semicolon"));
    add_code(arena, &list, string_u8_litexpr("Quote"));
    add_code(arena, &list, string_u8_litexpr("Comma"));
    add_code(arena, &list, string_u8_litexpr("Period"));
    add_code(arena, &list, string_u8_litexpr("ForwardSlash"));
    add_code(arena, &list, string_u8_litexpr("BackwardSlash"));
    add_code(arena, &list, string_u8_litexpr("Tab"));
    add_code(arena, &list, string_u8_litexpr("Escape"));
    add_code(arena, &list, string_u8_litexpr("Pause"));
    add_code(arena, &list, string_u8_litexpr("Up"));
    add_code(arena, &list, string_u8_litexpr("Down"));
    add_code(arena, &list, string_u8_litexpr("Left"));
    add_code(arena, &list, string_u8_litexpr("Right"));
    add_code(arena, &list, string_u8_litexpr("Backspace"));
    add_code(arena, &list, string_u8_litexpr("Return"));
    add_code(arena, &list, string_u8_litexpr("Delete"));
    add_code(arena, &list, string_u8_litexpr("Insert"));
    add_code(arena, &list, string_u8_litexpr("Home"));
    add_code(arena, &list, string_u8_litexpr("End"));
    add_code(arena, &list, string_u8_litexpr("PageUp"));
    add_code(arena, &list, string_u8_litexpr("PageDown"));
    add_code(arena, &list, string_u8_litexpr("CapsLock"));
    add_code(arena, &list, string_u8_litexpr("NumLock"));
    add_code(arena, &list, string_u8_litexpr("ScrollLock"));
    add_code(arena, &list, string_u8_litexpr("Menu"));
    add_code(arena, &list, string_u8_litexpr("Shift"));
    add_code(arena, &list, string_u8_litexpr("Control"));
    add_code(arena, &list, string_u8_litexpr("Alt"));
    add_code(arena, &list, string_u8_litexpr("Command"));
    for (u32 i = 1; i <= 24; i += 1){
        add_code(arena, &list, push_u8_stringf(arena, "F%d", i));
    }
    for (u32 i = '0'; i <= '9'; i += 1){
        add_code(arena, &list, push_u8_stringf(arena, "NumPad%c", i));
    }
    add_code(arena, &list, string_u8_litexpr("NumPadStar"));
    add_code(arena, &list, string_u8_litexpr("NumPadPlus"));
    add_code(arena, &list, string_u8_litexpr("NumPadMinus"));
    add_code(arena, &list, string_u8_litexpr("NumPadDot"));
    add_code(arena, &list, string_u8_litexpr("NumPadSlash"));
    for (i32 i = 0; i < 30; i += 1){
        add_code(arena, &list, push_u8_stringf(arena, "Ex%d", i));
    }
    return(list);
}

function Event_Code_List
make_mouse_list(Arena *arena){
    Event_Code_List list = {};
    list.code_prefix = string_u8_litexpr("MouseCode");
    list.name_table = string_u8_litexpr("mouse_code_name");
    add_code(arena, &list, string_u8_litexpr("Left"));
    add_code(arena, &list, string_u8_litexpr("Middle"));
    add_code(arena, &list, string_u8_litexpr("Right"));
    return(list);
}

function Event_Code_List
make_core_list(Arena *arena){
    Event_Code_List list = {};
    list.code_prefix = string_u8_litexpr("CoreCode");
    list.name_table = string_u8_litexpr("core_code_name");
    add_code(arena, &list, string_u8_litexpr("Startup"));
    add_code(arena, &list, string_u8_litexpr("Animate"));
    add_code(arena, &list, string_u8_litexpr("ClickActivateView"));
    add_code(arena, &list, string_u8_litexpr("ClickDeactivateView"));
    add_code(arena, &list, string_u8_litexpr("TryExit"));
    add_code(arena, &list, string_u8_litexpr("FileExternallyModified"));
    add_code(arena, &list, string_u8_litexpr("NewClipboardContents"));
    return(list);
}

////////////////////////////////

int
main(void){
    Arena arena = make_arena_malloc();
    
    Event_Code_List key_list = make_key_list(&arena);
    Event_Code_List mouse_list = make_mouse_list(&arena);
    Event_Code_List core_list = make_core_list(&arena);
    
    String_Const_u8 path_to_self = string_u8_litexpr(__FILE__);
    path_to_self = string_remove_last_folder(path_to_self);
    String_Const_u8 file_name =
        push_u8_stringf(&arena, "%.*scustom/generated/4coder_event_codes.h",
                        string_expand(path_to_self));
    
    FILE *out = fopen((char*)file_name.str, "wb");
    if (out == 0){
        printf("could not open output file '%s'\n", file_name.str);
        exit(1);
    }
    
    fprintf(out, "/* Generated by: " __FILE__ );
    fprintf(out, " */\n" );
    
    generate_codes(&arena, &key_list, out);
    generate_codes(&arena, &mouse_list, out);
    generate_codes(&arena, &core_list, out);
    
    fclose(out);
    return(0);
}

// BOTTOM


// end --- 4ed_generate_keycodes.cpp --- 



// begin --- 4ed_graphics_api.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 02.10.2019
 *
 * Graphics API definition program.
 *
 */

// TOP

function API_Definition*
define_api(Arena *arena){
    API_Definition *api = begin_api(arena, "graphics");
    
    {
        API_Call *call = api_call(arena, api, "get_texture", "u32");
        api_param(arena, call, "Vec3_i32", "dim");
        api_param(arena, call, "Texture_Kind", "texture_kind");
    }
    
    {
        API_Call *call = api_call(arena, api, "fill_texture", "b32");
        api_param(arena, call, "Texture_Kind", "texture_kind");
        api_param(arena, call, "u32", "texture");
        api_param(arena, call, "Vec3_i32", "p");
        api_param(arena, call, "Vec3_i32", "dim");
        api_param(arena, call, "void*", "data");
    }
    
    return(api);
}

function Generated_Group
get_api_group(void){
    return(GeneratedGroup_Core);
}

// BOTTOM



// end --- 4ed_graphics_api.cpp --- 



// begin --- 4ed_system_api.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 02.10.2019
 *
 * System API definition program.
 *
 */

// TOP

function API_Definition*
define_api(Arena *arena){
    API_Definition *api = begin_api(arena, "system");
    
    {
        API_Call *call = api_call(arena, api, "error_box", "void");
        api_param(arena, call, "char*", "msg");
    }
    
    {
        API_Call *call = api_call(arena, api, "get_path", "String_Const_u8");
        api_param(arena, call, "Arena*", "arena");
        api_param(arena, call, "System_Path_Code", "path_code");
    }
    
    {
        API_Call *call = api_call(arena, api, "get_canonical", "String_Const_u8");
        api_param(arena, call, "Arena*", "arena");
        api_param(arena, call, "String_Const_u8", "name");
    }
    
    {
        API_Call *call = api_call(arena, api, "get_file_list", "File_List");
        api_param(arena, call, "Arena*", "arena");
        api_param(arena, call, "String_Const_u8", "directory");
    }
    
    {
        API_Call *call = api_call(arena, api, "quick_file_attributes", "File_Attributes");
        api_param(arena, call, "Arena*", "scratch");
        api_param(arena, call, "String_Const_u8", "file_name");
    }
    
    {
        API_Call *call = api_call(arena, api, "load_handle", "b32");
        api_param(arena, call, "Arena*", "scratch");
        api_param(arena, call, "char*", "file_name");
        api_param(arena, call, "Plat_Handle*", "out");
    }
    
    {
        API_Call *call = api_call(arena, api, "load_attributes", "File_Attributes");
        api_param(arena, call, "Plat_Handle", "handle");
    }
    
    {
        API_Call *call = api_call(arena, api, "load_file", "b32");
        api_param(arena, call, "Plat_Handle", "handle");
        api_param(arena, call, "char*", "buffer");
        api_param(arena, call, "u32", "size");
    }
    
    {
        API_Call *call = api_call(arena, api, "load_close", "b32");
        api_param(arena, call, "Plat_Handle", "handle");
    }
    
    {
        API_Call *call = api_call(arena, api, "save_file", "File_Attributes");
        api_param(arena, call, "Arena*", "scratch");
        api_param(arena, call, "char*", "file_name");
        api_param(arena, call, "String_Const_u8", "data");
    }
    
    {
        API_Call *call = api_call(arena, api, "load_library", "b32");
        api_param(arena, call, "Arena*", "scratch");
        api_param(arena, call, "String_Const_u8", "file_name");
        api_param(arena, call, "System_Library*", "out");
    }
    
    {
        API_Call *call = api_call(arena, api, "release_library", "b32");
        api_param(arena, call, "System_Library", "handle");
    }
    
    {
        API_Call *call = api_call(arena, api, "get_proc", "Void_Func*");
        api_param(arena, call, "System_Library", "handle");
        api_param(arena, call, "char*", "proc_name");
    }
    
    {
        api_call(arena, api, "now_time", "u64");
    }
    
    {
        api_call(arena, api, "now_date_time_universal", "Date_Time");
    }
    
    {
        API_Call *call = api_call(arena, api, "local_date_time_from_universal", "Date_Time");
        api_param(arena, call, "Date_Time*", "date_time");
    }
    
    {
        API_Call *call = api_call(arena, api, "universal_date_time_from_local", "Date_Time");
        api_param(arena, call, "Date_Time*", "date_time");
    }
    
    {
        api_call(arena, api, "wake_up_timer_create", "Plat_Handle");
    }
    
    {
        API_Call *call = api_call(arena, api, "wake_up_timer_release", "void");
        api_param(arena, call, "Plat_Handle", "handle");
    }
    
    {
        API_Call *call = api_call(arena, api, "wake_up_timer_set", "void");
        api_param(arena, call, "Plat_Handle", "handle");
        api_param(arena, call, "u32", "time_milliseconds");
    }
    
    {
        API_Call *call = api_call(arena, api, "signal_step", "void");
        api_param(arena, call, "u32", "code");
    }
    
    {
        API_Call *call = api_call(arena, api, "sleep", "void");
        api_param(arena, call, "u64", "microseconds");
    }
    
    {
        API_Call *call = api_call(arena, api, "get_clipboard", "String_Const_u8");
        api_param(arena, call, "Arena*", "arena");
        api_param(arena, call, "i32", "index");
    }
    {
        API_Call *call = api_call(arena, api, "post_clipboard", "void");
        api_param(arena, call, "String_Const_u8", "str");
        api_param(arena, call, "i32", "index");
    }
    
    {
        API_Call *call = api_call(arena, api, "set_clipboard_catch_all", "void");
        api_param(arena, call, "b32", "enabled");
    }
    {
        api_call(arena, api, "get_clipboard_catch_all", "b32");
    }
    
    {
        API_Call *call = api_call(arena, api, "cli_call", "b32");
        api_param(arena, call, "Arena*", "scratch");
        api_param(arena, call, "char*", "path");
        api_param(arena, call, "char*", "script");
        api_param(arena, call, "CLI_Handles*", "cli_out");
    }
    
    {
        API_Call *call = api_call(arena, api, "cli_begin_update", "void");
        api_param(arena, call, "CLI_Handles*", "cli");
    }
    
    {
        API_Call *call = api_call(arena, api, "cli_update_step", "b32");
        api_param(arena, call, "CLI_Handles*", "cli");
        api_param(arena, call, "char*", "dest");
        api_param(arena, call, "u32", "max");
        api_param(arena, call, "u32*", "amount");
    }
    
    {
        API_Call *call = api_call(arena, api, "cli_end_update", "b32");
        api_param(arena, call, "CLI_Handles*", "cli");
    }
    
    {
        API_Call *call = api_call(arena, api, "open_color_picker", "void");
        api_param(arena, call, "Color_Picker*", "picker");
    }
    
    {
        api_call(arena, api, "get_screen_scale_factor", "f32");
    }
    
    {
        API_Call *call = api_call(arena, api, "thread_launch", "System_Thread");
        api_param(arena, call, "Thread_Function*", "proc");
        api_param(arena, call, "void*", "ptr");
    }
    
    {
        API_Call *call = api_call(arena, api, "thread_join", "void");
        api_param(arena, call, "System_Thread", "thread");
    }
    
    {
        API_Call *call = api_call(arena, api, "thread_free", "void");
        api_param(arena, call, "System_Thread", "thread");
    }
    
    {
        api_call(arena, api, "thread_get_id", "i32");
    }
    
    {
        API_Call *call = api_call(arena, api, "acquire_global_frame_mutex", "void");
        api_param(arena, call, "Thread_Context*", "tctx");
    }
    
    {
        API_Call *call = api_call(arena, api, "release_global_frame_mutex", "void");
        api_param(arena, call, "Thread_Context*", "tctx");
    }
    
    {
        api_call(arena, api, "mutex_make", "System_Mutex");
    }
    
    {
        API_Call *call = api_call(arena, api, "mutex_acquire", "void");
        api_param(arena, call, "System_Mutex", "mutex");
    }
    
    {
        API_Call *call = api_call(arena, api, "mutex_release", "void");
        api_param(arena, call, "System_Mutex", "mutex");
    }
    
    {
        API_Call *call = api_call(arena, api, "mutex_free", "void");
        api_param(arena, call, "System_Mutex", "mutex");
    }
    
    {
        api_call(arena, api, "condition_variable_make",
                 "System_Condition_Variable");
    }
    
    {
        API_Call *call = api_call(arena, api, "condition_variable_wait", "void");
        api_param(arena, call, "System_Condition_Variable", "cv");
        api_param(arena, call, "System_Mutex", "mutex");
    }
    
    {
        API_Call *call = api_call(arena, api, "condition_variable_signal", "void");
        api_param(arena, call, "System_Condition_Variable", "cv");
    }
    
    {
        API_Call *call = api_call(arena, api, "condition_variable_free", "void");
        api_param(arena, call, "System_Condition_Variable", "cv");
    }
    
    {
        API_Call *call = api_call(arena, api, "memory_allocate", "void*");
        api_param(arena, call, "u64", "size");
        api_param(arena, call, "String_Const_u8", "location");
    }
    
    {
        API_Call *call = api_call(arena, api, "memory_set_protection", "b32");
        api_param(arena, call, "void*", "ptr");
        api_param(arena, call, "u64", "size");
        api_param(arena, call, "u32", "flags");
    }
    
    {
        API_Call *call = api_call(arena, api, "memory_free", "void");
        api_param(arena, call, "void*", "ptr");
        api_param(arena, call, "u64", "size");
    }
    
    {
        API_Call *call = api_call(arena, api, "memory_annotation", "Memory_Annotation");
        api_param(arena, call, "Arena*", "arena");
    }
    
    {
        API_Call *call = api_call(arena, api, "show_mouse_cursor", "void");
        api_param(arena, call, "i32", "show");
    }
    
    {
        API_Call *call = api_call(arena, api, "set_fullscreen", "b32");
        api_param(arena, call, "b32", "full_screen");
    }
    
    {
        api_call(arena, api, "is_fullscreen", "b32");
    }
    
    {
        API_Call *call = api_call(arena, api, "get_keyboard_modifiers", "Input_Modifier_Set");
        api_param(arena, call, "Arena*", "arena");
    }
    
    {
        API_Call *call = api_call(arena, api, "set_key_mode", "void");
        api_param(arena, call, "Key_Mode", "mode");
    }
    
    {
        API_Call *call = api_call(arena, api, "set_source_mixer", "void");
        api_param(arena, call, "void*", "ctx");
        api_param(arena, call, "Audio_Mix_Sources_Function*", "mix_func");
    }
    
    {
        API_Call *call = api_call(arena, api, "set_destination_mixer", "void");
        api_param(arena, call, "Audio_Mix_Destination_Function*", "mix_func");
    }
    
    return(api);
}

function Generated_Group
get_api_group(void){
    return(GeneratedGroup_Custom);
}

// BOTTOM



// end --- 4ed_system_api.cpp --- 



// begin --- font_api.cpp --- 

function void
font_api_fill_vtable(API_VTable_font *vtable){
vtable->make_face = font_make_face;
}
#if defined(DYNAMIC_LINK_API)
function void
font_api_read_vtable(API_VTable_font *vtable){
font_make_face = vtable->make_face;
}
#undef DYNAMIC_LINK_API
#endif


// end --- font_api.cpp --- 



// begin --- graphics_api.cpp --- 

function void
graphics_api_fill_vtable(API_VTable_graphics *vtable){
vtable->get_texture = graphics_get_texture;
vtable->fill_texture = graphics_fill_texture;
}
#if defined(DYNAMIC_LINK_API)
function void
graphics_api_read_vtable(API_VTable_graphics *vtable){
graphics_get_texture = vtable->get_texture;
graphics_fill_texture = vtable->fill_texture;
}
#undef DYNAMIC_LINK_API
#endif


// end --- graphics_api.cpp --- 



// begin --- 4ed_opengl_render.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 10.11.2017
 *
 * OpenGL render implementation
 *
 */

// TOP

internal void
gl__bind_texture(Render_Target *t, i32 texid){
    if (t->bound_texture != texid){
        glBindTexture(GL_TEXTURE_2D_ARRAY, texid);
        t->bound_texture = texid;
    }
}

internal void
gl__bind_any_texture(Render_Target *t){
    if (t->bound_texture == 0){
        Assert(t->fallback_texture_id != 0);
        glBindTexture(GL_TEXTURE_2D_ARRAY, t->fallback_texture_id);
        t->bound_texture = t->fallback_texture_id;
    }
}

internal u32
gl__get_texture(Vec3_i32 dim, Texture_Kind texture_kind){
    u32 tex = 0;
    glGenTextures(1, &tex);
    glBindTexture(GL_TEXTURE_2D_ARRAY, tex);
    glTexImage3D(GL_TEXTURE_2D_ARRAY, 0, GL_R8, dim.x, dim.y, dim.z, 0, GL_RED, GL_UNSIGNED_BYTE, 0);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAX_LEVEL, 0);
    return(tex);
}

internal b32
gl__fill_texture(Texture_Kind texture_kind, u32 texture, Vec3_i32 p, Vec3_i32 dim, void *data){
    b32 result = false;
    if (texture != 0){
        glBindTexture(GL_TEXTURE_2D_ARRAY, texture);
    }
    if (dim.x > 0 && dim.y > 0 && dim.z > 0){
        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
        glTexSubImage3D(GL_TEXTURE_2D_ARRAY, 0, p.x, p.y, p.z, dim.x, dim.y, dim.z, GL_RED, GL_UNSIGNED_BYTE, data);
    }
    return(result);
}

internal void
gl__error_callback(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const char *message, const void *userParam){
    switch (id){
        case 131218:
        {
            // NOTE(allen): performance warning, do nothing.
        }break;
        
        default:
        {
            InvalidPath;
        }break;
    }
}

char *gl__header = R"foo(#version 130
        )foo";

char *gl__vertex = R"foo(
        uniform vec2 view_t;
        uniform mat2x2 view_m;
        in vec2 vertex_p;
        in vec3 vertex_t;
        in uint vertex_c;
        in float vertex_ht;
        smooth out vec4 fragment_color;
        smooth out vec3 uvw;
        smooth out vec2 xy;
        smooth out vec2 adjusted_half_dim;
        smooth out float half_thickness;
        void main(void)
        {
        gl_Position = vec4(view_m*(vertex_p - view_t), 0.0, 1.0);
         fragment_color.b = (float((vertex_c     )&0xFFu))/255.0;
        fragment_color.g = (float((vertex_c>> 8u)&0xFFu))/255.0;
        fragment_color.r = (float((vertex_c>>16u)&0xFFu))/255.0;
        fragment_color.a = (float((vertex_c>>24u)&0xFFu))/255.0;
        uvw = vertex_t;
        vec2 center = vertex_t.xy;
        vec2 half_dim = abs(vertex_p - center);
        adjusted_half_dim = half_dim - vertex_t.zz + vec2(0.5, 0.5);
        half_thickness = vertex_ht;
        xy = vertex_p;
        }
        )foo";

char *gl__fragment = R"foo(
        smooth in vec4 fragment_color;
        smooth in vec3 uvw;
        smooth in vec2 xy;
        smooth in vec2 adjusted_half_dim;
        smooth in float half_thickness;
        uniform sampler2DArray sampler;
        out vec4 out_color;
        
        float rectangle_sd(vec2 p, vec2 b){
        vec2 d = abs(p) - b;
        return(length(max(d, vec2(0.0, 0.0))) + min(max(d.x, d.y), 0.0));
        }
        
        void main(void)
        {
        float has_thickness = (step(0.49, half_thickness));
        float does_not_have_thickness = 1.0 - has_thickness;
        
        float sample_value = texture(sampler, uvw).r;
        sample_value *= does_not_have_thickness;
        
        vec2 center = uvw.xy;
        float roundness = uvw.z;
        float sd = rectangle_sd(xy - center, adjusted_half_dim);
        sd = sd - roundness;
        sd = abs(sd + half_thickness) - half_thickness;
        float shape_value = 1.0 - smoothstep(-1.0, 0.0, sd);
        shape_value *= has_thickness;
        
        out_color = vec4(fragment_color.xyz, fragment_color.a*(sample_value + shape_value));
        }
        )foo";

#define AttributeList(X) \
X(vertex_p) \
X(vertex_t) \
X(vertex_c) \
X(vertex_ht)

#define UniformList(X) \
X(view_t) \
X(view_m) \
X(sampler)

struct GL_Program{
    u32 program;
#define GetAttributeLocation(N) i32 N;
    AttributeList(GetAttributeLocation)
#undef GetAttributeLocation
#define GetUniformLocation(N) i32 N;
    UniformList(GetUniformLocation)
#undef GetUniformLocation
};

internal GL_Program
gl__make_program(char *header, char *vertex, char *fragment){
    if (header == 0){
        header = "";
    }
    
    GLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);
    GLchar *vertex_source_array[] = { header, vertex };
    glShaderSource(vertex_shader, ArrayCount(vertex_source_array), vertex_source_array, 0);
    glCompileShader(vertex_shader);
    
    GLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
    GLchar *fragment_source_array[] = { header, fragment };
    glShaderSource(fragment_shader, ArrayCount(fragment_source_array), fragment_source_array, 0);
    glCompileShader(fragment_shader);
    
    GLuint program = glCreateProgram();
    glAttachShader(program, vertex_shader);
    glAttachShader(program, fragment_shader);
    glLinkProgram(program);
    glValidateProgram(program);
    
    GLint success = false;
    glGetProgramiv(program, GL_LINK_STATUS, &success);
    if (!success){
        GLsizei ignore = 0;
        char vertex_errors[KB(4)];
        char fragment_errors[KB(4)];
        char program_errors[KB(4)];
        glGetShaderInfoLog(vertex_shader, sizeof(vertex_errors), &ignore, vertex_errors);
        glGetShaderInfoLog(fragment_shader, sizeof(fragment_errors), &ignore, fragment_errors);
        glGetProgramInfoLog(program, sizeof(program_errors), &ignore, program_errors);
#if SHIP_MODE
        os_popup_error("Error", "Shader compilation failed.");
#endif
        InvalidPath;
    }
    
    glDeleteShader(vertex_shader);
    glDeleteShader(fragment_shader);
    
    GL_Program result = {};
    result.program = program;
#define GetAttributeLocation(N) result.N = glGetAttribLocation(program, #N);
    AttributeList(GetAttributeLocation)
#undef GetAttributeLocation
#define GetUniformLocation(N) result.N = glGetUniformLocation(program, #N);
    UniformList(GetUniformLocation)
#undef GetUniformLocation
    return(result);
}

#define GLOffsetStruct(p,m) ((void*)(OffsetOfMemberStruct(p,m)))
#define GLOffset(S,m) ((void*)(OffsetOfMember(S,m)))

internal void
gl_render(Render_Target *t){
    Font_Set *font_set = (Font_Set*)t->font_set;
    
    local_persist b32 first_opengl_call = true;
    local_persist u32 attribute_buffer = 0;
    local_persist GL_Program gpu_program = {};
    
    if (first_opengl_call){
        first_opengl_call = false;
        
#if !SHIP_MODE
        glEnable(GL_DEBUG_OUTPUT);
        glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
        if (glDebugMessageControl){
            glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DEBUG_SEVERITY_NOTIFICATION, 0, 0, false);
            glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DEBUG_SEVERITY_LOW, 0, 0, false);
            glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DEBUG_SEVERITY_MEDIUM, 0, 0, true);
            glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DEBUG_SEVERITY_HIGH, 0, 0, true);
        }
        
        if (glDebugMessageCallback){
            glDebugMessageCallback(gl__error_callback, 0);
        }
#endif
        
        ////////////////////////////////
        
        GLuint dummy_vao = 0;
        glGenVertexArrays(1, &dummy_vao);
        glBindVertexArray(dummy_vao);
        
        ////////////////////////////////
        
        glGenBuffers(1, &attribute_buffer);
        glBindBuffer(GL_ARRAY_BUFFER, attribute_buffer);
        
        ////////////////////////////////
        
        glEnable(GL_SCISSOR_TEST);
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        
        ////////////////////////////////
        
        gpu_program = gl__make_program(gl__header, gl__vertex, gl__fragment);
        glUseProgram(gpu_program.program);
        
        ////////////////////////////////
        
        {
            t->fallback_texture_id = gl__get_texture(V3i32(2, 2, 1), TextureKind_Mono);
            u8 white_block[] = { 0xFF, 0xFF, 0xFF, 0xFF, };
            gl__fill_texture(TextureKind_Mono, 0, V3i32(0, 0, 0), V3i32(2, 2, 1), white_block);
        }
    }
    
    i32 width = t->width;
    i32 height = t->height;
    
    glViewport(0, 0, width, height);
    glScissor(0, 0, width, height);
    glClearColor(1.f, 0.f, 1.f, 1.f);
    glClear(GL_COLOR_BUFFER_BIT);
    
    glBindTexture(GL_TEXTURE_2D, 0);
    t->bound_texture = 0;
    
    for (Render_Free_Texture *free_texture = t->free_texture_first;
         free_texture != 0;
         free_texture = free_texture->next){
        glDeleteTextures(1, &free_texture->tex_id);
    }
    t->free_texture_first = 0;
    t->free_texture_last = 0;
    
    for (Render_Group *group = t->group_first;
         group != 0;
         group = group->next){
        Rect_i32 box = Ri32(group->clip_box);
        
        Rect_i32 scissor_box = {
            box.x0, height - box.y1, box.x1 - box.x0, box.y1 - box.y0,
        };
        scissor_box.x0 = clamp_bot(0, scissor_box.x0);
        scissor_box.y0 = clamp_bot(0, scissor_box.y0);
        scissor_box.x1 = clamp_bot(0, scissor_box.x1);
        scissor_box.y1 = clamp_bot(0, scissor_box.y1);
        glScissor(scissor_box.x0, scissor_box.y0, scissor_box.x1, scissor_box.y1);
        
        i32 vertex_count = group->vertex_list.vertex_count;
        if (vertex_count > 0){
            Face *face = font_set_face_from_id(font_set, group->face_id);
            if (face != 0){
                gl__bind_texture(t, face->texture);
            }
            else{
                gl__bind_any_texture(t);
            }
            
            glBufferData(GL_ARRAY_BUFFER, vertex_count*sizeof(Render_Vertex), 0, GL_STREAM_DRAW);
            i32 cursor = 0;
            for (Render_Vertex_Array_Node *node = group->vertex_list.first;
                 node != 0;
                 node = node->next){
                i32 size = node->vertex_count*sizeof(*node->vertices);
                glBufferSubData(GL_ARRAY_BUFFER, cursor, size, node->vertices);
                cursor += size;
            }
            
            glEnableVertexAttribArray(gpu_program.vertex_p);
            glEnableVertexAttribArray(gpu_program.vertex_t);
            glEnableVertexAttribArray(gpu_program.vertex_c);
            glEnableVertexAttribArray(gpu_program.vertex_ht);
            
            glVertexAttribPointer(gpu_program.vertex_p, 2, GL_FLOAT, true, sizeof(Render_Vertex),
                                  GLOffset(Render_Vertex, xy));
            glVertexAttribPointer(gpu_program.vertex_t, 3, GL_FLOAT, true, sizeof(Render_Vertex),
                                  GLOffset(Render_Vertex, uvw));
            glVertexAttribIPointer(gpu_program.vertex_c, 1, GL_UNSIGNED_INT, sizeof(Render_Vertex),
                                   GLOffset(Render_Vertex, color));
            glVertexAttribPointer(gpu_program.vertex_ht, 1, GL_FLOAT, true, sizeof(Render_Vertex),
                                  GLOffset(Render_Vertex, half_thickness));
            
            glUniform2f(gpu_program.view_t, width/2.f, height/2.f);
            f32 m[4] = {
                2.f/width, 0.f,
                0.f, -2.f/height,
            };
            glUniformMatrix2fv(gpu_program.view_m, 1, GL_FALSE, m);
            glUniform1i(gpu_program.sampler, 0);
            
            glDrawArrays(GL_TRIANGLES, 0, vertex_count);
            glDisableVertexAttribArray(gpu_program.vertex_p);
            glDisableVertexAttribArray(gpu_program.vertex_t);
            glDisableVertexAttribArray(gpu_program.vertex_c);
            glDisableVertexAttribArray(gpu_program.vertex_ht);
        }
    }
    
    glFlush();
}

// BOTTOM



// end --- 4ed_opengl_render.cpp --- 



// begin --- linux_4ed.cpp --- 

/*
 * chr  - Andrew Chronister &
 * inso - Alex Baines
 *
 * 12.19.2019
 *
 * Updated linux layer for 4coder
 *
 */

// TOP

#include <stdio.h>

#define FPS 60
#define frame_useconds (Million(1) / FPS)
#define frame_nseconds (Billion(1) / FPS)
#define SLASH '/'
#define DLL "so"

#define STATIC_LINK_API

#define STATIC_LINK_API

#define STATIC_LINK_API

// begin --- 4ed_font_provider_freetype.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 16.11.2017
 *
 * Data types for the freetype font provider.
 *
 */

// TOP

#if !defined(FCODER_FONT_PROVIDER_FREETYPE_H)
#define FCODER_FONT_PROVIDER_FREETYPE_H

struct FT_Codepoint_Index_Pair{
    u32 codepoint;
    u16 index;
};

struct FT_Codepoint_Index_Pair_Array{
    FT_Codepoint_Index_Pair *vals;
    i32 count;
};

#endif

// BOTTOM



// end --- 4ed_font_provider_freetype.h --- 



#include <dirent.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <errno.h>
#include <pthread.h>

#include <sys/epoll.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/timerfd.h>
#include <sys/eventfd.h>
#include <sys/syscall.h>

#define Cursor XCursor
#undef function
#undef internal
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/cursorfont.h>
#include <X11/Xatom.h>
#include <X11/extensions/Xfixes.h>
#include <X11/XKBlib.h>
#include <X11/keysym.h>
#define function static
#undef Cursor

//#include <fontconfig/fontconfig.h>
#define internal static

#include <GL/glx.h>
#include <GL/glext.h>

#ifdef INSO_DEBUG
#define LINUX_FN_DEBUG(fmt, ...) do { \
fprintf(stderr, "%s: " fmt "\n", __func__, ##__VA_ARGS__);\
} while (0)

// I want to see a message
#undef AssertBreak
#define AssertBreak(m) ({\
fprintf(stderr, "\n** ASSERTION FAILURE: %s:%d: %s\n\n", __FILE__, __LINE__, #m);\
*((volatile u64*)0) = 0xba771e70ad5;\
})
#else
#define LINUX_FN_DEBUG(...)
#endif

////////////////////////////////

global b32 log_os_enabled = false;
#define log_os(...) \
Stmnt( if (log_os_enabled){ fprintf(stdout, __VA_ARGS__); fflush(stdout); } )

////////////////////////////

struct Linux_Input_Chunk_Transient {
    Input_List event_list;
    b8 mouse_l_press;
    b8 mouse_l_release;
    b8 mouse_r_press;
    b8 mouse_r_release;
    i8 mouse_wheel;
    b8 trying_to_kill;
};

struct Linux_Input_Chunk_Persistent {
    Vec2_i32 mouse;
    Input_Modifier_Set_Fixed modifiers;
    b8 mouse_l;
    b8 mouse_r;
    b8 mouse_out_of_window;
};

struct Linux_Input_Chunk {
    Linux_Input_Chunk_Transient trans;
    Linux_Input_Chunk_Persistent pers;
};

struct Linux_Memory_Tracker_Node {
    Linux_Memory_Tracker_Node* prev;
    Linux_Memory_Tracker_Node* next;
    String_Const_u8 location;
    u64 size;
};

struct Linux_Vars {
    Thread_Context tctx;
    Arena frame_arena;
    
    Display* dpy;
    Window win;
    
    b32 has_xfixes;
    int xfixes_selection_event;
    XIM xim;
    XIC xic;
    //FcConfig* fontconfig;
    XkbDescPtr xkb;
    
    Linux_Input_Chunk input;
    int xkb_event;
    int xkb_group; // active keyboard layout (0-3)
    KeyCode prev_filtered_key;
    
    Key_Mode key_mode;
    
    int epoll;
    int step_timer_fd;
    u64 last_step_time;
    
    XCursor xcursors[APP_MOUSE_CURSOR_COUNT];
    Application_Mouse_Cursor cursor;
    XCursor hidden_cursor;
    i32 cursor_show;
    i32 prev_cursor_show;
    
    Node free_linux_objects;
    Node timer_objects;
    
    System_Mutex global_frame_mutex;
    pthread_mutex_t memory_tracker_mutex;
    Linux_Memory_Tracker_Node* memory_tracker_head;
    Linux_Memory_Tracker_Node* memory_tracker_tail;
    int memory_tracker_count;
    
    Arena clipboard_arena;
    String_Const_u8 clipboard_contents;
    b32 received_new_clipboard;
    b32 clipboard_catch_all;
    
    pthread_mutex_t audio_mutex;
    pthread_cond_t audio_cond;
    void* audio_ctx;
    Audio_Mix_Sources_Function* audio_src_func;
    Audio_Mix_Destination_Function* audio_dst_func;
    System_Thread audio_thread;
    
    Atom atom_TARGETS;
    Atom atom_CLIPBOARD;
    Atom atom_UTF8_STRING;
    Atom atom__NET_WM_STATE;
    Atom atom__NET_WM_STATE_MAXIMIZED_HORZ;
    Atom atom__NET_WM_STATE_MAXIMIZED_VERT;
    Atom atom__NET_WM_STATE_FULLSCREEN;
    Atom atom__NET_WM_PING;
    Atom atom__NET_WM_WINDOW_TYPE;
    Atom atom__NET_WM_WINDOW_TYPE_NORMAL;
    Atom atom__NET_WM_PID;
    Atom atom_WM_DELETE_WINDOW;
    
    Log_Function *log_string;
};

global Linux_Vars linuxvars;
global Render_Target render_target;

////////////////////////////

// Defererencing an epoll_event's .data.ptr will always give one of these event types.

typedef i32 Epoll_Kind;
enum {
    EPOLL_STEP_TIMER,
    EPOLL_X11,
    EPOLL_X11_INTERNAL,
    EPOLL_CLI_PIPE,
    EPOLL_USER_TIMER,
};

// Where per-event epoll data is not needed, .data.ptr will point to one of
// these static vars below.
// If per-event data is needed, container_of can be used on data.ptr
// to access the containing struct and all its other members.

internal Epoll_Kind epoll_tag_step_timer = EPOLL_STEP_TIMER;
internal Epoll_Kind epoll_tag_x11 = EPOLL_X11;
internal Epoll_Kind epoll_tag_x11_internal = EPOLL_X11_INTERNAL;
internal Epoll_Kind epoll_tag_cli_pipe = EPOLL_CLI_PIPE;

////////////////////////////

typedef i32 Linux_Object_Kind;
enum {
    LinuxObjectKind_ERROR = 0,
    LinuxObjectKind_Timer = 1,
    LinuxObjectKind_Thread = 2,
    LinuxObjectKind_Mutex = 3,
    LinuxObjectKind_ConditionVariable = 4,
};

struct Linux_Object {
    Linux_Object_Kind kind;
    Node node;
    union {
        struct {
            int fd;
            Epoll_Kind epoll_tag;
        } timer;
        struct {
            pthread_t pthread;
            Thread_Function* proc;
            void* ptr;
        } thread;
        pthread_mutex_t mutex;
        pthread_cond_t condition_variable;
    };
};

Linux_Object*
handle_to_object(Plat_Handle ph){
    return *(Linux_Object**)&ph;
}

Plat_Handle
object_to_handle(Linux_Object* obj) {
    return *(Plat_Handle*)&obj;
}

internal Linux_Object*
linux_alloc_object(Linux_Object_Kind kind){
    Linux_Object* result = NULL;
    
    if (linuxvars.free_linux_objects.next != &linuxvars.free_linux_objects) {
        result = CastFromMember(Linux_Object, node, linuxvars.free_linux_objects.next);
    }
    
    if (result == NULL) {
        i32 count = 512;
        
        Linux_Object* objects = (Linux_Object*)system_memory_allocate(
                                                                      sizeof(Linux_Object) * count,
                                                                      file_name_line_number_lit_u8
                                                                      );
        
        objects[0].node.prev = &linuxvars.free_linux_objects;
        linuxvars.free_linux_objects.next = &objects[0].node;
        for (i32 i = 1; i < count; ++i) {
            objects[i - 1].node.next = &objects[i].node;
            objects[i].node.prev = &objects[i - 1].node;
        }
        objects[count - 1].node.next = &linuxvars.free_linux_objects;
        linuxvars.free_linux_objects.prev = &objects[count - 1].node;
        
        result = CastFromMember(Linux_Object, node, linuxvars.free_linux_objects.next);
    }
    
    Assert(result != 0);
    dll_remove(&result->node);
    block_zero_struct(result);
    result->kind = kind;
    return result;
}

internal void
linux_free_object(Linux_Object *object){
    if (object->node.next != 0){
        dll_remove(&object->node);
    }
    dll_insert(&linuxvars.free_linux_objects, &object->node);
}

////////////////////////////

internal int
linux_compare_file_infos(File_Info** a, File_Info** b) {
    b32 a_hidden = (*a)->file_name.str[0] == '.';
    b32 b_hidden = (*b)->file_name.str[0] == '.';
    
    // hidden files lower in list
    if(a_hidden != b_hidden) {
        return a_hidden - b_hidden;
    }
    
    // push_stringf seems to null terminate
    return strcoll((char*)(*a)->file_name.str, (char*)(*b)->file_name.str);
}

internal int
linux_system_get_file_list_filter(const struct dirent *dirent) {
    String_Const_u8 file_name = SCu8((u8*)dirent->d_name);
    if (string_match(file_name, string_u8_litexpr("."))) {
        return 0;
    }
    else if (string_match(file_name, string_u8_litexpr(".."))) {
        return 0;
    }
    return 1;
}

internal u64
linux_us_from_timespec(const struct timespec timespec) {
    return timespec.tv_nsec/Thousand(1) + Million(1) * timespec.tv_sec;
}

internal File_Attribute_Flag
linux_convert_file_attribute_flags(int mode) {
    File_Attribute_Flag result = {};
    MovFlag(mode, S_IFDIR, result, FileAttribute_IsDirectory);
    return result;
}

internal File_Attributes
linux_file_attributes_from_struct_stat(struct stat* file_stat) {
    File_Attributes result = {};
    result.size = file_stat->st_size;
    result.last_write_time = linux_us_from_timespec(file_stat->st_mtim);
    result.flags = linux_convert_file_attribute_flags(file_stat->st_mode);
    return(result);
}

internal void
linux_schedule_step(){
    u64 now  = system_now_time();
    u64 diff = (now - linuxvars.last_step_time);
    
    struct itimerspec its = {};
    timerfd_gettime(linuxvars.step_timer_fd, &its);
    
    if (diff > frame_useconds) {
        its.it_value.tv_nsec = 1;
        timerfd_settime(linuxvars.step_timer_fd, 0, &its, NULL);
    } else {
        if (its.it_value.tv_sec == 0 && its.it_value.tv_nsec == 0){
            its.it_value.tv_nsec = (frame_useconds - diff) * 1000UL;
            timerfd_settime(linuxvars.step_timer_fd, 0, &its, NULL);
        }
    }
}

enum wm_state_mode {
    WM_STATE_DEL = 0,
    WM_STATE_ADD = 1,
    WM_STATE_TOGGLE = 2,
};

internal void
linux_set_wm_state(Atom one, Atom two, enum wm_state_mode mode){
    //NOTE(inso): this will only work after the window has been mapped
    
    XEvent e = {};
    e.xany.type = ClientMessage;
    e.xclient.message_type = linuxvars.atom__NET_WM_STATE;
    e.xclient.format = 32;
    e.xclient.window = linuxvars.win;
    e.xclient.data.l[0] = mode;
    e.xclient.data.l[1] = one;
    e.xclient.data.l[2] = two;
    e.xclient.data.l[3] = 1L;
    
    XSendEvent(linuxvars.dpy,
               RootWindow(linuxvars.dpy, 0),
               0, SubstructureNotifyMask | SubstructureRedirectMask, &e);
}

internal void
linux_window_maximize(enum wm_state_mode mode){
    linux_set_wm_state(linuxvars.atom__NET_WM_STATE_MAXIMIZED_HORZ, linuxvars.atom__NET_WM_STATE_MAXIMIZED_VERT, mode);
}

internal void
linux_window_fullscreen(enum wm_state_mode mode) {
    linux_set_wm_state(linuxvars.atom__NET_WM_STATE_FULLSCREEN, 0, mode);
}

internal int
linux_get_xsettings_dpi(Display* dpy, int screen){
    struct XSettingHeader {
        u8 type;
        u8 pad0;
        u16 name_len;
        char name[0];
    };
    
    struct XSettings {
        u8 byte_order;
        u8 pad[3];
        u32 serial;
        u32 num_settings;
    };
    
    enum { XSettingsTypeInt, XSettingsTypeString, XSettingsTypeColor };
    
    int dpi = -1;
    unsigned char* prop = NULL;
    char sel_buffer[64];
    struct XSettings* xs;
    const char* p;
    
    snprintf(sel_buffer, sizeof(sel_buffer), "_XSETTINGS_S%d", screen);
    
    Atom XSET_SEL = XInternAtom(dpy, sel_buffer, True);
    Atom XSET_SET = XInternAtom(dpy, "_XSETTINGS_SETTINGS", True);
    
    if (XSET_SEL == None || XSET_SET == None){
        //LOG("XSETTINGS unavailable.\n");
        return(dpi);
    }
    
    Window xset_win = XGetSelectionOwner(dpy, XSET_SEL);
    if (xset_win == None){
        // TODO(inso): listen for the ClientMessage about it becoming available?
        //             there's not much point atm if DPI scaling is only done at startup
        goto out;
    }
    
    {
        Atom type;
        int fmt;
        unsigned long pad, num;
        
        if (XGetWindowProperty(dpy, xset_win, XSET_SET, 0, 1024, False, XSET_SET, &type, &fmt, &num, &pad, &prop) != Success){
            //LOG("XSETTINGS: GetWindowProperty failed.\n");
            goto out;
        }
        
        if (fmt != 8){
            //LOG("XSETTINGS: Wrong format.\n");
            goto out;
        }
    }
    
    xs = (struct XSettings*)prop;
    p  = (char*)(xs + 1);
    
    if (xs->byte_order != 0){
        //LOG("FIXME: XSETTINGS not host byte order?\n");
        goto out;
    }
    
    for (int i = 0; i < xs->num_settings; ++i){
        struct XSettingHeader* h = (struct XSettingHeader*)p;
        
        p += sizeof(struct XSettingHeader);
        p += h->name_len;
        p += ((4 - (h->name_len & 3)) & 3);
        p += 4; // serial
        
        switch (h->type){
            case XSettingsTypeInt: {
                if (strncmp(h->name, "Xft/DPI", h->name_len) == 0){
                    dpi = *(i32*)p;
                    if (dpi != -1) dpi /= 1024;
                }
                p += 4;
            } break;
            
            case XSettingsTypeString: {
                u32 len = *(u32*)p;
                p += 4;
                p += len;
                p += ((4 - (len & 3)) & 3);
            } break;
            
            case XSettingsTypeColor: {
                p += 8;
            } break;
            
            default: {
                //LOG("XSETTINGS: Got invalid type...\n");
                goto out;
            } break;
        }
    }
    
    out:
    if (prop){
        XFree(prop);
    }
    
    return dpi;
}

internal void*
linux_thread_proc_start(void* arg) {
    Linux_Object* info = (Linux_Object*)arg;
    Assert(info->kind == LinuxObjectKind_Thread);
    info->thread.proc(info->thread.ptr);
    return NULL;
}

// begin --- linux_icon.h --- 

/* Generated by gen_linux_icon.c */
static const unsigned long linux_icon[] = {
    48, 48,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x7c26d726,
    0xd226d726, 0xd126d726, 0xd126d726, 0xd126d726, 0xd126d726, 0xd126d726,
    0xd126d726, 0xdb26d726, 0x3a26d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x2d26d726, 0xf426d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x4926d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xc026d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x4826d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x7726d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x4826d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x3326d726, 0xf626d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x4826d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x0626d726, 0xb726d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x4826d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x5f26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x4826d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x1726d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x4826d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0126d726,
    0xc226d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0x6b26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x4826d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x5926d726,
    0xfe26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0x8a26d726,
    0x2426d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x4826d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0626d726, 0xef26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xdd26d726, 0x1826d726,
    0x2a26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x4826d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xb126d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0x6126d726, 0x00000000,
    0x2a26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x4826d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x6226d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xa626d726, 0x00000000, 0x00000000,
    0x2a26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x4826d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x1926d726, 0xdd26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xed26d726, 0x0826d726, 0x00000000, 0x00000000,
    0x2a26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x4826d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x9626d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xfd26d726, 0x6126d726, 0x00000000, 0x00000000, 0x00000000,
    0x2a26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x4826d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x4c26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xca26d726, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x2a26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x4f26d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x1226d726, 0xee26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xfe26d726, 0x1426d726, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x2a26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x5026d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x9026d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0x5e26d726, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x2a26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x5026d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x2926d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xbf26d726,
    0x0926d726, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x2a26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x5026d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0226d726, 0xe326d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xfb26d726, 0x3626d726,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x2a26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x5026d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x9926d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0x7426d726, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x2a26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x5026d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x3626d726, 0xf426d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xc726d726, 0x00000000, 0x0126d726,
    0x0126d726, 0x0126d726, 0x0126d726, 0x0126d726, 0x0126d726, 0x00000000,
    0x2b26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x5126d726, 0x00000000, 0x0126d726, 0x0126d726,
    0x0126d726, 0x0126d726, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x6926d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xbf26d726, 0xa126d726, 0xa126d726,
    0xa126d726, 0xa126d726, 0xa126d726, 0xa126d726, 0xa126d726, 0xa026d726,
    0xb126d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xbf26d726, 0x9f26d726, 0xa126d726, 0xa126d726,
    0xa426d726, 0x7626d726, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x6626d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xbe26d726, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x6626d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xbb26d726, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x6626d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xbb26d726, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x6626d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xbb26d726, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x5e26d726, 0xf226d726, 0xec26d726,
    0xec26d726, 0xec26d726, 0xec26d726, 0xec26d726, 0xec26d726, 0xec26d726,
    0xec26d726, 0xec26d726, 0xec26d726, 0xec26d726, 0xec26d726, 0xec26d726,
    0xef26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0xf226d726, 0xec26d726, 0xec26d726, 0xec26d726,
    0xf126d726, 0xad26d726, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x1126d726, 0x2e26d726, 0x2d26d726,
    0x2d26d726, 0x2d26d726, 0x2d26d726, 0x2d26d726, 0x2d26d726, 0x2d26d726,
    0x2d26d726, 0x2d26d726, 0x2d26d726, 0x2d26d726, 0x2d26d726, 0x2b26d726,
    0x5026d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x6f26d726, 0x2826d726, 0x2d26d726, 0x2d26d726,
    0x2e26d726, 0x2126d726, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x2a26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x5026d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x2a26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x5026d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x2a26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x5026d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x2a26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x5026d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x2a26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x5026d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x2a26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726, 0xff26d726,
    0xff26d726, 0xff26d726, 0x4f26d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x2826d726, 0xfe26d726, 0xf026d726, 0xf026d726, 0xf026d726, 0xf026d726,
    0xf026d726, 0xfb26d726, 0x4426d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x0426d726, 0x1c26d726, 0x1b26d726, 0x1b26d726, 0x1b26d726, 0x1b26d726,
    0x1b26d726, 0x1c26d726, 0x0726d726, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
};


// end --- linux_icon.h --- 


internal void
linux_set_icon(Display* d, Window w){
    Atom WM_ICON = XInternAtom(d, "_NET_WM_ICON", False);
    XChangeProperty(d, w, WM_ICON, XA_CARDINAL, 32, PropModeReplace, (unsigned char*)linux_icon, sizeof(linux_icon) / sizeof(long));
}

// begin --- linux_error_box.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *  (Mostly by insofaras)
 *
 * 18.07.2017
 *
 * Linux fatal error message box.
 *
 */

// TOP

// HACK(allen): // NOTE(inso): this was a quick hack, might need some cleanup.
internal void
system_error_box(char *msg){
    fprintf(stderr, "Fatal Error: %s\n", msg);
    //LOGF("Fatal Error: %s\n", msg);
    
    Display *dpy = XOpenDisplay(0);
    if (!dpy){
        exit(1);
    }
    
    const int num_cols = 50;
    int win_w = (num_cols + 10) * 9;
    int win_h = 140;
    
    {
        const char *start_p = msg, *space_p = NULL;
        for(const char* p = msg; *p; ++p){
            if (*p == ' ') space_p = p;
            if (*p == '\n' || p - start_p > num_cols){
                win_h += 18;
                start_p = space_p ? space_p + 1 : p;
                space_p = NULL;
            }
        }
    }
    
    Window w = XCreateSimpleWindow(dpy, DefaultRootWindow(dpy), 0, 0, win_w, win_h, 0, 0, 0x227A3B);
    XStoreName(dpy, w, "4coder Error");
    
    XSizeHints* sh = XAllocSizeHints();
    sh->flags = PMinSize;
    sh->min_width = win_w;
    sh->min_height = win_h;
    XSetWMNormalHints(dpy, w, sh);
    
    Atom type = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
    
    XChangeProperty(dpy, w, XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False), XA_ATOM, 32, PropModeReplace, (unsigned char*) &type, 1);
    
    Atom WM_DELETE_WINDOW = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
    XSetWMProtocols(dpy, w, &WM_DELETE_WINDOW, 1);
    
    linux_set_icon(dpy, w);
    
    XMapRaised(dpy, w);
    XSync(dpy, False);
    
    XSelectInput(dpy, w, ExposureMask | StructureNotifyMask | PointerMotionMask | ButtonPressMask | ButtonReleaseMask | KeyPressMask);
    
    XFontStruct* font = XLoadQueryFont(dpy, "-*-fixed-bold-*-*-*-*-140-*-*-*-*-iso8859-1");
    if (!font){
        exit(1);
    }
    
    XGCValues gcv;
    gcv.foreground = WhitePixel(dpy, 0);
    gcv.line_width = 2;
    gcv.font = font->fid;
    
    GC gc1 = XCreateGC(dpy, w, GCForeground | GCFont | GCLineWidth, &gcv);
    gcv.foreground = BlackPixel(dpy, 0);
    GC gc2 = XCreateGC(dpy, w, GCForeground | GCFont | GCLineWidth, &gcv);
    
    int button_trigger = 0;
    int button_hi = 0;
    int redraw = 1;
    
    XEvent ev;
    while (1){
        XNextEvent(dpy, &ev);
        
        if (ev.type == Expose) redraw = 1;
        
        if (ev.type == ConfigureNotify){
            redraw = 1;
            win_w = ev.xconfigure.width;
            win_h = ev.xconfigure.height;
        }
        
        XRectangle button_rect = { (short)(win_w/2-40), (short)(win_h*0.8f), 80, 20 };
        
        if (ev.type == MotionNotify){
            int new_hi = (ev.xmotion.x > button_rect.x &&
                          ev.xmotion.y > button_rect.y &&
                          ev.xmotion.x < button_rect.x + button_rect.width &&
                          ev.xmotion.y < button_rect.y + button_rect.height);
            
            if (new_hi != button_hi){
                button_hi = new_hi;
                redraw = 1;
            }
        }
        
        if (ev.type == KeyPress){
            KeySym sym = XLookupKeysym(&ev.xkey, 0);
            if (sym == XK_Escape || sym == XK_Return){
                exit(1);
            }
        }
        
        if (ev.type == ButtonPress && ev.xbutton.button == Button1){
            if (button_hi) button_trigger = 1;
            redraw = 1;
        }
        
        if (ev.type == ButtonRelease && ev.xbutton.button == Button1){
            if (button_trigger){
                if (button_hi){
                    exit(1);
                } else {
                    button_trigger = 0;
                }
            }
            redraw = 1;
        }
        
        if (ev.type == ClientMessage && ev.xclient.window == w && (Atom)ev.xclient.data.l[0] == WM_DELETE_WINDOW){
            exit(1);
        }
        
#define DRAW_STR(x, y, str, len) \
XDrawString(dpy, w, gc2, (x)+1, (y)+1, (str), (len)); \
XDrawString(dpy, w, gc1, (x)  , (y)  , (str), (len))
        
        if (redraw){
            redraw = 0;
            XClearWindow(dpy, w);
            
            const char* line_start = msg;
            const char* last_space = NULL;
            int y = 30;
            
            {
                const char title[] = "4coder - Fatal Error";
                int width = XTextWidth(font, title, sizeof(title)-1);
                int x = (win_w/2) - (width/2);
                DRAW_STR(x, y, title, sizeof(title)-1);
            }
            
            y += 36;
            int width = XTextWidth(font, "x", 1) * num_cols;
            int x = (win_w/2) - (width/2);
            
            for(const char* p = line_start; *p; ++p){
                if (*p == ' ') last_space = p;
                if (p - line_start > num_cols || *p == '\n' || !p[1]){
                    
                    const char* new_line_start = last_space + 1;
                    if (!last_space || *p == '\n' || !p[1]){
                        new_line_start = last_space = (p + !p[1]);
                    }
                    
                    DRAW_STR(x, y, line_start, last_space - line_start);
                    
                    line_start = new_line_start;
                    last_space = NULL;
                    y += 18;
                }
            }
            
            XDrawRectangles(dpy, w, gc1, &button_rect, 1);
            if (button_hi || button_trigger){
                XDrawRectangle(dpy, w, gc2, button_rect.x+1, button_rect.y+1, button_rect.width-2, button_rect.height-2);
            }
            
            DRAW_STR(button_rect.x + 20, button_rect.y + 15, "Drat!", 5);
        }
    }
#undef DRAW_STR
    
    exit(1);
}

// BOTTOM



// end --- linux_error_box.cpp --- 



function void
os_popup_error(char *title, char *message){
    system_error_box(message);
    exit(1);
}

////////////////////////////

// begin --- linux_4ed_functions.cpp --- 

/*
 * chr  - Andrew Chronister &
 * inso - Alex Baines
 *
 * 02.02.2020
 *
 * Updated linux layer for 4coder
 *
 */

global char *lnx_override_user_directory = 0;

internal String_Const_u8
system_get_path(Arena* arena, System_Path_Code path_code){
    String_Const_u8 result = {};
    
    switch (path_code){
        case SystemPath_CurrentDirectory: {
            // glibc extension: getcwd allocates its own memory if passed NULL
            char *working_dir = getcwd(NULL, 0);
            u64 working_dir_len = cstring_length(working_dir);
            u8 *out = push_array(arena, u8, working_dir_len + 1);
            block_copy(out, working_dir, working_dir_len);
            
            // NOTE: 4ed appears to expect a slash on the end.
            out[working_dir_len] = '/';
            
            free(working_dir);
            result = SCu8(out, working_dir_len + 1);
        } break;
        
        case SystemPath_Binary: {
            // linux-specific: binary path symlinked at /proc/self/exe
            // PATH_MAX is probably good enough...
            // read the 'readlink' manpage for some comedy about it being 'broken by design'.
            
            char* buf = push_array(arena, char, PATH_MAX);
            ssize_t n = readlink("/proc/self/exe", buf, PATH_MAX);
            
            if(n == -1) {
                perror("readlink");
                *buf = n = 0;
            }
            
            result = string_remove_last_folder(SCu8(buf, n));
        } break;
        
        case SystemPath_UserDirectory:
        {
            if (lnx_override_user_directory == 0){
                char *home_cstr = getenv("HOME");
                if (home_cstr != 0){
                    result = push_u8_stringf(arena, "%s/.4coder/", home_cstr);
                }
            }
            else{
                result = SCu8((u8*)lnx_override_user_directory);
            }
        }break;
    }
    
    return(result);
}

internal String_Const_u8
system_get_canonical(Arena* arena, String_Const_u8 name){
    
    // first remove redundant ../, //, ./ parts
    
    const u8* input = (u8*) strndupa((char*)name.str, name.size);
    u8* output = push_array(arena, u8, name.size + 1);
    
    const u8* p = input;
    u8* q = output;
    
    while(*p) {
        
        // not a slash - copy char
        if(p[0] != '/') {
            *q++ = *p++;
            continue;
        }
        
        // two slashes in a row, skip one.
        if(p[1] == '/') {
            ++p;
        }
        else if(p[1] == '.') {
            
            // skip "/./" or trailing "/."
            if(p[2] == '/' || p[2] == '\0') {
                p += 2;
            }
            
            // if we encounter "/../" or trailing "/..", remove last directory instead
            else if(p[2] == '.' && (p[3] == '/' || p[3] == '\0')) {
                while(q > output && *--q != '/'){};
                p += 3;
            }
            
            else {
                *q++ = *p++;
            }
        }
        else {
            *q++ = *p++;
        }
    }
    
#ifdef INSO_DEBUG
    if(name.size != q - output) {
        LINUX_FN_DEBUG("[%.*s] -> [%.*s]", (int)name.size, name.str, (int)(q - output), output);
    }
#endif
    
    // TODO: use realpath at this point to resolve symlinks?
    return SCu8(output, q - output);
}

internal File_List
system_get_file_list(Arena* arena, String_Const_u8 directory){
    //LINUX_FN_DEBUG("%.*s", (int)directory.size, directory.str);
    File_List result = {};
    
    char* path = strndupa((char*)directory.str, directory.size);
    int fd = open(path, O_RDONLY | O_DIRECTORY);
    if(fd == -1) {
        perror("open");
        return result;
    }
    
    DIR* dir = fdopendir(fd);
    struct dirent* d;
    
    File_Info* head = NULL;
    File_Info** fip = &head;
    
    while((d = readdir(dir))) {
        const char* name = d->d_name;
        
        // ignore . and ..
        if(*name == '.' && (name[1] == '\0' || (name[1] == '.' && name[2] == '\0'))) {
            continue;
        }
        
        *fip = push_array_zero(arena, File_Info, 1);
        (*fip)->file_name = push_u8_stringf(arena, "%.*s", d->d_reclen, name);
        
        struct stat st;
        if (fstatat(fd, name, &st, 0) == -1){
            perror("fstatat");
        }
        else{
            (*fip)->attributes = linux_file_attributes_from_struct_stat(&st);
        }
        
        fip = &(*fip)->next;
        result.count++;
    }
    closedir(dir);
    
    if(result.count > 0) {
        result.infos = fip = push_array(arena, File_Info*, result.count);
        
        for(File_Info* f = head;
            f != 0;
            f = f->next) {
            *fip++ = f;
        }
        
        qsort(result.infos, result.count, sizeof(File_Info*), (__compar_fn_t)&linux_compare_file_infos);
        
        for(u32 i = 0; i < result.count - 1; ++i) {
            result.infos[i]->next = result.infos[i+1];
        }
        result.infos[result.count-1]->next = NULL;
    }
    
    return result;
}

internal File_Attributes
system_quick_file_attributes(Arena* scratch, String_Const_u8 file_name){
    //LINUX_FN_DEBUG("%.*s", (int)file_name.size, file_name.str);
    Temp_Memory_Block temp(scratch);
    file_name = push_string_copy(scratch, file_name);
    File_Attributes result = {};
    struct stat file_stat;
    if (stat((const char*)file_name.str, &file_stat) == 0){
        result = linux_file_attributes_from_struct_stat(&file_stat);
    }
    return(result);
}

internal b32
system_load_handle(Arena* scratch, char* file_name, Plat_Handle* out){
    LINUX_FN_DEBUG("%s", file_name);
    int fd = open(file_name, O_RDONLY);
    if (fd != -1) {
        *(int*)out = fd;
        return true;
    }
    return false;
}

internal File_Attributes
system_load_attributes(Plat_Handle handle){
    LINUX_FN_DEBUG();
    File_Attributes result = {};
    struct stat file_stat;
    if (fstat(*(int*)&handle, &file_stat) == 0){
        result = linux_file_attributes_from_struct_stat(&file_stat);
    }
    return(result);
}

internal b32
system_load_file(Plat_Handle handle, char* buffer, u32 size){
    LINUX_FN_DEBUG("%.*s", size, buffer);
    int fd = *(int*)&handle;
    int bytes_read = read(fd, buffer, size);
    if (bytes_read == size) {
        return true;
    }
    return false;
}

internal b32
system_load_close(Plat_Handle handle){
    LINUX_FN_DEBUG();
    int fd = *(int*)&handle;
    return close(fd) == 0;
}

internal File_Attributes
system_save_file(Arena* scratch, char* file_name, String_Const_u8 data){
    LINUX_FN_DEBUG("%s", file_name);
    File_Attributes result = {};
    
    // TODO(inso): should probably put a \n on the end if it's a text file.
    
    int fd = open(file_name, O_TRUNC|O_WRONLY|O_CREAT, 0666);
    if (fd != -1) {
        int bytes_written = write(fd, data.str, data.size);
        if (bytes_written == -1) {
            perror("write");
        } else if (bytes_written == data.size) {
            struct stat file_stat;
            if (fstat(fd, &file_stat) == 0){
                result = linux_file_attributes_from_struct_stat(&file_stat);
            }
        }
        close(fd);
    } else {
        perror("open");
    }
    
    return result;
}

internal b32
system_load_library(Arena* scratch, String_Const_u8 file_name, System_Library* out){
    LINUX_FN_DEBUG("%.*s", (int)file_name.size, file_name.str);
    void* library = dlopen((const char*)file_name.str, RTLD_LAZY);
    if (library != NULL) {
        *(void**)out = library;
        return true;
    }
    return false;
}

internal b32
system_release_library(System_Library handle){
    LINUX_FN_DEBUG();
    return dlclose(*(void**)&handle) == 0;
}

internal Void_Func*
system_get_proc(System_Library handle, char* proc_name){
    LINUX_FN_DEBUG("%s", proc_name);
    return (Void_Func*)dlsym(*(void**)&handle, proc_name);
}

internal u64
system_now_time(void){
    //LINUX_FN_DEBUG();
    struct timespec time;
    clock_gettime(CLOCK_MONOTONIC, &time);
    return linux_us_from_timespec(time);
}

function void
linux_date_time_from_tm(Date_Time *out, struct tm *in){
    out->year = in->tm_year + 1900;
    out->mon = in->tm_mon;
    out->day = in->tm_mday - 1;
    out->hour = in->tm_hour;
    out->min = in->tm_min;
    out->sec = in->tm_sec;
    out->msec = 0;
}

function void
linux_tm_from_date_time(struct tm *out, Date_Time *in){
    out->tm_year = in->year - 1900;
    out->tm_mon = in->mon;
    out->tm_mday = in->day + 1;
    out->tm_hour = in->hour;
    out->tm_min = in->min;
    out->tm_sec = in->sec;
}

function
system_now_date_time_universal_sig(){
    time_t now_time = time(0);
    struct tm *now_tm = gmtime(&now_time);
    Date_Time result = {};
    linux_date_time_from_tm(&result, now_tm);
    return(result);
}

function
system_local_date_time_from_universal_sig(){
    struct tm univ_tm = {};
    linux_tm_from_date_time(&univ_tm, date_time);
    time_t utc_time = timegm(&univ_tm);
    struct tm *local_tm = localtime(&utc_time);
    Date_Time result = {};
    linux_date_time_from_tm(&result, local_tm);
    return(result);
}

function
system_universal_date_time_from_local_sig(){
    struct tm local_tm = {};
    linux_tm_from_date_time(&local_tm, date_time);
    time_t loc_time = timelocal(&local_tm);
    struct tm *utc_tm = gmtime(&loc_time);
    Date_Time result = {};
    linux_date_time_from_tm(&result, utc_tm);
    return(result);
}

internal Plat_Handle
system_wake_up_timer_create(void){
    LINUX_FN_DEBUG();
    Linux_Object* object = linux_alloc_object(LinuxObjectKind_Timer);
    dll_insert(&linuxvars.timer_objects, &object->node);
    
    // NOTE(inso): timers created on-demand to avoid file-descriptor exhaustion.
    object->timer.fd = -1;
    return object_to_handle(object);
}

internal void
system_wake_up_timer_release(Plat_Handle handle){
    LINUX_FN_DEBUG();
    Linux_Object* object = handle_to_object(handle);
    if (object->kind == LinuxObjectKind_Timer){
        if(object->timer.fd != -1) {
            close(object->timer.fd);
            object->timer.fd = -1;
        }
        linux_free_object(object);
    }
}

internal void
system_wake_up_timer_set(Plat_Handle handle, u32 time_milliseconds){
    //LINUX_FN_DEBUG("%u", time_milliseconds);
    Linux_Object* object = handle_to_object(handle);
    
    if (object->kind == LinuxObjectKind_Timer){
        if(object->timer.fd == -1) {
            object->timer.fd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);
            
            struct epoll_event ev;
            ev.events = EPOLLIN | EPOLLET | EPOLLONESHOT;
            ev.data.ptr = &object->timer.epoll_tag;
            epoll_ctl(linuxvars.epoll, EPOLL_CTL_ADD, object->timer.fd, &ev);
        }
        
        struct itimerspec it = {};
        it.it_value.tv_sec = time_milliseconds / 1000;
        it.it_value.tv_nsec = (time_milliseconds % 1000) * UINT64_C(1000000);
        timerfd_settime(object->timer.fd, 0, &it, NULL);
    }
    
}

internal void
system_signal_step(u32 code){
    LINUX_FN_DEBUG("%d", code);
    linux_schedule_step();
}

internal void
system_sleep(u64 microseconds){
    //LINUX_FN_DEBUG("%" PRIu64, microseconds);
    struct timespec requested;
    struct timespec remaining;
    u64 seconds = microseconds / Million(1);
    requested.tv_sec = seconds;
    requested.tv_nsec = (microseconds - seconds * Million(1)) * Thousand(1);
    nanosleep(&requested, &remaining);
}

internal b32
system_cli_call(Arena* scratch, char* path, char* script, CLI_Handles* cli_out){
    LINUX_FN_DEBUG("%s / %s", path, script);
    int pipe_fds[2];
    if (pipe(pipe_fds) == -1){
        perror("system_cli_call: pipe");
        return 0;
    }
    
    pid_t child_pid = vfork();
    if (child_pid == -1){
        perror("system_cli_call: fork");
        return 0;
    }
    
    enum { PIPE_FD_READ, PIPE_FD_WRITE };
    
    // child
    if (child_pid == 0){
        close(pipe_fds[PIPE_FD_READ]);
        dup2(pipe_fds[PIPE_FD_WRITE], STDOUT_FILENO);
        dup2(pipe_fds[PIPE_FD_WRITE], STDERR_FILENO);
        
        if (chdir(path) == -1){
            perror("system_cli_call: chdir");
            exit(1);
        }
        
        char* argv[] = { "sh", "-c", script, NULL };
        
        if (execv("/bin/sh", argv) == -1){
            perror("system_cli_call: execv");
        }
        exit(1);
    }
    else{
        close(pipe_fds[PIPE_FD_WRITE]);
        
        *(pid_t*)&cli_out->proc = child_pid;
        *(int*)&cli_out->out_read = pipe_fds[PIPE_FD_READ];
        *(int*)&cli_out->out_write = pipe_fds[PIPE_FD_WRITE];
        
        struct epoll_event e = {};
        e.events = EPOLLIN | EPOLLET;
        e.data.ptr = &epoll_tag_cli_pipe;
        epoll_ctl(linuxvars.epoll, EPOLL_CTL_ADD, pipe_fds[PIPE_FD_READ], &e);
    }
    
    return(true);
}

internal void
system_cli_begin_update(CLI_Handles* cli){
    // NOTE(inso): I don't think anything needs to be done here.
    //LINUX_FN_DEBUG();
}

internal b32
system_cli_update_step(CLI_Handles* cli, char* dest, u32 max, u32* amount){
    LINUX_FN_DEBUG();
    int pipe_read_fd = *(int*)&cli->out_read;
    
    fd_set fds;
    FD_ZERO(&fds);
    FD_SET(pipe_read_fd, &fds);
    
    struct timeval tv = {};
    
    size_t space_left = max;
    char* ptr = dest;
    
    while (space_left > 0 && select(pipe_read_fd + 1, &fds, NULL, NULL, &tv) == 1){
        ssize_t num = read(pipe_read_fd, ptr, space_left);
        if (num == -1){
            perror("system_cli_update_step: read");
        } else if (num == 0){
            // NOTE(inso): EOF
            break;
        } else {
            ptr += num;
            space_left -= num;
        }
    }
    
    *amount = (ptr - dest);
    return((ptr - dest) > 0);
}

internal b32
system_cli_end_update(CLI_Handles* cli){
    LINUX_FN_DEBUG();
    pid_t pid = *(pid_t*)&cli->proc;
    b32 close_me = false;
    
    int status;
    if (pid && waitpid(pid, &status, WNOHANG) > 0){
        cli->exit = WEXITSTATUS(status);
        
        close_me = true;
        close(*(int*)&cli->out_read);
        close(*(int*)&cli->out_write);
    }
    
    return(close_me);
}

internal void
system_open_color_picker(Color_Picker* picker){
    // TODO?
    LINUX_FN_DEBUG();
}

internal f32
system_get_screen_scale_factor(void){
    LINUX_FN_DEBUG();
    // TODO: correct screen number somehow
    int dpi = linux_get_xsettings_dpi(linuxvars.dpy, 0);
    if(dpi == -1){
        int scr = DefaultScreen(linuxvars.dpy);
        int dw = DisplayWidth(linuxvars.dpy, scr);
        int dh = DisplayHeight(linuxvars.dpy, scr);
        int dw_mm = DisplayWidthMM(linuxvars.dpy, scr);
        int dh_mm = DisplayHeightMM(linuxvars.dpy, scr);
        int dpi_x = dw_mm ? dw / (dw_mm / 25.4) : 96;
        int dpi_y = dh_mm ? dh / (dh_mm / 25.4) : 96;
        dpi = dpi_x > dpi_y ? dpi_x : dpi_y;
    }
    return dpi / 96.0f;
}

internal System_Thread
system_thread_launch(Thread_Function* proc, void* ptr){
    LINUX_FN_DEBUG();
    System_Thread result = {};
    
    Linux_Object* thread_info = linux_alloc_object(LinuxObjectKind_Thread);
    thread_info->thread.proc = proc;
    thread_info->thread.ptr = ptr;
    
    pthread_attr_t thread_attr;
    pthread_attr_init(&thread_attr);
    int create_result = pthread_create(
                                       &thread_info->thread.pthread,
                                       &thread_attr,
                                       linux_thread_proc_start,
                                       thread_info);
    
    pthread_attr_destroy(&thread_attr);
    
    // TODO(andrew): Need to wait for thread to confirm it launched?
    if (create_result == 0) {
        static_assert(sizeof(Linux_Object*) <= sizeof(System_Thread), "Linux_Object doesn't fit inside System_Thread");
        *(Linux_Object**)&result = thread_info;
        return result;
    }
    
    return result;
}

internal void
system_thread_join(System_Thread thread){
    LINUX_FN_DEBUG();
    Linux_Object* object = *(Linux_Object**)&thread;
    void* retval_ignored;
    int result = pthread_join(object->thread.pthread, &retval_ignored);
}

internal void
system_thread_free(System_Thread thread){
    LINUX_FN_DEBUG();
    Linux_Object* object = *(Linux_Object**)&thread;
    Assert(object->kind == LinuxObjectKind_Thread);
    linux_free_object(object);
}

internal i32
system_thread_get_id(void){
    pid_t id = syscall(__NR_gettid);
    //LINUX_FN_DEBUG("%d", id);
    return id;
}

internal void
system_acquire_global_frame_mutex(Thread_Context* tctx){
    //LINUX_FN_DEBUG();
    if (tctx->kind == ThreadKind_AsyncTasks ||
        tctx->kind == ThreadKind_Main){
        system_mutex_acquire(linuxvars.global_frame_mutex);
    }
}

internal void
system_release_global_frame_mutex(Thread_Context* tctx){
    //LINUX_FN_DEBUG();
    if (tctx->kind == ThreadKind_AsyncTasks ||
        tctx->kind == ThreadKind_Main){
        system_mutex_release(linuxvars.global_frame_mutex);
    }
}

internal System_Mutex
system_mutex_make(void){
    System_Mutex result = {};
    Linux_Object* object = linux_alloc_object(LinuxObjectKind_Mutex);
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
    pthread_mutex_init(&object->mutex, &attr);
    *(Linux_Object**)&result = object;
    //LINUX_FN_DEBUG("%p", object);
    return result;
}

internal void
system_mutex_acquire(System_Mutex mutex){
    Linux_Object* object = *(Linux_Object**)&mutex;
    //LINUX_FN_DEBUG("%p", object);
    Assert(object->kind == LinuxObjectKind_Mutex);
    pthread_mutex_lock(&object->mutex);
}

internal void
system_mutex_release(System_Mutex mutex){
    Linux_Object* object = *(Linux_Object**)&mutex;
    //LINUX_FN_DEBUG("%p", object);
    Assert(object->kind == LinuxObjectKind_Mutex);
    pthread_mutex_unlock(&object->mutex);
}

internal void
system_mutex_free(System_Mutex mutex){
    Linux_Object* object = *(Linux_Object**)&mutex;
    //LINUX_FN_DEBUG("%p", object);
    Assert(object->kind == LinuxObjectKind_Mutex);
    pthread_mutex_destroy(&object->mutex);
    linux_free_object(object);
}

internal System_Condition_Variable
system_condition_variable_make(void){
    System_Condition_Variable result = {};
    Linux_Object* object = linux_alloc_object(LinuxObjectKind_ConditionVariable);
    //LINUX_FN_DEBUG("%p", object);
    pthread_cond_init(&object->condition_variable, NULL);
    *(Linux_Object**)&result = object;
    return result;
}

internal void
system_condition_variable_wait(System_Condition_Variable cv, System_Mutex mutex){
    Linux_Object* cv_object = *(Linux_Object**)&cv;
    Linux_Object* mutex_object = *(Linux_Object**)&mutex;
    //LINUX_FN_DEBUG("%p / %p", cv_object, mutex_object);
    Assert(cv_object->kind == LinuxObjectKind_ConditionVariable);
    Assert(mutex_object->kind == LinuxObjectKind_Mutex);
    pthread_cond_wait(&cv_object->condition_variable, &mutex_object->mutex);
}

internal void
system_condition_variable_signal(System_Condition_Variable cv){
    Linux_Object* object = *(Linux_Object**)&cv;
    //LINUX_FN_DEBUG("%p", object);
    Assert(object->kind == LinuxObjectKind_ConditionVariable);
    pthread_cond_signal(&object->condition_variable);
}

internal void
system_condition_variable_free(System_Condition_Variable cv){
    Linux_Object* object = *(Linux_Object**)&cv;
    LINUX_FN_DEBUG("%p", &object->condition_variable);
    Assert(object->kind == LinuxObjectKind_ConditionVariable);
    pthread_cond_destroy(&object->condition_variable);
    linux_free_object(object);
}

#define MEMORY_PREFIX_SIZE 64

internal void*
system_memory_allocate(u64 size, String_Const_u8 location){
    
    static_assert(MEMORY_PREFIX_SIZE >= sizeof(Memory_Annotation_Node), "MEMORY_PREFIX_SIZE is not enough to contain Memory_Annotation_Node");
    u64 adjusted_size = size + MEMORY_PREFIX_SIZE;
    
    Assert(adjusted_size > size);
    
    const int prot  = PROT_READ | PROT_WRITE;
    const int flags = MAP_PRIVATE | MAP_ANONYMOUS;
    
    void* result = mmap(NULL, adjusted_size, prot, flags, -1, 0);
    
    if(result == MAP_FAILED) {
        perror("mmap");
        return NULL;
    }
    
    Linux_Memory_Tracker_Node* node = (Linux_Memory_Tracker_Node*)result;
    node->location = location;
    node->size = size;
    
    pthread_mutex_lock(&linuxvars.memory_tracker_mutex);
    zdll_push_back(linuxvars.memory_tracker_head, linuxvars.memory_tracker_tail, node);
    linuxvars.memory_tracker_count++;
    pthread_mutex_unlock(&linuxvars.memory_tracker_mutex);
    
    return (u8*)result + MEMORY_PREFIX_SIZE;
}

internal b32
system_memory_set_protection(void* ptr, u64 size, u32 flags){
    LINUX_FN_DEBUG("%p / %ld / %d", ptr, size, flags);
    int protect = 0;
    MovFlag(flags, MemProtect_Read, protect, PROT_READ);
    MovFlag(flags, MemProtect_Write, protect, PROT_WRITE);
    MovFlag(flags, MemProtect_Execute, protect, PROT_EXEC);
    int result = mprotect(ptr, size, protect);
    return result == 0;
}

internal void
system_memory_free(void* ptr, u64 size){
    u64 adjusted_size = size + MEMORY_PREFIX_SIZE;
    Linux_Memory_Tracker_Node* node = (Linux_Memory_Tracker_Node*)((u8*)ptr - MEMORY_PREFIX_SIZE);
    
    pthread_mutex_lock(&linuxvars.memory_tracker_mutex);
    zdll_remove(linuxvars.memory_tracker_head, linuxvars.memory_tracker_tail, node);
    linuxvars.memory_tracker_count--;
    pthread_mutex_unlock(&linuxvars.memory_tracker_mutex);
    
    if(munmap(node, adjusted_size) == -1) {
        perror("munmap");
    }
}

internal Memory_Annotation
system_memory_annotation(Arena* arena){
    LINUX_FN_DEBUG();
    
    Memory_Annotation result;
    Memory_Annotation_Node** ptr = &result.first;
    
    pthread_mutex_lock(&linuxvars.memory_tracker_mutex);
    
    for(Linux_Memory_Tracker_Node* node = linuxvars.memory_tracker_head; node; node = node->next) {
        *ptr = push_array(arena, Memory_Annotation_Node, 1);
        (*ptr)->location = node->location;
        (*ptr)->size = node->size;
        (*ptr)->address = (u8*)node + MEMORY_PREFIX_SIZE;
        ptr = &(*ptr)->next;
        result.count++;
    }
    
    pthread_mutex_unlock(&linuxvars.memory_tracker_mutex);
    
    *ptr = NULL;
    result.last = CastFromMember(Memory_Annotation_Node, next, ptr);
    
    return result;
}

internal void
system_show_mouse_cursor(i32 show){
    LINUX_FN_DEBUG("%d", show);
    
    linuxvars.cursor_show = show;
    
    XDefineCursor(
                  linuxvars.dpy,
                  linuxvars.win,
                  show ? None : linuxvars.hidden_cursor);
}

internal b32
system_set_fullscreen(b32 full_screen){
    linux_window_fullscreen(full_screen ? WM_STATE_ADD : WM_STATE_DEL);
    return true;
}

internal b32
system_is_fullscreen(void){
    b32 result = 0;
    
    // NOTE(inso): This will get the "true" state of fullscreen,
    // even if it was toggled outside of 4coder.
    // (e.g. super-F11 on some WMs sets fullscreen for any window/program)
    
    Atom type, *prop;
    unsigned long nitems, pad;
    int fmt;
    int ret = XGetWindowProperty(linuxvars.dpy,
                                 linuxvars.win,
                                 linuxvars.atom__NET_WM_STATE,
                                 0, 32, False, XA_ATOM,
                                 &type, &fmt, &nitems, &pad,
                                 (unsigned char**)&prop);
    
    if(ret == Success && prop){
        result = *prop == linuxvars.atom__NET_WM_STATE_FULLSCREEN;
        XFree((unsigned char*)prop);
    }
    
    return result;
}

internal Input_Modifier_Set
system_get_keyboard_modifiers(Arena* arena){
    //LINUX_FN_DEBUG();
    return(copy_modifier_set(arena, &linuxvars.input.pers.modifiers));
}

function
system_set_key_mode_sig(){
    linuxvars.key_mode = mode;
}

internal void
system_set_source_mixer(void* ctx, Audio_Mix_Sources_Function* mix_func){
    pthread_mutex_lock(&linuxvars.audio_mutex);
    linuxvars.audio_ctx = ctx;
    linuxvars.audio_src_func = mix_func;
    pthread_mutex_unlock(&linuxvars.audio_mutex);
}

internal void
system_set_destination_mixer(Audio_Mix_Destination_Function* mix_func){
    pthread_mutex_lock(&linuxvars.audio_mutex);
    linuxvars.audio_dst_func = mix_func;
    pthread_mutex_unlock(&linuxvars.audio_mutex);
}

// NOTE(inso): to prevent me continuously messing up indentation
// vim: et:ts=4:sts=4:sw=4


// end --- linux_4ed_functions.cpp --- 



// begin --- linux_4ed_audio.cpp --- 

#define ___fred_function function
#undef function
#include <alsa/asoundlib.h>
#include <poll.h>
#define function ___fred_function

internal void
linux_default_mix_sources(void *ctx, f32 *mix_buffer, u32 sample_count)
{

}

internal void
linux_default_mix_destination(i16 *dst, f32 *src, u32 sample_count)
{
    u32 opl = sample_count*2;
    for(u32 i = 0; i < sample_count; i += 1){
        dst[i] = (i16)src[i];
    }
}

internal struct alsa_funcs {
#define ALSA_FN(r,n,a) r (*n) a;

// begin --- alsa_funcs.txt --- 

ALSA_FN(snd_pcm_sframes_t, writei                   , (snd_pcm_t *pcm, const void *buffer, snd_pcm_uframes_t size))
ALSA_FN(int              , recover                  , (snd_pcm_t *pcm, int err, int silent))
ALSA_FN(int              , open                     , (snd_pcm_t **pcm, const char *name, snd_pcm_stream_t stream, int mode))
ALSA_FN(int              , hw_params_malloc         , (snd_pcm_hw_params_t **ptr))
ALSA_FN(int              , hw_params_any            , (snd_pcm_t *pcm, snd_pcm_hw_params_t *params))
ALSA_FN(int              , hw_params_set_access     , (snd_pcm_t *pcm, snd_pcm_hw_params_t *params, snd_pcm_access_t _access))
ALSA_FN(int              , hw_params_set_format     , (snd_pcm_t *pcm, snd_pcm_hw_params_t *params, snd_pcm_format_t val))
ALSA_FN(int              , hw_params_set_channels   , (snd_pcm_t *pcm, snd_pcm_hw_params_t *params, unsigned int val))
ALSA_FN(int              , hw_params_set_rate       , (snd_pcm_t *pcm, snd_pcm_hw_params_t *params, unsigned int val, int dir))
ALSA_FN(int              , hw_params_set_buffer_size, (snd_pcm_t *pcm, snd_pcm_hw_params_t *params, snd_pcm_uframes_t val))
ALSA_FN(int              , hw_params                , (snd_pcm_t *pcm, snd_pcm_hw_params_t *params))
ALSA_FN(void             , hw_params_free           , (snd_pcm_hw_params_t *obj))
ALSA_FN(int              , poll_descriptors_count   , (snd_pcm_t *pcm))
ALSA_FN(int              , poll_descriptors         , (snd_pcm_t *pcm, struct pollfd *pfds, unsigned int space))


// end --- alsa_funcs.txt --- 


#undef ALSA_FN
} snd_pcm;

internal void
linux_submit_audio(snd_pcm_t* pcm, i16* samples, u32 sample_count, f32* mix_buffer)
{
    Audio_Mix_Sources_Function *audio_mix_src;
    Audio_Mix_Destination_Function *audio_mix_dst;

    pthread_mutex_lock(&linuxvars.audio_mutex);
    audio_mix_src = linuxvars.audio_src_func;
    audio_mix_dst = linuxvars.audio_dst_func;
    void* audio_ctx = linuxvars.audio_ctx;
    pthread_mutex_unlock(&linuxvars.audio_mutex);

    if(!audio_mix_src) {
        audio_mix_src = linux_default_mix_sources;
    }

    if(!audio_mix_dst) {
        audio_mix_dst = linux_default_mix_destination;
    }

    audio_mix_src(audio_ctx, mix_buffer, sample_count);
    audio_mix_dst(samples, mix_buffer, sample_count);

    int err = snd_pcm.writei(pcm, samples, sample_count);
    if(err < 0){
	    snd_pcm.recover(pcm, err, 1);
    }
}

#define chk(x) ({\
	int err = (x);\
	if(err < 0){\
		fprintf(stderr, "ALSA ERR: %s: [%d]\n", #x, err);\
	}\
})

internal void
linux_audio_main(void* _unused)
{
    const u32 SamplesPerSecond = 48000;
    const u32 SamplesPerBuffer = 16*SamplesPerSecond/1000;
    const u32 ChannelCount = 2;
    const u32 BytesPerSample = 2; // S16LE
    const u32 BufferSize = SamplesPerBuffer * BytesPerSample;
    const u32 BufferCount = 3;
    const u32 MixBufferSize = (SamplesPerBuffer * ChannelCount * sizeof(f32));
    const u32 SampleBufferSize = (SamplesPerBuffer * ChannelCount * sizeof(i16));

    void* lib = dlopen("libasound.so.2", RTLD_LOCAL | RTLD_LAZY);
    if(!lib) {
        fprintf(stderr, "failed to load libasound.so.2: %s", dlerror());\
        return;
    }

#define ALSA_FN(r,n,a)\
    *((void**)&snd_pcm.n) = (void*)dlsym(lib, stringify(snd_pcm_##n));\
    if(!snd_pcm.n){\
        fprintf(stderr, "failed to load alsa func: %s", #n);\
        return;\
    }
#undef ALSA_FN

    snd_pcm_t* pcm;

	chk( snd_pcm.open(&pcm, "default", SND_PCM_STREAM_PLAYBACK, 0));

	     snd_pcm_hw_params_t*                hw;
	chk( snd_pcm.hw_params_malloc          (&hw));
	chk( snd_pcm.hw_params_any             (pcm, hw));
	chk( snd_pcm.hw_params_set_access      (pcm, hw, SND_PCM_ACCESS_RW_INTERLEAVED));
	chk( snd_pcm.hw_params_set_format      (pcm, hw, SND_PCM_FORMAT_S16_LE));
	chk( snd_pcm.hw_params_set_channels    (pcm, hw, ChannelCount));
	chk( snd_pcm.hw_params_set_rate        (pcm, hw, SamplesPerSecond, 0));
	chk( snd_pcm.hw_params_set_buffer_size (pcm, hw, BufferSize * BufferCount));
	chk( snd_pcm.hw_params                 (pcm, hw));
	     snd_pcm.hw_params_free            (hw);

	int fd_count = snd_pcm.poll_descriptors_count(pcm);
	struct pollfd* fds = (struct pollfd*)calloc(fd_count, sizeof(struct pollfd));
	snd_pcm.poll_descriptors(pcm, fds, fd_count);

    for(;;) {
		int n = poll(fds, fd_count, -1);
        if(n == -1) {
            perror("poll");
            continue;
        }

        f32* MixBuffer = (f32*)calloc(1, MixBufferSize);
        i16* SampleBuffer = (i16*)calloc(1, SampleBufferSize);

        if(!MixBuffer || !SampleBuffer) {
            perror("calloc");
            continue;
        }

        linux_submit_audio(pcm, SampleBuffer, SamplesPerBuffer, MixBuffer);

        free(MixBuffer);
        free(SampleBuffer);
    }
}

#undef chk


// end --- linux_4ed_audio.cpp --- 



////////////////////////////

#include <GL/gl.h>
#define GL_FUNC(N,R,P) typedef R (CALL_CONVENTION N##_Function)P; N##_Function *N = 0;

internal
graphics_get_texture_sig(){
    return(gl__get_texture(dim, texture_kind));
}

internal
graphics_fill_texture_sig(){
    return(gl__fill_texture(texture_kind, texture, p, dim, data));
}

////////////////////////////

internal Face*
font_make_face(Arena* arena, Face_Description* description, f32 scale_factor) {
    
    Face_Description local_description = *description;
    String_Const_u8* name = &local_description.font.file_name;
    
    // if description->font.file_name is a relative path, prepend the font directory.
    if(string_get_character(*name, 0) != '/') {
        String_Const_u8 binary = system_get_path(arena, SystemPath_Binary);
        *name = push_u8_stringf(arena, "%.*sfonts/%.*s", string_expand(binary), string_expand(*name));
    }
    
    Face* result = ft__font_make_face(arena, &local_description, scale_factor);
    
    if(!result) {
        // is this fatal? 4ed.cpp:277 (caller) does not check for null.
        char msg[4096];
        snprintf(msg, sizeof(msg), "Unable to load font: %.*s", string_expand(*name));
        system_error_box(msg);
    }
    
    return(result);
}

////////////////////////////

internal b32
glx_init(void) {
    int glx_maj, glx_min;
    
    if(!glXQueryVersion(linuxvars.dpy, &glx_maj, &glx_min)) {
        return false;
    }
    
    return glx_maj > 1 || (glx_maj == 1 && glx_min >= 3);
}

internal b32
glx_get_config(GLXFBConfig* fb_config, XVisualInfo* vi) {
    
    static const int attrs[] = {
        GLX_X_RENDERABLE , True,
        GLX_DRAWABLE_TYPE, GLX_WINDOW_BIT,
        GLX_RENDER_TYPE  , GLX_RGBA_BIT,
        GLX_X_VISUAL_TYPE, GLX_TRUE_COLOR,
        GLX_RED_SIZE     , 8,
        GLX_GREEN_SIZE   , 8,
        GLX_BLUE_SIZE    , 8,
        GLX_ALPHA_SIZE   , 8,
        GLX_DEPTH_SIZE   , 24,
        GLX_STENCIL_SIZE , 8,
        GLX_DOUBLEBUFFER , True,
        None
    };
    
    int conf_count = 0;
    GLXFBConfig* conf_list = glXChooseFBConfig(linuxvars.dpy, DefaultScreen(linuxvars.dpy), attrs, &conf_count);
    if(!conf_count || conf_count <= 0) {
        return false;
    }
    
    *fb_config = *conf_list;
    XFree(conf_list);
    
    XVisualInfo* xvi = glXGetVisualFromFBConfig(linuxvars.dpy, *fb_config);
    if(!xvi) {
        return false;
    }
    
    *vi = *xvi;
    XFree(xvi);
    
    return true;
}

internal b32 glx_ctx_error;

internal int
glx_error_handler(Display* dpy, XErrorEvent* ev){
    glx_ctx_error = true;
    return 0;
}

typedef GLXContext (glXCreateContextAttribsARB_Function)(Display*, GLXFBConfig, GLXContext, Bool, const int*);
typedef void       (glXSwapIntervalEXT_Function)        (Display *dpy, GLXDrawable drawable, int interval);
typedef int        (glXSwapIntervalMESA_Function)       (unsigned int interval);
typedef int        (glXGetSwapIntervalMESA_Function)    (void);
typedef int        (glXSwapIntervalSGI_Function)        (int interval);

internal b32
glx_create_context(GLXFBConfig fb_config){
    const char *glx_exts = glXQueryExtensionsString(linuxvars.dpy, DefaultScreen(linuxvars.dpy));
    
    glXCreateContextAttribsARB_Function *glXCreateContextAttribsARB = 0;
    glXSwapIntervalEXT_Function         *glXSwapIntervalEXT = 0;
    glXSwapIntervalMESA_Function        *glXSwapIntervalMESA = 0;
    glXGetSwapIntervalMESA_Function     *glXGetSwapIntervalMESA = 0;
    glXSwapIntervalSGI_Function         *glXSwapIntervalSGI = 0;
    
#define GLXLOAD(f) f = (f##_Function*) glXGetProcAddressARB((const GLubyte*) #f);
    GLXLOAD(glXCreateContextAttribsARB);
    
    GLXContext ctx = NULL;
    int (*old_handler)(Display*, XErrorEvent*) = XSetErrorHandler(&glx_error_handler);
    
    if (glXCreateContextAttribsARB == NULL){
        //LOG("glXCreateContextAttribsARB() not found, using old-style GLX context\n" );
        ctx = glXCreateNewContext(linuxvars.dpy, fb_config, GLX_RGBA_TYPE, 0, True);
    } else {
        static const int context_attribs[] = {
            GLX_CONTEXT_MAJOR_VERSION_ARB, 2,
            GLX_CONTEXT_MINOR_VERSION_ARB, 1,
            GLX_CONTEXT_PROFILE_MASK_ARB , GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB,
#if GL_DEBUG_MODE
            GLX_CONTEXT_FLAGS_ARB        , GLX_CONTEXT_DEBUG_BIT_ARB,
#endif
            None
        };
        
        //LOG("Creating GL 2.1 context... ");
        ctx = glXCreateContextAttribsARB(linuxvars.dpy, fb_config, 0, True, context_attribs);
    }
    
    XSync(linuxvars.dpy, False);
    if(glx_ctx_error || !ctx) {
        return false;
    }
    
    XSync(linuxvars.dpy, False);
    XSetErrorHandler(old_handler);
    
    //b32 direct = glXIsDirect(linuxvars.dpy, ctx);
    
    //LOG("Making context current\n");
    glXMakeCurrent(linuxvars.dpy, linuxvars.win, ctx);
    
    //glx_enable_vsync();
    
    // NOTE(allen): Load gl functions
#define GL_FUNC(f,R,P) GLXLOAD(f)
    
#undef GLXLOAD
    
    return true;
}

////////////////////////////

internal void
linux_x11_init(int argc, char** argv, Plat_Settings* settings) {
    
    Display* dpy = XOpenDisplay(0);
    if (!dpy){
        fprintf(stderr, "FATAL: Cannot open X11 Display!\n");
        exit(1);
    }
    
    linuxvars.dpy = dpy;
    
#define LOAD_ATOM(x) linuxvars.atom_##x = XInternAtom(linuxvars.dpy, #x, False);
    
    LOAD_ATOM(TARGETS);
    LOAD_ATOM(CLIPBOARD);
    LOAD_ATOM(UTF8_STRING);
    LOAD_ATOM(_NET_WM_STATE);
    LOAD_ATOM(_NET_WM_STATE_MAXIMIZED_HORZ);
    LOAD_ATOM(_NET_WM_STATE_MAXIMIZED_VERT);
    LOAD_ATOM(_NET_WM_STATE_FULLSCREEN);
    LOAD_ATOM(_NET_WM_PING);
    LOAD_ATOM(_NET_WM_WINDOW_TYPE);
    LOAD_ATOM(_NET_WM_WINDOW_TYPE_NORMAL);
    LOAD_ATOM(_NET_WM_PID);
    LOAD_ATOM(WM_DELETE_WINDOW);
    
#undef LOAD_ATOM
    
    if (!glx_init()){
        system_error_box("Your XServer's GLX version is too old. GLX 1.3+ is required.");
    }
    
    GLXFBConfig fb_config;
    XVisualInfo vi;
    if (!glx_get_config(&fb_config, &vi)){
        system_error_box("Could not get a matching GLX FBConfig. Check your OpenGL drivers are installed correctly.");
    }
    
    // TODO: window size
#define WINDOW_W_DEFAULT 800
#define WINDOW_H_DEFAULT 600
    int w = WINDOW_W_DEFAULT;
    int h = WINDOW_H_DEFAULT;
    
    // TEMP
    render_target.width = w;
    render_target.height = h;
    
    XSetWindowAttributes swa = {};
    swa.backing_store = WhenMapped;
    swa.event_mask = StructureNotifyMask;
    swa.bit_gravity = NorthWestGravity;
    swa.colormap = XCreateColormap(dpy, RootWindow(dpy, vi.screen), vi.visual, AllocNone);
    
    u32 CWflags = CWBackingStore|CWBitGravity|CWBackPixel|CWBorderPixel|CWColormap|CWEventMask;
    linuxvars.win = XCreateWindow(dpy, RootWindow(dpy, vi.screen), 0, 0, w, h, 0, vi.depth, InputOutput, vi.visual, CWflags, &swa);
    
    if (!linuxvars.win){
        system_error_box("XCreateWindow failed. Make sure your display is set up correctly.");
    }
    
    //NOTE(inso): Set the window's type to normal
    XChangeProperty(linuxvars.dpy, linuxvars.win, linuxvars.atom__NET_WM_WINDOW_TYPE, XA_ATOM, 32, PropModeReplace, (unsigned char*)&linuxvars.atom__NET_WM_WINDOW_TYPE_NORMAL, 1);
    
    //NOTE(inso): window managers want the PID as a window property for some reason.
    pid_t pid = getpid();
    XChangeProperty(linuxvars.dpy, linuxvars.win, linuxvars.atom__NET_WM_PID, XA_CARDINAL, 32, PropModeReplace, (unsigned char*)&pid, 1);
    
    //NOTE(inso): set wm properties
    XStoreName(linuxvars.dpy, linuxvars.win, WINDOW_NAME);
    
    XSizeHints *sz_hints = XAllocSizeHints();
    XWMHints   *wm_hints = XAllocWMHints();
    XClassHint *cl_hints = XAllocClassHint();
    
    sz_hints->flags = PMinSize | PMaxSize | PWinGravity;
    
    sz_hints->min_width = 50;
    sz_hints->min_height = 50;
    
    sz_hints->max_width = sz_hints->max_height = (1UL << 16UL);
    sz_hints->win_gravity = NorthWestGravity;
    
    if (settings->set_window_pos){
        sz_hints->flags |= USPosition;
        sz_hints->x = settings->window_x;
        sz_hints->y = settings->window_y;
    }
    
    wm_hints->flags |= InputHint | StateHint;
    wm_hints->input = True;
    wm_hints->initial_state = NormalState;
    
    cl_hints->res_name = "4coder";
    cl_hints->res_class = "4coder";
    
    char* win_name_list[] = { WINDOW_NAME };
    XTextProperty win_name;
    XStringListToTextProperty(win_name_list, 1, &win_name);
    
    XSetWMProperties(linuxvars.dpy, linuxvars.win, &win_name, NULL, argv, argc, sz_hints, wm_hints, cl_hints);
    
    XFree(win_name.value);
    XFree(sz_hints);
    XFree(wm_hints);
    XFree(cl_hints);
    
    linux_set_icon(linuxvars.dpy, linuxvars.win);
    
    // NOTE(inso): make the window visible
    XMapWindow(linuxvars.dpy, linuxvars.win);
    
    if(!glx_create_context(fb_config)) {
        system_error_box("Unable to create GLX context.");
    }
    
    XRaiseWindow(linuxvars.dpy, linuxvars.win);
    
    if (settings->set_window_pos){
        XMoveWindow(linuxvars.dpy, linuxvars.win, settings->window_x, settings->window_y);
    }
    
    if (settings->maximize_window){
        linux_set_wm_state(linuxvars.atom__NET_WM_STATE_MAXIMIZED_HORZ, linuxvars.atom__NET_WM_STATE_MAXIMIZED_VERT, WM_STATE_ADD);
    } else if (settings->fullscreen_window){
        linux_set_wm_state(linuxvars.atom__NET_WM_STATE_FULLSCREEN, 0, WM_STATE_ADD);
    }
    
    XSync(linuxvars.dpy, False);
    
    Atom wm_protos[] = {
        linuxvars.atom_WM_DELETE_WINDOW,
        linuxvars.atom__NET_WM_PING
    };
    
    XSetWMProtocols(linuxvars.dpy, linuxvars.win, wm_protos, 2);
    
    // XFixes extension for clipboard notification.
    {
        int xfixes_version_unused, xfixes_err_unused;
        Bool has_xfixes = XQueryExtension(linuxvars.dpy, "XFIXES", &xfixes_version_unused, &linuxvars.xfixes_selection_event, &xfixes_err_unused);
        linuxvars.has_xfixes = (has_xfixes == True);
        
        // request notifications for CLIPBOARD updates.
        if(has_xfixes) {
            XFixesSelectSelectionInput(linuxvars.dpy, linuxvars.win, linuxvars.atom_CLIPBOARD, XFixesSetSelectionOwnerNotifyMask);
        }
    }
    
    // Input handling init
    
    setlocale(LC_ALL, "");
    XSetLocaleModifiers("");
    b32 locale_supported = XSupportsLocale();
    
    if (!locale_supported){
        setlocale(LC_ALL, "C");
    }
    
    linuxvars.xim = XOpenIM(dpy, 0, 0, 0);
    if (!linuxvars.xim){
        // NOTE(inso): Try falling back to the internal XIM implementation that
        // should in theory always exist.
        XSetLocaleModifiers("@im=none");
        linuxvars.xim = XOpenIM(dpy, 0, 0, 0);
    }
    
    // If it still isn't there we're screwed.
    if (!linuxvars.xim){
        system_error_box("Could not initialize X Input.");
    }
    
    XIMStyles *styles = NULL;
    const XIMStyle style_want = (XIMPreeditNothing | XIMStatusNothing);
    b32 found_style = false;
    
    if (!XGetIMValues(linuxvars.xim, XNQueryInputStyle, &styles, NULL) && styles){
        for (i32 i = 0; i < styles->count_styles; ++i){
            XIMStyle style = styles->supported_styles[i];
            if (style == style_want) {
                found_style = true;
                break;
            }
        }
    }
    
    if(!found_style) {
        system_error_box("Could not find supported X Input style.");
    }
    
    XFree(styles);
    
    linuxvars.xic = XCreateIC(linuxvars.xim,
                              XNInputStyle, style_want,
                              XNClientWindow, linuxvars.win,
                              XNFocusWindow, linuxvars.win,
                              NULL);
    
    if(!linuxvars.xic) {
        system_error_box("Error creating X Input context.");
    }
    
    int xim_event_mask;
    if (XGetICValues(linuxvars.xic, XNFilterEvents, &xim_event_mask, NULL)){
        xim_event_mask = 0;
    }
    
    u32 event_mask = ExposureMask
        | KeyPressMask | KeyReleaseMask
        | ButtonPressMask | ButtonReleaseMask
        | EnterWindowMask | LeaveWindowMask
        | PointerMotionMask
        | FocusChangeMask
        | StructureNotifyMask
        | ExposureMask | VisibilityChangeMask
        | xim_event_mask;
    
    XSelectInput(linuxvars.dpy, linuxvars.win, event_mask);
    
    // init XKB keyboard extension
    
    if(!XkbQueryExtension(linuxvars.dpy, 0, &linuxvars.xkb_event, 0, 0, 0)) {
        system_error_box("XKB Extension not available.");
    }
    
    XkbSelectEvents(linuxvars.dpy, XkbUseCoreKbd, XkbAllEventsMask, XkbAllEventsMask);
    linuxvars.xkb = XkbGetMap(linuxvars.dpy, XkbKeyTypesMask | XkbKeySymsMask, XkbUseCoreKbd);
    if(!linuxvars.xkb) {
        system_error_box("Error getting XKB keyboard map.");
    }
    
    if(XkbGetNames(linuxvars.dpy, XkbKeyNamesMask, linuxvars.xkb) != Success) {
        system_error_box("Error getting XKB key names.");
    }
    
    // closer to windows behaviour (holding key doesn't generate release events)
    XkbSetDetectableAutoRepeat(linuxvars.dpy, True, NULL);
    
    XCursor cursors[APP_MOUSE_CURSOR_COUNT] = {
        None,
        None,
        XCreateFontCursor(linuxvars.dpy, XC_xterm),
        XCreateFontCursor(linuxvars.dpy, XC_sb_h_double_arrow),
        XCreateFontCursor(linuxvars.dpy, XC_sb_v_double_arrow)
    };
    block_copy(linuxvars.xcursors, cursors, sizeof(cursors));
    
    // sneaky invisible cursor
    {
        char data = 0;
        XColor c  = {};
        Pixmap p  = XCreateBitmapFromData(linuxvars.dpy, linuxvars.win, &data, 1, 1);
        
        linuxvars.hidden_cursor = XCreatePixmapCursor(linuxvars.dpy, p, p, &c, &c, 0, 0);
        
        XFreePixmap(linuxvars.dpy, p);
    }
}

global Key_Code keycode_lookup_table_physical[255];
global Key_Code keycode_lookup_table_language[255];

struct SymCode {
    KeySym sym;
    Key_Code code;
};

internal void
linux_keycode_init_common(Display* dpy, Key_Code* keycode_lookup_table, SymCode* sym_table, SymCode* p, size_t sym_table_size){
    
    *p++ = { XK_space, KeyCode_Space };
    *p++ = { XK_Tab, KeyCode_Tab };
    *p++ = { XK_Escape, KeyCode_Escape };
    *p++ = { XK_Pause, KeyCode_Pause };
    *p++ = { XK_Up, KeyCode_Up };
    *p++ = { XK_Down, KeyCode_Down };
    *p++ = { XK_Left, KeyCode_Left };
    *p++ = { XK_Right, KeyCode_Right };
    *p++ = { XK_BackSpace, KeyCode_Backspace };
    *p++ = { XK_Return, KeyCode_Return };
    *p++ = { XK_Delete, KeyCode_Delete };
    *p++ = { XK_Insert, KeyCode_Insert };
    *p++ = { XK_Home, KeyCode_Home };
    *p++ = { XK_End, KeyCode_End };
    *p++ = { XK_Page_Up, KeyCode_PageUp };
    *p++ = { XK_Page_Down, KeyCode_PageDown };
    *p++ = { XK_Caps_Lock, KeyCode_CapsLock };
    *p++ = { XK_Num_Lock, KeyCode_NumLock };
    *p++ = { XK_Scroll_Lock, KeyCode_ScrollLock };
    *p++ = { XK_Menu, KeyCode_Menu };
    *p++ = { XK_Shift_L, KeyCode_Shift };
    *p++ = { XK_Shift_R, KeyCode_Shift };
    *p++ = { XK_Control_L, KeyCode_Control };
    *p++ = { XK_Control_R, KeyCode_Control };
    *p++ = { XK_Alt_L, KeyCode_Alt };
    *p++ = { XK_Alt_R, KeyCode_Alt };
    *p++ = { XK_Super_L, KeyCode_Command };
    *p++ = { XK_Super_R, KeyCode_Command };
    
    for (Key_Code k = KeyCode_F1; k <= KeyCode_F24; ++k){
        *p++ = { XK_F1 + (k - KeyCode_F1), k };
    }
    
    for (Key_Code k = KeyCode_NumPad0; k <= KeyCode_NumPad9; ++k){
        *p++ = { XK_KP_0 + (k - KeyCode_NumPad0), k };
    }
    
    *p++ = { XK_KP_Multiply, KeyCode_NumPadStar };
    *p++ = { XK_KP_Add, KeyCode_NumPadPlus };
    *p++ = { XK_KP_Subtract, KeyCode_NumPadMinus };
    *p++ = { XK_KP_Decimal, KeyCode_NumPadDot };
    *p++ = { XK_KP_Delete, KeyCode_NumPadDot }; // seems to take precedence over Decimal...
    *p++ = { XK_KP_Divide, KeyCode_NumPadSlash };
    *p++ = { XK_KP_Enter, KeyCode_Return }; // NumPadEnter?
    
    const int table_size = p - sym_table;
    Assert(table_size < sym_table_size);
    
    Key_Code next_extra = KeyCode_Ex1;
    const Key_Code max_extra = KeyCode_Ex29;
    
    for(int i = XkbMinLegalKeyCode; i <= XkbMaxLegalKeyCode; ++i) {
        KeySym sym = NoSymbol;
        
        // lookup key in current layout with no modifiers held (0)
        if(!XkbTranslateKeyCode(linuxvars.xkb, i, XkbBuildCoreState(0, linuxvars.xkb_group), NULL, &sym)) {
            continue;
        }
        
        int j;
        for(j = 0; j < table_size; ++j) {
            if(sym_table[j].sym == sym) {
                keycode_lookup_table[i] = sym_table[j].code;
                //printf("lookup %s = %d\n", key_code_name[sym_table[j].code], i);
                break;
            }
        }
        
        if(j != table_size){
            continue;
        }
        
        // nothing found - try with shift held (needed for e.g. belgian numbers to bind).
        KeySym shift_sym = NoSymbol;
        
        if(!XkbTranslateKeyCode(linuxvars.xkb, i, XkbBuildCoreState(ShiftMask, linuxvars.xkb_group), NULL, &shift_sym)) {
            continue;
        }
        
        for(j = 0; j < table_size; ++j) {
            if(sym_table[j].sym == shift_sym) {
                keycode_lookup_table[i] = sym_table[j].code;
                //printf("lookup %s = %d\n", key_code_name[sym_table[j].code], i);
                break;
            }
        }
        
        // something unknown bound, put it in extra
        if(j == table_size && sym != NoSymbol && next_extra <= max_extra && keycode_lookup_table[i] == 0) {
            keycode_lookup_table[i] = next_extra++;
        }
    }
    
}

internal void
linux_keycode_init_language(Display* dpy, Key_Code* keycode_lookup_table){
    SymCode sym_table[300];
    SymCode* p = sym_table;
    
    for(unsigned int i = 0; i < 26; ++i) {
        *p++ = { XK_a + i, KeyCode_A + i};
    }
    
    for(unsigned int i = 0; i < 26; ++i) {
        *p++ = { XK_A + i, KeyCode_A + i};
    }
    
    for(unsigned int i = 0; i <= 9; ++i) {
        *p++ = { XK_0 + i, KeyCode_0 + i};
    }
    
    *p++ = { XK_grave, KeyCode_Tick };
    *p++ = { XK_minus, KeyCode_Minus };
    *p++ = { XK_equal, KeyCode_Equal };
    *p++ = { XK_bracketleft, KeyCode_LeftBracket };
    *p++ = { XK_bracketright, KeyCode_RightBracket };
    *p++ = { XK_semicolon, KeyCode_Semicolon };
    *p++ = { XK_apostrophe, KeyCode_Quote };
    *p++ = { XK_comma, KeyCode_Comma };
    *p++ = { XK_period, KeyCode_Period };
    *p++ = { XK_slash, KeyCode_ForwardSlash };
    *p++ = { XK_backslash, KeyCode_BackwardSlash };
    
    linux_keycode_init_common(dpy, keycode_lookup_table, sym_table, p, ArrayCount(sym_table));
}

internal void
linux_keycode_init_physical(Display* dpy, Key_Code* keycode_lookup_table){
    
    // Find common keys by their key label
    SymCode sym_table[100];
    linux_keycode_init_common(dpy, keycode_lookup_table, sym_table, sym_table, ArrayCount(sym_table));
    
    // Find these keys by physical position, and map to QWERTY KeyCodes
#define K(k) glue(KeyCode_, k)
    static const u8 positional_keys[] = {
        K(1), K(2), K(3), K(4), K(5), K(6), K(7), K(8), K(9), K(0), K(Minus), K(Equal),
        K(Q), K(W), K(E), K(R), K(T), K(Y), K(U), K(I), K(O), K(P), K(LeftBracket), K(RightBracket),
        K(A), K(S), K(D), K(F), K(G), K(H), K(J), K(K), K(L), K(Semicolon), K(Quote), /*uk hash*/0,
        K(Z), K(X), K(C), K(V), K(B), K(N), K(M), K(Comma), K(Period), K(ForwardSlash), 0, 0
    };
#undef K
    
    // XKB gives the alphanumeric keys names like AE01 -> E is the row (from B-E), 01 is the column (01-12).
    // to get key names in .ps file: setxkbmap -print | xkbcomp - - | xkbprint -label name - out.ps
    
    static const int ncols = 12;
    static const int nrows = 4;
    
    for(int i = XkbMinLegalKeyCode; i <= XkbMaxLegalKeyCode; ++i) {
        const char* name = linuxvars.xkb->names->keys[i].name;
        
        // alphanumeric keys
        
        if(name[0] == 'A' && name[1] >= 'B' && name[1] <= 'E') {
            int row = (nrows - 1) - (name[1] - 'B');
            int col = (name[2] - '0') * 10 + (name[3] - '0') - 1;
            
            if(row >= 0 && row < nrows && col >= 0 && col < ncols) {
                keycode_lookup_table[i] = positional_keys[row * ncols + col];
            }
        }
        
        // numpad
        
        else if(name[0] == 'K' && name[1] == 'P' && name[2] >= '0' && name[2] <= '9' && !name[3]) {
            
            // don't overwrite - for e.g. laptops with numpad keys embedded in the normal ones, toggling with numlock
            if(keycode_lookup_table[i] == 0) {
                keycode_lookup_table[i] = KeyCode_NumPad0 + name[2] - '0';
            }
        }
        
        // a few special cases:
        
        else if(memcmp(name, "TLDE", XkbKeyNameLength) == 0) {
            keycode_lookup_table[i] = KeyCode_Tick;
        } else if(memcmp(name, "BKSL", XkbKeyNameLength) == 0) {
            keycode_lookup_table[i] = KeyCode_BackwardSlash;
        } else if(memcmp(name, "LSGT", XkbKeyNameLength) == 0) {
            // UK extra key between left shift and Z
            // it prints \ and | with shift. KeyCode_Backslash will be where UK # is.
            keycode_lookup_table[i] = KeyCode_Ex0;
        }
    }
}

internal void
linux_keycode_init(Display* dpy){
    block_zero_array(keycode_lookup_table_physical);
    block_zero_array(keycode_lookup_table_language);
    
    linux_keycode_init_physical(dpy, keycode_lookup_table_physical);
    linux_keycode_init_language(dpy, keycode_lookup_table_language);
}

internal void
linux_epoll_init(void) {
    struct epoll_event e = {};
    e.events = EPOLLIN | EPOLLET;
    
    linuxvars.step_timer_fd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK);
    linuxvars.epoll = epoll_create(16);
    
    e.data.ptr = &epoll_tag_x11;
    epoll_ctl(linuxvars.epoll, EPOLL_CTL_ADD, ConnectionNumber(linuxvars.dpy), &e);
    
    e.data.ptr = &epoll_tag_step_timer;
    epoll_ctl(linuxvars.epoll, EPOLL_CTL_ADD, linuxvars.step_timer_fd, &e);
}

internal void
linux_clipboard_send(XSelectionRequestEvent* req) {
    
    XSelectionEvent rsp = {};
    rsp.type = SelectionNotify;
    rsp.requestor = req->requestor;
    rsp.selection = req->selection;
    rsp.target = req->target;
    rsp.time = req->time;
    rsp.property = None;
    
    Atom formats[] = {
        linuxvars.atom_UTF8_STRING,
        XA_STRING,
    };
    
    if(linuxvars.clipboard_contents.size == 0) {
        goto done;
    }
    
    if(req->selection != linuxvars.atom_CLIPBOARD || req->property == None) {
        goto done;
    }
    
    if (req->target == linuxvars.atom_TARGETS){
        
        XChangeProperty(
                        req->display,
                        req->requestor,
                        req->property,
                        XA_ATOM,
                        32,
                        PropModeReplace,
                        (u8*)formats,
                        ArrayCount(formats));
        
        rsp.property = req->property;
        
    } else {
        
        int i;
        for(i = 0; i < ArrayCount(formats); ++i){
            if (req->target == formats[i]){
                break;
            }
        }
        
        if (i != ArrayCount(formats)){
            XChangeProperty(
                            req->display,
                            req->requestor,
                            req->property,
                            req->target,
                            8,
                            PropModeReplace,
                            linuxvars.clipboard_contents.str,
                            linuxvars.clipboard_contents.size
                            );
            
            rsp.property = req->property;
        }
    }
    
    done:
    XSendEvent(req->display, req->requestor, True, 0, (XEvent*)&rsp);
}

internal String_Const_u8
linux_clipboard_recv(Arena *arena){
    Atom type;
    int fmt;
    unsigned long nitems;
    unsigned long bytes_left;
    u8 *data;
    
    int result = XGetWindowProperty(linuxvars.dpy,
                                    linuxvars.win,
                                    linuxvars.atom_CLIPBOARD,
                                    0L, 0x20000000L, False,
                                    linuxvars.atom_UTF8_STRING,
                                    &type, &fmt, &nitems,
                                    &bytes_left, &data);
    
    String_Const_u8 clip = {};
    if(result == Success && fmt == 8){
        clip= push_string_copy(arena, SCu8(data, nitems));
        XFree(data);
        XDeleteProperty(linuxvars.dpy, linuxvars.win, linuxvars.atom_CLIPBOARD);
    }
    
    return(clip);
}

internal void
linux_clipboard_recv(XSelectionEvent* ev) {
    
    if(ev->selection != linuxvars.atom_CLIPBOARD ||
       ev->target != linuxvars.atom_UTF8_STRING ||
       ev->property == None) {
        return;
    }
    
    Scratch_Block scratch(&linuxvars.tctx);
    String_Const_u8 clip = linux_clipboard_recv(scratch);
    if (clip.size > 0){
        linalloc_clear(&linuxvars.clipboard_arena);
        linuxvars.clipboard_contents = push_string_copy(&linuxvars.clipboard_arena, clip);
        linuxvars.received_new_clipboard = true;
        linux_schedule_step();
    }
}

internal
system_get_clipboard_sig(){
    // TODO(inso): index?
    return(push_string_copy(arena, linuxvars.clipboard_contents));
}

internal void
system_post_clipboard(String_Const_u8 str, i32 index){
    // TODO(inso): index?
    //LINUX_FN_DEBUG("%.*s", string_expand(str));
    linalloc_clear(&linuxvars.clipboard_arena);
    linuxvars.clipboard_contents = push_u8_stringf(&linuxvars.clipboard_arena, "%.*s", string_expand(str));
    XSetSelectionOwner(linuxvars.dpy, linuxvars.atom_CLIPBOARD, linuxvars.win, CurrentTime);
}

internal void
system_set_clipboard_catch_all(b32 enabled){
    LINUX_FN_DEBUG("%d", enabled);
    linuxvars.clipboard_catch_all = !!enabled;
}

internal b32
system_get_clipboard_catch_all(void){
    return linuxvars.clipboard_catch_all;
}

internal String_Const_u8
linux_filter_text(Arena* arena, u8* buf, int len) {
    u8* const result = push_array(arena, u8, len);
    u8* outp = result;
    
    for(int i = 0; i < len; ++i) {
        u8 c = buf[i];
        
        if(c == '\r') {
            *outp++ = '\n';
        } else if(c > 127 || (' ' <= c && c <= '~') || c == '\t') {
            *outp++ = c;
        }
    }
    
    return SCu8(result, outp - result);
}

internal KeyCode
linux_numlock_convert(KeyCode in){
    static const KeyCode lookup[] = {
        KeyCode_Insert,
        KeyCode_End,
        KeyCode_Down,
        KeyCode_PageDown,
        KeyCode_Left,
        0,
        KeyCode_Right,
        KeyCode_Home,
        KeyCode_Up,
        KeyCode_PageUp,
        0, 0, 0,
        KeyCode_Delete,
    };
    
    if(in >= KeyCode_NumPad0 && in <= KeyCode_NumPadDot) {
        KeyCode ret = lookup[in - KeyCode_NumPad0];
        if(ret != 0) {
            return ret;
        }
    }
    
    return in;
}

internal void
linux_handle_x11_events() {
    static XEvent prev_event = {};
    b32 should_step = false;
    
    while (XPending(linuxvars.dpy)) {
        XEvent event;
        XNextEvent(linuxvars.dpy, &event);
        
        b32 filtered = false;
        if (XFilterEvent(&event, None) == True){
            filtered = true;
            if(event.type != KeyPress && event.type != KeyRelease) {
                continue;
            }
        }
        
        u64 event_id = (u64)event.xkey.serial << 32 | event.xkey.time;
        
        switch(event.type) {
            case KeyPress: {
                should_step = true;
                
                Input_Modifier_Set_Fixed* mods = &linuxvars.input.pers.modifiers;
                
                int state = event.xkey.state;
                set_modifier(mods, KeyCode_Shift, state & ShiftMask);
                set_modifier(mods, KeyCode_Control, state & ControlMask);
                set_modifier(mods, KeyCode_CapsLock, state & LockMask);
                set_modifier(mods, KeyCode_Alt, state & Mod1Mask);
                
                event.xkey.state &= ~(ControlMask);
                
                Status status;
                KeySym keysym = NoSymbol;
                u8 buf[256] = {};
                
                int len = Xutf8LookupString(linuxvars.xic, &event.xkey, (char*)buf, sizeof(buf) - 1, &keysym, &status);
                
                if (status == XBufferOverflow){
                    Xutf8ResetIC(linuxvars.xic);
                    XSetICFocus(linuxvars.xic);
                }
                
                if (keysym == XK_ISO_Left_Tab){
                    add_modifier(mods, KeyCode_Shift);
                }
                
                Key_Code key;
                if(linuxvars.key_mode == KeyMode_Physical) {
                    key = keycode_lookup_table_physical[(u8)event.xkey.keycode];
                } else {
                    key = keycode_lookup_table_language[(u8)event.xkey.keycode];
                }
                
                if(!(state & Mod2Mask)) {
                    key = linux_numlock_convert(key);
                }
                
                //printf("key %d = %s (f:%d)\n", event.xkey.keycode, key_code_name[key], filtered);
                
                b32 is_dead = false;
                if (keysym >= XK_dead_grave && keysym <= XK_dead_greek && len == 0) {
                    is_dead = true;
                }
                
                if(!is_dead && filtered) {
                    linuxvars.prev_filtered_key = key;
                    break;
                }
                
                // send a keycode for the key after the dead key
                if(!key && linuxvars.prev_filtered_key) {
                    key = linuxvars.prev_filtered_key;
                    linuxvars.prev_filtered_key = 0;
                }
                
                Input_Event* key_event = NULL;
                if(key) {
                    add_modifier(mods, key);
                    // printf(" push key %d\n", key);
                    
                    key_event = push_input_event(&linuxvars.frame_arena, &linuxvars.input.trans.event_list);
                    key_event->kind = InputEventKind_KeyStroke;
                    key_event->key.code = key;
                    key_event->key.modifiers = copy_modifier_set(&linuxvars.frame_arena, mods);
                    key_event->key.flags = 0;
                    if (is_dead){
                        key_event->key.flags |= KeyFlag_IsDeadKey;
                    }
                }
                
                Input_Event* text_event = NULL;
                if(status == XLookupChars || status == XLookupBoth) {
                    String_Const_u8 str = linux_filter_text(&linuxvars.frame_arena, buf, len);
                    if(str.size) {
                        // printf(" push txt %d\n", key);
                        text_event = push_input_event(&linuxvars.frame_arena, &linuxvars.input.trans.event_list);
                        text_event->kind = InputEventKind_TextInsert;
                        text_event->text.string = str;
                    }
                }
                
                if(key_event && text_event) {
                    key_event->key.first_dependent_text = text_event;
                }
            } break;
            
            case KeyRelease: {
                should_step = true;
                
                Input_Modifier_Set_Fixed* mods = &linuxvars.input.pers.modifiers;
                
                int state = event.xkey.state;
                set_modifier(mods, KeyCode_Shift, state & ShiftMask);
                set_modifier(mods, KeyCode_Control, state & ControlMask);
                set_modifier(mods, KeyCode_CapsLock, state & LockMask);
                set_modifier(mods, KeyCode_Alt, state & Mod1Mask);
                
                Key_Code key;
                if(linuxvars.key_mode == KeyMode_Physical) {
                    key = keycode_lookup_table_physical[(u8)event.xkey.keycode];
                } else {
                    key = keycode_lookup_table_language[(u8)event.xkey.keycode];
                }
                
                // num lock off -> convert KP keys to Insert, Home, End etc.
                if(!(state & Mod2Mask)) {
                    key = linux_numlock_convert(key);
                }
                
                Input_Event* key_event = NULL;
                if(key) {
                    remove_modifier(mods, key);
                    key_event = push_input_event(&linuxvars.frame_arena, &linuxvars.input.trans.event_list);
                    key_event->kind = InputEventKind_KeyRelease;
                    key_event->key.code = key;
                    key_event->key.modifiers = copy_modifier_set(&linuxvars.frame_arena, mods);
                }
            } break;
            
            case MotionNotify: {
                int x = clamp(0, event.xmotion.x, render_target.width - 1);
                int y = clamp(0, event.xmotion.y, render_target.height - 1);
                linuxvars.input.pers.mouse = { x, y };
                should_step = true;
            } break;
            
            case ButtonPress: {
                should_step = true;
                switch(event.xbutton.button) {
                    case Button1: {
                        linuxvars.input.trans.mouse_l_press = true;
                        linuxvars.input.pers.mouse_l = true;
                        
                        // NOTE(inso): improves selection dragging (especially in notepad-like mode).
                        // we will still get mouse events when the pointer leaves the window if it's dragging.
                        XGrabPointer(
                                     linuxvars.dpy,
                                     linuxvars.win,
                                     True, PointerMotionMask | ButtonPressMask | ButtonReleaseMask,
                                     GrabModeAsync, GrabModeAsync,
                                     None, None, CurrentTime);
                        
                    } break;
                    
                    case Button3: {
                        linuxvars.input.trans.mouse_r_press = true;
                        linuxvars.input.pers.mouse_r = true;
                    } break;
                    
                    case Button4: {
                        linuxvars.input.trans.mouse_wheel = -100;
                    } break;
                    
                    case Button5: {
                        linuxvars.input.trans.mouse_wheel = +100;
                    } break;
                }
            } break;
            
            case ButtonRelease: {
                should_step = true;
                switch(event.xbutton.button) {
                    case Button1: {
                        linuxvars.input.trans.mouse_l_release = true;
                        linuxvars.input.pers.mouse_l = false;
                        
                        XUngrabPointer(linuxvars.dpy, CurrentTime);
                    } break;
                    
                    case Button3: {
                        linuxvars.input.trans.mouse_r_release = true;
                        linuxvars.input.pers.mouse_r = false;
                    } break;
                }
            } break;
            
            case FocusIn:
            case FocusOut: {
                linuxvars.input.pers.mouse_l = false;
                linuxvars.input.pers.mouse_r = false;
                block_zero_struct(&linuxvars.input.pers.modifiers);
            } break;
            
            case EnterNotify: {
                linuxvars.input.pers.mouse_out_of_window = 0;
            } break;
            
            case LeaveNotify: {
                linuxvars.input.pers.mouse_out_of_window = 1;
            } break;
            
            case ConfigureNotify: {
                i32 w = event.xconfigure.width;
                i32 h = event.xconfigure.height;
                
                if (w != render_target.width || h != render_target.height){
                    should_step = true;
                    render_target.width = w;
                    render_target.height = h;
                }
            } break;
            
            case ClientMessage: {
                Atom atom = event.xclient.data.l[0];
                
                // Window X button clicked
                if(atom == linuxvars.atom_WM_DELETE_WINDOW) {
                    should_step = true;
                    linuxvars.input.trans.trying_to_kill = true;
                }
                
                // Notify WM that we're still responding (don't grey our window out).
                else if(atom == linuxvars.atom__NET_WM_PING) {
                    event.xclient.window = DefaultRootWindow(linuxvars.dpy);
                    XSendEvent(linuxvars.dpy,
                               event.xclient.window,
                               False,
                               SubstructureRedirectMask | SubstructureNotifyMask,
                               &event);
                }
            } break;
            
            case SelectionRequest: {
                linux_clipboard_send((XSelectionRequestEvent*)&event);
            } break;
            
            case SelectionNotify: {
                linux_clipboard_recv((XSelectionEvent*)&event);
            } break;
            
            case SelectionClear: {
                if(event.xselectionclear.selection == linuxvars.atom_CLIPBOARD) {
                    linalloc_clear(&linuxvars.clipboard_arena);
                    block_zero_struct(&linuxvars.clipboard_contents);
                }
            } break;
            
            case Expose:
            case VisibilityNotify: {
                should_step = true;
            } break;
            
            default: {
                // clipboard update notification - ask for the new content
                if (event.type == linuxvars.xfixes_selection_event) {
                    XFixesSelectionNotifyEvent* sne = (XFixesSelectionNotifyEvent*)&event;
                    if (sne->subtype == XFixesSelectionNotify && sne->owner != linuxvars.win){
                        XConvertSelection(linuxvars.dpy,
                                          linuxvars.atom_CLIPBOARD,
                                          linuxvars.atom_UTF8_STRING,
                                          linuxvars.atom_CLIPBOARD,
                                          linuxvars.win,
                                          CurrentTime);
                    }
                }
                
                else if(event.type == linuxvars.xkb_event) {
                    XkbEvent* kb = (XkbEvent*)&event;
                    
                    // Keyboard layout changed, refresh lookup table.
                    if(kb->any.xkb_type == XkbStateNotify && kb->state.group != linuxvars.xkb_group) {
                        linuxvars.xkb_group = kb->state.group;
                        XkbRefreshKeyboardMapping((XkbMapNotifyEvent*)kb);
                        linux_keycode_init(linuxvars.dpy);
                    }
                }
            } break;
        }
    }
    
    if(should_step) {
        linux_schedule_step();
    }
}

internal b32
linux_epoll_process(struct epoll_event* events, int num_events) {
    b32 do_step = false;
    
    for (int i = 0; i < num_events; ++i){
        struct epoll_event* ev = events + i;
        Epoll_Kind* tag = (Epoll_Kind*)ev->data.ptr;
        
        switch (*tag){
            case EPOLL_X11: {
                linux_handle_x11_events();
            } break;
            
            case EPOLL_X11_INTERNAL: {
                //XProcessInternalConnection(linuxvars.dpy, fd);
            } break;
            
            case EPOLL_STEP_TIMER: {
                u64 count;
                int ret;
                do {
                    ret = read(linuxvars.step_timer_fd, &count, 8);
                } while (ret != -1 || errno != EAGAIN);
                do_step = true;
            } break;
            
            case EPOLL_CLI_PIPE: {
                linux_schedule_step();
            } break;
            
            case EPOLL_USER_TIMER: {
                Linux_Object* obj = CastFromMember(Linux_Object, timer.epoll_tag, tag);
                close(obj->timer.fd);
                obj->timer.fd = -1;
                linux_schedule_step();
            } break;
        }
    }
    
    return do_step;
}

int
main(int argc, char **argv){
    // NOTE(allen): fucking bullshit. someone get my shit togeth :(er
    
    for (i32 i = 0; i < argc; i += 1){
        String_Const_u8 arg = SCu8(argv[i]);
        if (string_match(arg, str8_lit("-L"))){
            log_os_enabled = true;
        }
    }
    
    // NOTE(allen): All of This thing
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
    pthread_mutex_init(&linuxvars.memory_tracker_mutex, &attr);
    
    pthread_mutex_init(&linuxvars.audio_mutex, &attr);
    pthread_cond_init(&linuxvars.audio_cond, NULL);
    
    // NOTE(allen): context setup
    {
        Base_Allocator* alloc = get_base_allocator_system();
        thread_ctx_init(&linuxvars.tctx, ThreadKind_Main, alloc, alloc);
    }
    
    API_VTable_system system_vtable = {};
    system_api_fill_vtable(&system_vtable);
    
    API_VTable_graphics graphics_vtable = {};
    graphics_api_fill_vtable(&graphics_vtable);
    
    API_VTable_font font_vtable = {};
    font_api_fill_vtable(&font_vtable);
    
    // NOTE(allen): memory
    linuxvars.frame_arena = make_arena_system();
    linuxvars.clipboard_arena = make_arena_system();
    render_target.arena = make_arena_system(KB(256));
    
    //linuxvars.fontconfig = FcInitLoadConfigAndFonts();
    
    linuxvars.cursor_show = MouseCursorShow_Always;
    linuxvars.prev_cursor_show = MouseCursorShow_Always;
    
    dll_init_sentinel(&linuxvars.free_linux_objects);
    dll_init_sentinel(&linuxvars.timer_objects);
    
    //InitializeCriticalSection(&win32vars.thread_launch_mutex);
    //InitializeConditionVariable(&win32vars.thread_launch_cv);
    
    linuxvars.clipboard_catch_all = false;
    
    // NOTE(allen): load core
    System_Library core_library = {};
    App_Functions app = {};
    {
        App_Get_Functions *get_funcs = 0;
        Scratch_Block scratch(&linuxvars.tctx);
        List_String_Const_u8 search_list = {};
        def_search_list_add_system_path(scratch, &search_list, SystemPath_Binary);
        
        String_Const_u8 core_path = def_search_get_full_path(scratch, &search_list, SCu8("4ed_app.so"));
        if (system_load_library(scratch, core_path, &core_library)){
            get_funcs = (App_Get_Functions*)system_get_proc(core_library, "app_get_functions");
            if (get_funcs != 0){
                app = get_funcs();
            }
            else{
                char msg[] = "Failed to get application code from '4ed_app.so'.";
                system_error_box(msg);
            }
        }
        else{
            char msg[] = "Could not load '4ed_app.so'. This file should be in the same directory as the main '4ed' executable.";
            system_error_box(msg);
        }
    }
    
    // NOTE(allen): send system vtable to core
    app.load_vtables(&system_vtable, &font_vtable, &graphics_vtable);
    // get_logger calls log_init which is needed.
    //app.get_logger();
    linuxvars.log_string = app.get_logger();
    
    // NOTE(allen): init & command line parameters
    Plat_Settings plat_settings = {};
    void *base_ptr = 0;
    {
        Scratch_Block scratch(&linuxvars.tctx);
        String_Const_u8 curdir = system_get_path(scratch, SystemPath_CurrentDirectory);
        
        char **files = 0;
        i32 *file_count = 0;
        base_ptr = app.read_command_line(&linuxvars.tctx, curdir, &plat_settings, &files, &file_count, argc, argv);
        /* TODO(inso): what is this doing?
        {
            i32 end = *file_count;
            i32 i = 0, j = 0;
            for (; i < end; ++i){
                if (system_file_can_be_made(scratch, (u8*)files[i])){
                    files[j] = files[i];
                    ++j;
                }
            }
            *file_count = j;
        }*/
    }
    
    // NOTE(allen): setup user directory override
    if (plat_settings.user_directory != 0){
        lnx_override_user_directory = plat_settings.user_directory;
    }
    
    // NOTE(allen): load custom layer
    System_Library custom_library = {};
    Custom_API custom = {};
    {
        char custom_not_found_msg[] = "Did not find a library for the custom layer.";
        char custom_fail_load_msg[] = "Failed to load custom code due to missing version information.  Try rebuilding with buildsuper.";
        char custom_fail_version_msg[] = "Failed to load custom code due to a version mismatch.  Try rebuilding with buildsuper.";
        char custom_fail_init_apis[] = "Failed to load custom code due to missing 'init_apis' symbol.  Try rebuilding with buildsuper";
        
        Scratch_Block scratch(&linuxvars.tctx);
        String_Const_u8 default_file_name = string_u8_litexpr("custom_4coder.so");
        List_String_Const_u8 search_list = {};
        def_search_list_add_system_path(scratch, &search_list, SystemPath_UserDirectory);
        def_search_list_add_system_path(scratch, &search_list, SystemPath_Binary);
        String_Const_u8 custom_file_names[2] = {};
        i32 custom_file_count = 1;
        if (plat_settings.custom_dll != 0){
            custom_file_names[0] = SCu8(plat_settings.custom_dll);
            if (!plat_settings.custom_dll_is_strict){
                custom_file_names[1] = default_file_name;
                custom_file_count += 1;
            }
        }
        else{
            custom_file_names[0] = default_file_name;
        }
        String_Const_u8 custom_file_name = {};
        for (i32 i = 0; i < custom_file_count; i += 1){
            custom_file_name = def_search_get_full_path(scratch, &search_list, custom_file_names[i]);
            if (custom_file_name.size > 0){
                break;
            }
        }
        b32 has_library = false;
        if (custom_file_name.size > 0){
            if (system_load_library(scratch, custom_file_name, &custom_library)){
                has_library = true;
            }
        }
        
        if (!has_library){
            system_error_box(custom_not_found_msg);
        }
        custom.get_version = (_Get_Version_Type*)system_get_proc(custom_library, "get_version");
        if (custom.get_version == 0){
            system_error_box(custom_fail_load_msg);
        }
        else if (custom.get_version(MAJOR, MINOR, PATCH) == 0){
            system_error_box(custom_fail_version_msg);
        }
        custom.init_apis = (_Init_APIs_Type*)system_get_proc(custom_library, "init_apis");
        if (custom.init_apis == 0){
            system_error_box(custom_fail_init_apis);
        }
    }
    
    linux_x11_init(argc, argv, &plat_settings);
    linux_keycode_init(linuxvars.dpy);
    linux_epoll_init();
    
    linuxvars.audio_thread = system_thread_launch(&linux_audio_main, NULL);
    
    
    // app init
    {
        Scratch_Block scratch(&linuxvars.tctx);
        String_Const_u8 curdir = system_get_path(scratch, SystemPath_CurrentDirectory);
        app.init(&linuxvars.tctx, &render_target, base_ptr, curdir, custom);
    }
    
    linuxvars.global_frame_mutex = system_mutex_make();
    system_mutex_acquire(linuxvars.global_frame_mutex);
    
    linux_schedule_step();
    b32 first_step = true;
    u64 timer_start = system_now_time();
    
    for (;;) {
        
        if (XEventsQueued(linuxvars.dpy, QueuedAlready)){
            linux_handle_x11_events();
        }
        
        system_mutex_release(linuxvars.global_frame_mutex);
        
        struct epoll_event events[16];
        int num_events = epoll_wait(linuxvars.epoll, events, ArrayCount(events), -1);
        
        system_mutex_acquire(linuxvars.global_frame_mutex);
        
        if (num_events == -1){
            if (errno != EINTR){
                perror("epoll_wait");
                //LOG("epoll_wait\n");
            }
            continue;
        }
        
        if(!linux_epoll_process(events, num_events)) {
            continue;
        }
        
        linuxvars.last_step_time = system_now_time();
        
        // NOTE(allen): Frame Clipboard Input
        // Request clipboard contents from X11 on first step, or every step if they don't have XFixes notification ability.
        if (first_step || (!linuxvars.has_xfixes && linuxvars.clipboard_catch_all)){
            XConvertSelection(linuxvars.dpy, linuxvars.atom_CLIPBOARD, linuxvars.atom_UTF8_STRING, linuxvars.atom_CLIPBOARD, linuxvars.win, CurrentTime);
        }
        
        Application_Step_Input input = {};
        
        if (linuxvars.received_new_clipboard && linuxvars.clipboard_catch_all){
            input.clipboard = linuxvars.clipboard_contents;
        }
        linuxvars.received_new_clipboard = false;
        
        input.first_step = first_step;
        input.dt = frame_useconds/1000000.f; // variable?
        input.events = linuxvars.input.trans.event_list;
        input.trying_to_kill = linuxvars.input.trans.trying_to_kill;
        
        input.mouse.out_of_window = linuxvars.input.pers.mouse_out_of_window;
        input.mouse.p = linuxvars.input.pers.mouse;
        input.mouse.l = linuxvars.input.pers.mouse_l;
        input.mouse.r = linuxvars.input.pers.mouse_r;
        input.mouse.press_l = linuxvars.input.trans.mouse_l_press;
        input.mouse.release_l = linuxvars.input.trans.mouse_l_release;
        input.mouse.press_r = linuxvars.input.trans.mouse_r_press;
        input.mouse.release_r = linuxvars.input.trans.mouse_r_release;
        input.mouse.wheel = linuxvars.input.trans.mouse_wheel;
        
        // NOTE(allen): Application Core Update
        Application_Step_Result result = {};
        if (app.step != 0){
            result = app.step(&linuxvars.tctx, &render_target, base_ptr, &input);
        }
        
        // NOTE(allen): Finish the Loop
        if (result.perform_kill){
            break;
        }
        
        // NOTE(NAME): Switch to New Title
        if (result.has_new_title){
            XStoreName(linuxvars.dpy, linuxvars.win, result.title_string);
        }
        
        // NOTE(allen): Switch to New Cursor
        if (result.mouse_cursor_type != linuxvars.cursor && !linuxvars.input.pers.mouse_l){
            XCursor c = linuxvars.xcursors[result.mouse_cursor_type];
            if (linuxvars.cursor_show){
                XDefineCursor(linuxvars.dpy, linuxvars.win, c);
            }
            linuxvars.cursor = result.mouse_cursor_type;
        }
        
        gl_render(&render_target);
        glXSwapBuffers(linuxvars.dpy, linuxvars.win);
        
        // TODO(allen): don't let the screen size change until HERE after the render
        
        // NOTE(allen): Schedule a step if necessary
        if (result.animating){
            linux_schedule_step();
        }
        
        first_step = false;
        
        linalloc_clear(&linuxvars.frame_arena);
        block_zero_struct(&linuxvars.input.trans);
    }
    
    return 0;
}

// NOTE(inso): to prevent me continuously messing up indentation
// vim: et:ts=4:sts=4:sw=4


// end --- linux_4ed.cpp --- 



// begin --- mac_error_box.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 26.09.2017
 *
 * Mac error box implementation.
 *
 */

// TOP

internal void
system_error_box(char *msg){
    //LOGF("error box: %s\n", msg);
    osx_error_dialogue(msg);
    exit(1);
}

// BOTTOM



// end --- mac_error_box.cpp --- 



// begin --- unix_4ed_functions.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 30.06.2017
 *
 * General unix functions
 *
 */

// TOP

#error IS THIS STILL REAL? (February 27th 2020)

#if !defined(FD_CHECK)
#define FD_CHECK()
#endif

struct Unix_Vars{
    b32 did_first_log;
};
global Unix_Vars unixvars;

//
// 4ed Path
//

internal
Sys_Get_Current_Path_Sig(system_get_current_path){
    i32 result = 0;
    char *d = getcwd(out, capacity);
    if (d == out){
        result = strlen(out);
    }
    return(result);
}

//
// Shared system functions (system_shared.h)
//

internal
Sys_File_Can_Be_Made_Sig(system_file_can_be_made){
    b32 result = access((char*)filename, W_OK) == 0;
    //LOGF("%s = %d\n", filename, result);
    return(result);
}

//
// Memory
//

internal void*
system_memory_allocate_extended(void *base, u64 size){
    // NOTE(allen): This must return the exact base of the vpage.
    // We will count on the user to keep track of size themselves.
    void *result = mmap(base, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (result == MAP_FAILED){
        result = 0;
    }
    return(result);
}

internal
Sys_Memory_Allocate_Sig(system_memory_allocate){
    void *result = system_memory_allocate_extended(0, size);
    return(result);
}

internal
Sys_Memory_Set_Protection_Sig(system_memory_set_protection){
    bool32 result = true;
    
    int protect = 0;
    switch (flags & 0x7){
        case 0: protect = PROT_NONE; break;
        
        case MemProtect_Read:
        protect = PROT_READ; break;
        
        case MemProtect_Write:
        case MemProtect_Read|MemProtect_Write:
        protect = PROT_READ | PROT_WRITE; break;
        
        case MemProtect_Execute:
        protect = PROT_EXEC; break;
        
        case MemProtect_Execute|MemProtect_Read:
        protect = PROT_READ | PROT_EXEC; break;
        
        // NOTE(inso): some W^X protection things might be unhappy about this one
        case MemProtect_Execute|MemProtect_Write:
        case MemProtect_Execute|MemProtect_Write|MemProtect_Read:
        protect = PROT_READ | PROT_WRITE | PROT_EXEC; break;
    }
    
    if(mprotect(ptr, size, protect) == -1){
        result = 0;
    }
    
    return(result);
}

internal
Sys_Memory_Free_Sig(system_memory_free){
    // NOTE(allen): This must take the exact base of the vpage.
    munmap(ptr, size);
}

//
// Files
//

internal
Sys_Set_File_List_Sig(system_set_file_list){
    if (directory == 0){
        system_memory_free(file_list->block, file_list->block_size);
        file_list->block = 0;
        file_list->block_size = 0;
        file_list->infos = 0;
        file_list->count = 0;
        return;
    }
    
    //LOGF("%s\n", directory);
    
    DIR *d = opendir(directory);
    if (d != 0){
        if (canon_directory_out != 0){
            u32 length = copy_fast_unsafe_cc(canon_directory_out, directory);
            if (canon_directory_out[length-1] != '/'){
                canon_directory_out[length++] = '/';
            }
            canon_directory_out[length] = 0;
            *canon_directory_size_out = length;
        }
        
        i32 character_count = 0;
        i32 file_count = 0;
        for (struct dirent *entry = readdir(d);
             entry != 0;
             entry = readdir(d)){
            char *fname = entry->d_name;
            if (match_cc(fname, ".") || match_cc(fname, "..")){
                continue;
            }
            ++file_count;
            i32 size = 0;
            for (; fname[size]; ++size);
            character_count += size + 1;
        }
        
        i32 required_size = character_count + file_count * sizeof(File_Info);
        if (file_list->block_size < required_size){
            system_memory_free(file_list->block, file_list->block_size);
            file_list->block = system_memory_allocate(required_size);
            file_list->block_size = required_size;
        }
        
        file_list->infos = (File_Info*)file_list->block;
        char *cursor = (char*)(file_list->infos + file_count);
        
        if (file_list->block != 0){
            rewinddir(d);
            File_Info *info_ptr = file_list->infos;
            for (struct dirent *entry = readdir(d);
                 entry != 0;
                 entry = readdir(d)){
                char *fname = entry->d_name;
                if (match(fname, ".") || match(fname, "..")){
                    continue;
                }
                char *cursor_start = cursor;
                i32 length = copy_fast_unsafe_cc(cursor_start, fname);
                cursor += length;
                
                if (entry->d_type == DT_LNK){
                    struct stat st;
                    if (stat(entry->d_name, &st) != -1){
                        info_ptr->folder = S_ISDIR(st.st_mode);
                    }
                    else{
                        info_ptr->folder = false;
                    }
                }
                else{
                    info_ptr->folder = (entry->d_type == DT_DIR);
                }
                
                info_ptr->filename = cursor_start;
                info_ptr->filename_len = length;
                *cursor++ = 0;
                ++info_ptr;
            }
        }
        
        file_list->count = file_count;
        
        closedir(d);
    }
    else{
        system_memory_free(file_list->block, file_list->block_size);
        file_list->block = 0;
        file_list->block_size = 0;
        file_list->infos = 0;
        file_list->count = 0;
    }
}

internal
Sys_Get_Canonical_Sig(system_get_canonical){
    char* path = (char*) alloca(len + 1);
    char* write_p = path;
    const char* read_p = filename;
    
    // return 0 for relative paths (e.g. cmdline args)
    if(len > 0 && filename[0] != '/'){
        return 0;
    }
    
    if (max == 0){
        return 0;
    }
    
    max -= 1;
    
    while (read_p < filename + len){
        if (read_p == filename || read_p[0] == '/'){
            if (read_p[1] == '/'){
                ++read_p;
            }
            else if(read_p[1] == '.'){
                if (read_p[2] == '/' || !read_p[2]){
                    read_p += 2;
                } else if(read_p[2] == '.' && (read_p[3] == '/' || !read_p[3])){
                    while(write_p > path && *--write_p != '/');
                    read_p += 3;
                }
                else {
                    *write_p++ = *read_p++;
                }
            }
            else{
                *write_p++ = *read_p++;
            }
        }
        else{
            *write_p++ = *read_p++;
        }
    }
    if (write_p == path) *write_p++ = '/';
    
    if (max >= (write_p - path)){
        memcpy(buffer, path, write_p - path);
    }
    else{
        write_p = path;
    }
    
#if defined(FRED_INTERNAL)
    if (len != (write_p - path) || memcmp(filename, path, len) != 0){
        //LOGF("[%.*s] -> [%.*s]\n", len, filename, (int)(write_p - path), path);
    }
#endif
    
    u32 length = (i32)(write_p - path);
    buffer[length] = 0;
    return(length);
}

internal
Sys_Load_Handle_Sig(system_load_handle){
    b32 result = false;
    
    FD_CHECK();
    
    i32 fd = open(filename, O_RDONLY);
    if (fd == -1 || fd == 0){
        //LOGF("upable to open file descriptor for %s\n", filename);
    }
    else{
        //LOGF("file descriptor (%d) == file %s\n", fd, filename);
        *(i32*)handle_out = fd;
        result = true;
    }
    
    return(result);
}

internal
Sys_Load_Size_Sig(system_load_size){
    u32 result = 0;
    
    i32 fd = *(i32*)&handle;
    struct stat st = {};
    
    if (fstat(fd, &st) == -1){
        //LOGF("unable to stat a file\n");
    }
    else{
        //LOGF("file descriptor (%d) has size %d\n", fd, (i32)st.st_size);
        result = st.st_size;
    }
    
    return(result);
}

internal
Sys_Load_File_Sig(system_load_file){
    i32 fd = *(i32*)&handle;
    
    do{
        ssize_t n = read(fd, buffer, size);
        if (n == -1){
            if (errno != EINTR){
                //LOGF("error reading from file descriptor (%d)\n", fd);
                break;
            }
        }
        else{
            size -= n;
            buffer += n;
        }
    } while(size);
    
    return(size == 0);
}

internal
Sys_Load_Close_Sig(system_load_close){
    b32 result = true;
    
    i32 fd = *(i32*)&handle;
    if (close(fd) == -1){
        //LOGF("error closing file descriptor (%d)\n", fd);
        result = false;
    }
    else{
        //LOGF("file descriptor (%d) closed\n", fd);
    }
    
    FD_CHECK();
    
    return(result);
}

internal
Sys_Save_File_Sig(system_save_file){
    i32 fd = open(filename, O_WRONLY|O_TRUNC|O_CREAT, 00640);
    
    //LOGF("%s %d\n", filename, size);
    if (fd < 0){
        //LOGF("error: open '%s': %s\n", filename, strerror(errno));
    }
    else{
        do{
            ssize_t written = write(fd, buffer, size);
            if (written == -1){
                if (errno != EINTR){
                    break;
                }
            }
            else{
                size -= written;
                buffer += written;
            }
        }while(size);
        close(fd);
    }
    
    return(size == 0);
}

//
// File System
//

internal
Sys_File_Exists_Sig(system_file_exists){
    int result = 0;
    char buff[PATH_MAX] = {};
    
    if (len + 1 > PATH_MAX){
        //LOG("system_directory_has_file: path too long\n");
    }
    else{
        memcpy(buff, filename, len);
        buff[len] = 0;
        struct stat st;
        result = stat(buff, &st) == 0 && S_ISREG(st.st_mode);
    }
    
    //LOGF("%s: %d\n", buff, result);
    
    return(result);
}

// BOTTOM



// end --- unix_4ed_functions.cpp --- 



// begin --- 4ed_dx11_render.cpp --- 


#define DX11_MAX_TEXTURE_COUNT 32

struct DX11Texture {
    ID3D11Texture2D* pointer;
    ID3D11ShaderResourceView* view;
};

struct GL_Program {
    ID3D11VertexShader* vertex;
    ID3D11InputLayout* layout;
    ID3D11PixelShader* pixel;
    b8 valid;
};

struct DX11 {
    b8 initialized;
    ID3D11Device1* device;
    ID3D11DeviceContext1* context;
    IDXGISwapChain1* swap_chain;
    ID3D11SamplerState* sampler;
    ID3D11RenderTargetView* render_target_view;
    GL_Program gpu_program;
    ID3D11Buffer* vertex_buffer;
    ID3D11Buffer* constants_buffer;
    
    // NOTE(simon, 28/02/24): To keep the API the same since the OpenGL texture handle are store in
    // other places than the graphics parts (e.g. in the font Face struct), we create an array of
    // textures, and use the indices as texture handles.
    DX11Texture textures[ DX11_MAX_TEXTURE_COUNT + 1 ];
    // NOTE(simon, 28/02/24): The first slot in the array should not be used so we can consider an
    // index of 0 to be invalid. OpenGL should not return 0 for texture handle, so we sort of do
    // the same.
    u32 texture_count;
};

global DX11 g_dx11 = { };

// NOTE(simon, 28/02/24): Passing 0 for texid use the reserved texture in the array, and passing a
// resource view of zero unbinds the resource.
internal void
gl__bind_texture(Render_Target *t, i32 texid){
    if (t->bound_texture != texid){
        DX11Texture* texture = g_dx11.textures + texid;
        g_dx11.context->PSSetShaderResources( 0, 1, &texture->view );
        t->bound_texture = texid;
    }
}

internal void
gl__bind_any_texture(Render_Target *t){
    if (t->bound_texture == 0){
        Assert(t->fallback_texture_id != 0);
        DX11Texture* texture = g_dx11.textures + t->fallback_texture_id;
        g_dx11.context->PSSetShaderResources( 0, 1, &texture->view );
        t->bound_texture = t->fallback_texture_id;
    }
}

internal u32
gl__get_texture(Vec3_i32 dim, Texture_Kind texture_kind){
    
    u32 texid = 0;
    
    if ( g_dx11.texture_count < ArrayCount( g_dx11.textures ) ) {
        
        texid = g_dx11.texture_count;
        g_dx11.texture_count++;
        
    } else {
        
        for ( u32 i = 1; i < g_dx11.texture_count; i++ ) {
            
            DX11Texture* texture = g_dx11.textures + i;
            
            if ( !texture->pointer && !texture->view ) {
                texid = i;
                break;
            }
        }
    }
    
    if ( texid ) {
        
        DX11Texture* texture = g_dx11.textures + texid;
        Assert( texture->pointer == 0 );
        Assert( texture->view == 0 );
        
        D3D11_TEXTURE2D_DESC texture_desc = { 0 };
        texture_desc.Width = dim.x;
        texture_desc.Height = dim.y;
        texture_desc.MipLevels = 1;
        texture_desc.ArraySize = dim.z;
        texture_desc.Format = DXGI_FORMAT_A8_UNORM;
        texture_desc.SampleDesc.Count = 1;
        texture_desc.Usage = D3D11_USAGE_DEFAULT;
        texture_desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
        texture_desc.CPUAccessFlags = 0; // D3D11_CPU_ACCESS_WRITE;
        
        // NOTE(simon, 28/02/24): I initialize the texture with zeros. In practice it doesn't seem
        // to matter, but since the shader use a bilinear filter, the unitialized data in the
        // texture could change the result of the filtering for texel at the edge of a character.
        // I did some tests with the rectangle packer to have a border around character but got the
        // exact same render, so It doesn't matter much.
        D3D11_SUBRESOURCE_DATA* texture_data = push_array_zero( &win32vars.frame_arena, D3D11_SUBRESOURCE_DATA, dim.z );
        u8* initial_data = push_array_zero( &win32vars.frame_arena, u8, dim.x * dim.y );
        
        for ( i32 i = 0; i < dim.z; i++ ) {
            texture_data[ i ].pSysMem = initial_data;
            texture_data[ i ].SysMemPitch = dim.x;
        }
        
        HRESULT hr = g_dx11.device->CreateTexture2D( &texture_desc, texture_data, &texture->pointer );
        
        pop_array( &win32vars.frame_arena, u8, dim.x * dim.y );
        pop_array( &win32vars.frame_arena, D3D11_SUBRESOURCE_DATA, dim.z );
        
        if ( SUCCEEDED( hr ) ) {
            hr = g_dx11.device->CreateShaderResourceView( ( ID3D11Resource* ) texture->pointer, 0, &texture->view );
        }
        
        if ( FAILED( hr ) ) {
            
            // NOTE(simon, 28/02/24): When we fail, we donc decrement the texture count, but the
            // loop at the beginning of the function will reuse texture when
            // texture_count == DX11_MAX_TEXTURE_COUNT.
            texid = 0;
            
            if ( texture->pointer ) {
                texture->pointer->Release( );
                texture->pointer = 0;
            }
            
            if ( texture->view ) {
                texture->view->Release( );
                texture->view = 0;
            }
        }
    }
    
    return(texid);
}

internal b32
gl__fill_texture(Texture_Kind texture_kind, u32 texid, Vec3_i32 p, Vec3_i32 dim, void *data){
    
    // NOTE(simon, 28/02/24): The OpenGL version always returns false.
    b32 result = false;
    
    // NOTE(simon, 28/02/24): In the OpenGL version, if we pass zero as texture handle, the
    // function works on the currently bound texture. In directx we need to get the texture pointer.
    // We could retrieve that from Render_Target->bound_texture, but we don't have that as a
    // parameter to this function and don't want to change the signature since it's used by the
    // font rendering code and other platforms. Fortunately the only call that specified 0 for the
    // texture handle was for the creation of the fallback texture in gl_render, and we can modify
    // that call to pass the fallback texture handle.
    Assert( texid != 0 ); 
    
    if (dim.x > 0 && dim.y > 0 && dim.z > 0){
        
        DX11Texture* texture = g_dx11.textures + texid;
        
        D3D11_BOX box = { };
        box.left = p.x;
        box.right = p.x + dim.x;
        box.top = p.y;
        box.bottom = p.y + dim.y;
        box.front = 0;
        box.back = 1;
        
        u32 sub_resource_index = D3D11CalcSubresource( 0 /* MipSlice */, p.z /* ArraySlice */, 1 /* MipLevels */ );
        g_dx11.context->UpdateSubresource( texture->pointer, sub_resource_index, &box, data, dim.x, dim.x * dim.y );
    }
    
    return(result);
}

internal void gl__free_texture( u32 texid ) {
    
    if ( texid ) {
        
        DX11Texture* texture = g_dx11.textures + texid;
        
        if ( texture->view ) {
            texture->view->Release( );
            texture->view = 0;
        }
        
        if ( texture->pointer ) {
            texture->pointer->Release( );
            texture->pointer = 0;
        }
    }
}

char *gl__vertex = R"foo(

// NOTE(simon, 28/02/24): The layout of this is (constants are store in 16 bytes vectors (4 floats))
// vector1: view_m._11, view_m._12, 0, 0
// vector2: view_m._21, view_m._22, view_t.x, view_t.y
cbuffer constants : register( b0 ) {
    row_major float2x2 view_m;
    float2 view_t;
}

struct input_t {
    float2 vertex_p : POSITION;
    float3 vertex_t : UVW;
    float4 vertex_c : COLOR;
    float vertex_ht : THICKNESS;
};

struct output_t {
    float4 position : SV_POSITION;
    float4 color : COLOR;
    float3 uvw : UVW;
    float2 xy : XY;
    float2 adjusted_half_dim: HALF_DIM;
    float half_thickness : THICKNESS;
};

output_t main(input_t input) {
	
    output_t output;

    output.position = float4( mul( view_m, ( input.vertex_p - view_t ) ), 0.0, 1.0 );
    // NOTE(simon, 28/02/24): The input colors are BGRA, we need them as RGBA.
    output.color = input.vertex_c.zyxw;
    output.uvw = input.vertex_t;
	output.xy = input.vertex_p;
	output.half_thickness = input.vertex_ht;
	
    float2 center = input.vertex_t.xy;
    float2 half_dim = abs( input.vertex_p - center );
    output.adjusted_half_dim = half_dim - input.vertex_t.zz + float2( 0.5, 0.5 );
    
    return output;
}
)foo";

char *gl__fragment = R"foo(

struct input_t {
    float4 position : SV_POSITION;
    float4 color : COLOR;
    float3 uvw : UVW;
    float2 xy : XY;
    float2 adjusted_half_dim: HALF_DIM;
    float half_thickness : THICKNESS;
};

Texture2DArray alpha : register( t0 );
SamplerState alpha_sampler : register( s0 );

float rectangle_sd( float2 p, float2 b ) {

    float2 d = abs( p ) - b;
    return( length( max( d, float2( 0.0, 0.0 ) ) ) + min( max( d.x, d.y ), 0.0 ) );
}

float4 main( input_t input ) : SV_TARGET {

    float has_thickness = step( 0.49, input.half_thickness );
    float does_not_have_thickness = 1.0 - has_thickness;

    float sample_value = alpha.Sample( alpha_sampler, input.uvw ).a;
    sample_value *= does_not_have_thickness;

    float2 center = input.uvw.xy;
    float roundness = input.uvw.z;
    float sd = rectangle_sd( input.xy - center, input.adjusted_half_dim );
    sd = sd - roundness;
    sd = abs( sd + input.half_thickness ) - input.half_thickness;
    float shape_value = 1.0 - smoothstep(-1.0, 0.0, sd);
    shape_value *= has_thickness;

    float4 result = float4( input.color.xyz, input.color.a * ( sample_value + shape_value ) );
    return result;
}
)foo";

// NOTE(simon, 28/02/24): This function is not generic. It can compile any shader, but the vertex
// input layout is fixed. 4coder only has one vertex format and shader, so we could remove this
// function and move its content in the win32_gl_create_window. I removed the header parameter as
// it's not useful in directx.
internal GL_Program
gl__make_program( char* vertex, char* pixel ) {
    
    GL_Program result = { };
    
    u32 vertex_length = 0;
    
    while ( vertex && vertex[ vertex_length ] != 0 ) {
        vertex_length++;
    }
    
    u32 pixel_length = 0;
    
    while ( pixel && pixel[ pixel_length ] != 0 ) {
        pixel_length++;
    }
    
    ID3DBlob* vs_blob = 0;
    ID3DBlob* vs_error_blob = 0;
    ID3D11VertexShader* vertex_shader = 0;
    ID3D11InputLayout* input_layout = 0;
    
    ID3DBlob* ps_blob = 0;
    ID3DBlob* ps_error_blob = 0;
    ID3D11PixelShader* pixel_shader = 0;
    
    do {
        
        HRESULT hr = D3DCompile( vertex, vertex_length, 0, 0, 0, "main", "vs_5_0", 0, 0, &vs_blob, &vs_error_blob );
        
        if ( FAILED( hr ) ) {
            log_os( "Failed to compile vertex shader.\n" );
            
            if ( vs_error_blob ) {
                u8* error_message = ( u8* ) vs_error_blob->GetBufferPointer( );
                u32 length = ( u32 ) vs_error_blob->GetBufferSize( );
                log_os( "vertex shader error:\n%.*s\n", length, error_message );
            }
            
            break;
        }
        
        hr = g_dx11.device->CreateVertexShader( vs_blob->GetBufferPointer( ), vs_blob->GetBufferSize( ), 0, &vertex_shader );
        
        if ( FAILED( hr ) ) {
            log_os( "Failed to create a vertex shader.\n" );
            break;
        }
        
        
        D3D11_INPUT_ELEMENT_DESC layout_desc[ 4 ] = { };
        
        layout_desc[ 0 ].SemanticName = "POSITION";
        layout_desc[ 0 ].Format = DXGI_FORMAT_R32G32_FLOAT;
        layout_desc[ 0 ].AlignedByteOffset = 0;
        layout_desc[ 0 ].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
        
        layout_desc[ 1 ].SemanticName = "UVW";
        layout_desc[ 1 ].Format = DXGI_FORMAT_R32G32B32_FLOAT;
        layout_desc[ 1 ].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
        layout_desc[ 1 ].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
        
        layout_desc[ 2 ].SemanticName = "COLOR";
        layout_desc[ 2 ].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        layout_desc[ 2 ].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
        layout_desc[ 2 ].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
        
        layout_desc[ 3 ].SemanticName = "THICKNESS";
        layout_desc[ 3 ].Format = DXGI_FORMAT_R32_FLOAT;
        layout_desc[ 3 ].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
        layout_desc[ 3 ].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
        
        hr = g_dx11.device->CreateInputLayout( layout_desc, ArrayCount( layout_desc ), vs_blob->GetBufferPointer( ), vs_blob->GetBufferSize( ), &input_layout );
        
        if ( FAILED( hr ) ) {
            log_os( "Failed to create input layout.\n" );
            break;
        }
        
        
        hr = D3DCompile( pixel, pixel_length, 0, 0, 0, "main", "ps_5_0", 0, 0, &ps_blob, &ps_error_blob );
        
        if ( FAILED( hr ) ) {
            log_os( "Failed to compile pixel shader.\n" );
            
            if ( ps_error_blob ) {
                u8* error_message = ( u8* ) ps_error_blob->GetBufferPointer( );
                u32 length = ( u32 ) ps_error_blob->GetBufferSize( );
                log_os( "pixel shader error:\n%.*s\n", length, error_message );
            }
            
            break;
        }
        
        hr = g_dx11.device->CreatePixelShader( ps_blob->GetBufferPointer( ), ps_blob->GetBufferSize( ), 0, &pixel_shader );
        
        if ( FAILED( hr ) ) {
            log_os( "Failed to create a pixel shader.\n" );
            break;
        }
        
        result.vertex = vertex_shader;
        result.layout = input_layout;
        result.pixel = pixel_shader;
        result.valid = true;
        
    } while ( 0 );
    
    if ( vs_blob ) {
        vs_blob->Release( );
        vs_blob = 0;
    }
    
    if ( vs_error_blob ) {
        vs_error_blob->Release( );
        vs_error_blob = 0;
    }
    
    if ( ps_blob ) {
        ps_blob->Release( );
        ps_blob = 0;
    }
    
    if ( ps_error_blob ) {
        ps_error_blob->Release( );
        ps_error_blob = 0;
    }
    
    if ( !result.valid ) {
        
        if ( vertex_shader ) {
            vertex_shader->Release( );
            vertex_shader = 0;
        }
        
        if ( input_layout ) {
            input_layout->Release( );
            input_layout = 0;
        }
        
        if ( pixel_shader ) {
            pixel_shader->Release( );
            pixel_shader = 0;
        }
        
        os_popup_error( "Error", "Shader compilation failed." );
    }
    
    return result;
}

internal void
gl_render(Render_Target *t){
    Font_Set *font_set = (Font_Set*)t->font_set;
    
    local_persist b32 first_call = true;
    
    if (first_call){
        
        // NOTE(simon, 28/02/24): Most of the code here has been moved in win32_gl_create_window
        // because if that code fails we should exit the application directly.
        first_call = false;
        
        u32 stride = sizeof( Render_Vertex );
        u32 offset = 0;
        
        g_dx11.context->IASetVertexBuffers( 0, 1, &g_dx11.vertex_buffer, &stride, &offset );
        g_dx11.context->IASetInputLayout( g_dx11.gpu_program.layout );
        g_dx11.context->IASetPrimitiveTopology( D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST );
        
        g_dx11.context->VSSetShader( g_dx11.gpu_program.vertex, 0, 0 );
        g_dx11.context->VSSetConstantBuffers( 0, 1, &g_dx11.constants_buffer );
        
        g_dx11.context->PSSetShader( g_dx11.gpu_program.pixel, 0, 0 );
        g_dx11.context->PSSetSamplers( 0, 1, &g_dx11.sampler );
        
        {
            t->fallback_texture_id = gl__get_texture(V3i32(2, 2, 1), TextureKind_Mono);
            u8 white_block[] = { 0xFF, 0xFF, 0xFF, 0xFF, };
            // NOTE(simon, 28/02/24): Passing the fallback texture, because we can't rely on the
            // fact that gl__get_texture has bound the fallback texture.
            gl__fill_texture(TextureKind_Mono, t->fallback_texture_id, V3i32(0, 0, 0), V3i32(2, 2, 1), white_block);
        }
    }
    
    // NOTE(simon, 28/02/24): OMSetRenderTargets needs to be set each frame when using a FLIP swap
    // chain.
    g_dx11.context->OMSetRenderTargets( 1, &g_dx11.render_target_view, 0 );
    
    i32 width = t->width;
    i32 height = t->height;
    
    // NOTE(simon, 28/02/24): Viewport (0, 0) is top left in directx. Important for viewport and
    // scissor calls.
    
    D3D11_VIEWPORT viewport = {
        0, // TopLeftX
        0, // TopLeftY
        ( float ) width, // Width
        ( float ) height, // Height
        0, // MinDepth
        1// MaxDepth
    };
    
    g_dx11.context->RSSetViewports( 1, &viewport );
    
    D3D11_RECT scissor = {
        0, // left
        0, // top
        width, // right
        height // bottom
    };
    
    g_dx11.context->RSSetScissorRects( 1, &scissor );
    
    float magenta[ 4 ] = { 1.0f, 0.0f, 1.0f, 1.0f };
    g_dx11.context->ClearRenderTargetView( g_dx11.render_target_view, magenta );
    
    // NOTE(simon, 28/02/24): The constants (uniforms) were set in the render loop in the OpenGL
    // version. But since they don't vary between draw calls I moved the code before the render
    // loop.
    D3D11_MAPPED_SUBRESOURCE constants_map = { };
    HRESULT hr = g_dx11.context->Map( ( ID3D11Resource* ) g_dx11.constants_buffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &constants_map );
    
    // NOTE(simon, 28/02/24): The layout of the constants buffer was a bit confusing. This link
    // explains a little about how data is laid out:
    // https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-packing-rules
    // The article doesn't explain anything about matrices. What I found out while making this work
    // is that each row or column (depending on if we use column or row major matrices) of a matrix
    // needs to start on a new 16 bytes vector. For a 2 by 2 matrix, this means that there are two
    // register elements at the end of the first vector that aren't used.
    // Another thing is that the second vector only needs the first two elements for the matrix,
    // so the two elements we want to put next can be in the same vector.
    
    // NOTE(simon, 28/02/24): The code here could be shorter, but I prefer to make it clear what's
    // happening.
    f32 view_m[ 4 ] = {
        2.0f / width, 0,
        0, -2.0f / height
    };
    f32 view_t[ 2 ] = { width / 2.0f, height / 2.0f };
    
    f32* vector_1 = ( f32* ) constants_map.pData;
    f32* vector_2 = vector_1 + 4;
    
    vector_1[ 0 ] = view_m[ 0 ];
    vector_1[ 1 ] = view_m[ 1 ];
    vector_1[ 2 ] = 0; // Padding
    vector_1[ 3 ] = 0; // Padding
    
    vector_2[ 0 ] = view_m[ 2 ];
    vector_2[ 1 ] = view_m[ 3 ];
    vector_2[ 2 ] = view_t[ 0 ];
    vector_2[ 3 ] = view_t[ 1 ];
    
    g_dx11.context->Unmap( ( ID3D11Resource* ) g_dx11.constants_buffer, 0 );
    
    gl__bind_texture( t, 0 );
    
    for (Render_Free_Texture *free_texture = t->free_texture_first;
         free_texture != 0;
         free_texture = free_texture->next){
        
        gl__free_texture( free_texture->tex_id );
    }
    
    t->free_texture_first = 0;
    t->free_texture_last = 0;
    
    D3D11_BUFFER_DESC vertex_buffer_desc = { };
    g_dx11.vertex_buffer->GetDesc( &vertex_buffer_desc );
    
    for (Render_Group *group = t->group_first;
         group != 0;
         group = group->next){
        Rect_i32 box = Ri32(group->clip_box);
        
        D3D11_RECT group_scissor = { };
        group_scissor.left = box.x0;
        group_scissor.right = box.x1;
        group_scissor.top = box.y0;
        group_scissor.bottom = box.y1;
        
        g_dx11.context->RSSetScissorRects( 1, &group_scissor );
        
        i32 vertex_count = group->vertex_list.vertex_count;
        if (vertex_count > 0){
            Face *face = font_set_face_from_id(font_set, group->face_id);
            if (face != 0){
                gl__bind_texture(t, face->texture);
            }
            else{
                gl__bind_any_texture(t);
            }
            
            // NOTE(simon, 29/03/24): 4coder doesn't appear to clip character outside the screen
            // horizontally. Even with line wrapping enabled, you can have cases where the line
            // won't wrap, for example "{0,0,0,0,...}" with a lot of zero and no space will not
            // wrap. The consequence of that is that we might send a lot of vertex data that's
            // offscreen and the assumption about the vertex buffer size I made, can be wrong.
            // So in this loop we release the previous vertex and create a new one when necessary.
            u32 size_required = vertex_count * sizeof( Render_Vertex );
            
            if ( size_required > vertex_buffer_desc.ByteWidth ) {
                
                u32 new_size = vertex_buffer_desc.ByteWidth * 2;
                
                while ( new_size < size_required ) {
                    new_size *= 2;
                }
                
                // NOTE(simon, 29/03/24): Create a new buffer and only release the previous one if
                // the creation succeeded. If the creation fails, we skip this vertex group, which
                // means the user will see an empty panel, but at least we won't stop rendering.
                D3D11_BUFFER_DESC new_vertex_buffer_desc = vertex_buffer_desc;
                new_vertex_buffer_desc.ByteWidth = new_size;
                ID3D11Buffer* new_vertex_buffer = 0;
                hr = g_dx11.device->CreateBuffer( &new_vertex_buffer_desc, 0, &new_vertex_buffer );
                
                if ( FAILED( hr ) ) {
                    continue;
                }
                
                g_dx11.vertex_buffer->Release( );
                g_dx11.vertex_buffer = new_vertex_buffer;
                vertex_buffer_desc.ByteWidth = new_size;
                
                u32 stride = sizeof( Render_Vertex );
                u32 offset = 0;
                g_dx11.context->IASetVertexBuffers( 0, 1, &g_dx11.vertex_buffer, &stride, &offset );
            }
            
            // NOTE(simon, 28/02/24): We fill the buffer, draw what we filled and then do the next
            // group, which allows to always start drawing from vertex 0. Alternatively we could
            // do a pass to fill the vertex buffer completly so we only map the vertex buffer once,
            // and then a second pass that just execute the draw calls. It doesn't seems necessary
            // since we have less than 10 draw call.
            
            D3D11_MAPPED_SUBRESOURCE vertex_map = { };
            hr = g_dx11.context->Map( ( ID3D11Resource* ) g_dx11.vertex_buffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &vertex_map );
            
            if ( FAILED( hr ) ) {
                // NOTE(simon, 28/02/24): It's improbable that Map will fail, but if it does we
                // just stop rendering, and we'll try on the next frame. We could just skip the
                // group and try with the next (using 'continue' instead of 'break'), but Map would
                // probably fail again. Waiting for the next frame "might" work. I don't really
                // know. We could also just exit the application assuming we won't be able to
                // render anything.
                break;
            }
            
            u8* bytes = ( u8* ) vertex_map.pData;
            
            for (Render_Vertex_Array_Node *node = group->vertex_list.first;
                 node != 0;
                 node = node->next){
                
                i32 size = node->vertex_count*sizeof(*node->vertices);
                memcpy( bytes, node->vertices, size );
                bytes += size;
            }
            
            g_dx11.context->Unmap( ( ID3D11Resource* ) g_dx11.vertex_buffer, 0 );
            
            g_dx11.context->Draw( vertex_count, 0 );
        }
    }
}

// end --- 4ed_dx11_render.cpp --- 



// begin --- win32_4ed.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 12.12.2014
 *
 * Win32 layer for 4coder
 *
 */

// TOP

// #define FPS 144
// #define frame_useconds (1000000 / FPS)

// #define WIN32_DX11

#include <stdio.h>
#define STATIC_LINK_API
#define STATIC_LINK_API
#define STATIC_LINK_API

#undef function
#define UNICODE
#include <Windows.h>
#define function static

// begin --- win32_utf8.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 23.03.2017
 *
 * UTF8 versions of WIN32 calls.
 *
 */

// TOP

#if !defined(FRED_WIN32_UTF8_H)
#define FRED_WIN32_UTF8_H

function HANDLE
CreateFile_utf8(Arena *scratch, u8 *name, DWORD access, DWORD share, LPSECURITY_ATTRIBUTES security, DWORD creation, DWORD flags, HANDLE template_file);

function DWORD
GetFinalPathNameByHandle_utf8(Arena *scratch, HANDLE file, u8 *file_path_out, DWORD path_max, DWORD flags);

function HANDLE
FindFirstFile_utf8(Arena *scratch, u8 *name, LPWIN32_FIND_DATA find_data);

function DWORD
GetFileAttributes_utf8(Arena *scratch, u8 *name);

function DWORD
GetModuleFileName_utf8(Arena *scratch, HMODULE module, u8 *file_out, DWORD max);

function BOOL
CreateProcess_utf8(Arena *scratch, u8 *app_name, u8 *command, LPSECURITY_ATTRIBUTES security, LPSECURITY_ATTRIBUTES thread, BOOL inherit_handles, DWORD creation, LPVOID environment, u8 *curdir, LPSTARTUPINFO startup, LPPROCESS_INFORMATION process);

function DWORD
GetCurrentDirectory_utf8(Arena *scratch, DWORD max, u8 *buffer);

function int
MessageBox_utf8(Arena *scratch, HWND owner, u8 *text, u8 *caption, UINT type);

function BOOL
SetWindowText_utf8(Arena *scratch, HWND window, u8 *string);

function BOOL
GetFileAttributesEx_utf8String(Arena *scratch, String_Const_u8 file_name, GET_FILEEX_INFO_LEVELS info_level_id, LPVOID file_info);

function HMODULE
LoadLibrary_utf8String(Arena *scratch, String_Const_u8 file_name);

#endif

// BOTTOM



// end --- win32_utf8.h --- 



////////////////////////////////

global b32 log_os_enabled = false;
#define log_os(...) \
Stmnt( if (log_os_enabled){ fprintf(stdout, __VA_ARGS__); fflush(stdout); } )

//////////////////////////////

internal String_Const_u8 win32_get_error_string(void);
internal void win32_output_error_string(String_Const_u8 string);

//////////////////////////////

#define WM_4coder_ANIMATE (WM_USER + 0)

struct Control_Keys{
    b8 l_ctrl;
    b8 r_ctrl;
    b8 l_alt;
    b8 r_alt;
};

struct Win32_Input_Chunk_Transient{
    Input_List event_list;
    b8 mouse_l_press;
    b8 mouse_l_release;
    b8 mouse_r_press;
    b8 mouse_r_release;
    b8 out_of_window;
    i8 mouse_wheel;
    b8 trying_to_kill;
};

struct Win32_Input_Chunk_Persistent{
    Vec2_i32 mouse;
    Control_Keys controls;
    Input_Modifier_Set_Fixed modifiers;
    b8 mouse_l;
    b8 mouse_r;
};

struct Win32_Input_Chunk{
    Win32_Input_Chunk_Transient trans;
    Win32_Input_Chunk_Persistent pers;
};

////////////////////////////////

#define SLASH '\\'
#define DLL "dll"

////////////////////////////////

typedef i32 Win32_Object_Kind;
enum{
    Win32ObjectKind_ERROR = 0,
    Win32ObjectKind_Timer = 1,
    Win32ObjectKind_Thread = 2,
    Win32ObjectKind_Mutex = 3,
    Win32ObjectKind_CV = 4,
};

struct Win32_Object{
    Node node;
    Win32_Object_Kind kind;
    union{
        struct{
            UINT_PTR id;
        } timer;
        struct{
            HANDLE thread;
            Thread_Function *proc;
            void *ptr;
        } thread;
        CRITICAL_SECTION mutex;
        CONDITION_VARIABLE cv;
    };
};

struct Win32_Vars{
    Thread_Context *tctx;
    
    Arena frame_arena;
    Input_Event *active_key_stroke;
    Input_Event *active_text_input;
    Win32_Input_Chunk input_chunk;
    b8 lctrl_lalt_is_altgr;
    b8 got_useful_event;
    
    Key_Mode key_mode;
    HKL kl_universal;
    
    b8 full_screen;
    b8 do_toggle;
    WINDOWPLACEMENT bordered_win_pos;
    b32 send_exit_signal;
    
    HCURSOR cursor_ibeam;
    HCURSOR cursor_arrow;
    HCURSOR cursor_leftright;
    HCURSOR cursor_updown;
    i32 cursor_show;
    i32 prev_cursor_show;
    
    String_Const_u8 binary_path;
    
    b8 clip_catch_all;
    DWORD clipboard_sequence;
    Plat_Handle clip_wakeup_timer;
    
    Arena clip_post_arena;
    String_Const_u8 clip_post;
    
    HWND window_handle;
    f32 screen_scale_factor;
    
    DWORD audio_thread_id;
    
    void *volatile audio_mix_ctx;
    Audio_Mix_Sources_Function *volatile audio_mix_sources;
    Audio_Mix_Destination_Function *volatile audio_mix_destination;
    
    f64 usecond_per_count;
    b32 first;
    i32 running_cli;
    
    Node free_win32_objects;
    Node timer_objects;
    UINT_PTR timer_counter;
    
    CRITICAL_SECTION thread_launch_mutex;
    CONDITION_VARIABLE thread_launch_cv;
    b32 waiting_for_launch;
    
    System_Mutex global_frame_mutex;
    
    Log_Function *log_string;
};

////////////////////////////////

global Win32_Vars win32vars;
global Render_Target target;

////////////////////////////////

internal void
system_error_box(char *msg){
    MessageBoxA(0, msg, "Error", MB_OK);
    ExitProcess(1);
}

////////////////////////////////

internal String_Const_u8
win32_get_error_string(void){
    String_Const_u8 result = {};
    DWORD error = GetLastError();
    char *str = 0;
    char *str_ptr = (char*)&str;
    if (FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                       0, error, 0, str_ptr, 0, 0)){
        result.str = (u8*)str;
        result.size = strlen(str);
    }
    return(result);
}

internal void
win32_output_error_string(String_Const_u8 error_string){
    system_error_box((char*)error_string.str);
}

////////////////////////////////

internal HANDLE
handle_type(Plat_Handle h){
    HANDLE result;
    block_copy(&result, &h, sizeof(result));
    return(result);
}

internal Plat_Handle
handle_type(HANDLE h){
    Plat_Handle result = {};
    block_copy(&result, &h, sizeof(h));
    return(result);
}

internal void*
handle_type_ptr(Plat_Handle h){
    void *result;
    block_copy(&result, &h, sizeof(result));
    return(result);
}

internal Plat_Handle
handle_type_ptr(void *ptr){
    Plat_Handle result = {};
    block_copy(&result, &ptr, sizeof(ptr));
    return(result);
}

////////////////////////////////

// begin --- win32_4ed_functions.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 18.07.2017
 *
 * General win32 functions
 *
 */

// TOP

internal b32
system_file_can_be_made(Arena *scratch, u8 *filename){
    HANDLE file = CreateFile_utf8(scratch, filename, FILE_APPEND_DATA, 0, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
    b32 result = false;
    if (file != INVALID_HANDLE_VALUE){
        CloseHandle(file);
        result = true;
    }
    return(result);
}

//
// Memory
//

struct Memory_Annotation_Tracker_Node{
    Memory_Annotation_Tracker_Node *next;
    Memory_Annotation_Tracker_Node *prev;
    String_Const_u8 location;
    u64 size;
};

struct Memory_Annotation_Tracker{
    Memory_Annotation_Tracker_Node *first;
    Memory_Annotation_Tracker_Node *last;
    i32 count;
};

global Memory_Annotation_Tracker memory_tracker = {};
global CRITICAL_SECTION memory_tracker_mutex;

internal void*
win32_memory_allocate_extended(void *base, u64 size, String_Const_u8 location){
    u64 adjusted_size = size + 64;
    void *result = VirtualAlloc(base, (SIZE_T)adjusted_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    Memory_Annotation_Tracker_Node *node = (Memory_Annotation_Tracker_Node*)result;
    EnterCriticalSection(&memory_tracker_mutex);
    zdll_push_back(memory_tracker.first, memory_tracker.last, node);
    memory_tracker.count += 1;
    LeaveCriticalSection(&memory_tracker_mutex);
    node->location = location;
    node->size = size;
    return(node + 1);
}

internal void
win32_memory_free_extended(void *ptr){
    Memory_Annotation_Tracker_Node *node = (Memory_Annotation_Tracker_Node*)ptr;
    node -= 1;
    EnterCriticalSection(&memory_tracker_mutex);
    zdll_remove(memory_tracker.first, memory_tracker.last, node);
    memory_tracker.count -= 1;
    LeaveCriticalSection(&memory_tracker_mutex);
    VirtualFree(node, 0, MEM_RELEASE);
}

internal
system_memory_allocate_sig(){
    return(win32_memory_allocate_extended(0, size, location));
}

internal
system_memory_set_protection_sig(){
    DWORD protect = 0;
    
    switch (flags & 0x7){
        case 0:                                                   protect = PAGE_NOACCESS; break;
        case MemProtect_Read:                                     protect = PAGE_READONLY; break;
        case MemProtect_Write:                                    /* below */
        case MemProtect_Write|MemProtect_Read:                    protect = PAGE_READWRITE; break;
        case MemProtect_Execute:                                  protect = PAGE_EXECUTE; break;
        case MemProtect_Execute|MemProtect_Read:                  protect = PAGE_EXECUTE_READ; break;
        case MemProtect_Execute|MemProtect_Write:                 /* below */
        case MemProtect_Execute|MemProtect_Write|MemProtect_Read: protect = PAGE_EXECUTE_READWRITE; break;
    }
    
    Memory_Annotation_Tracker_Node *node = (Memory_Annotation_Tracker_Node*)ptr;
    node -= 1;
    
    DWORD old_protect = 0;
    b32 result = VirtualProtect(node, (SIZE_T)size, protect, &old_protect);
    return(result);
}

internal
system_memory_free_sig(){
    win32_memory_free_extended(ptr);
}

internal
system_memory_annotation_sig(){
    Memory_Annotation result = {};
    EnterCriticalSection(&memory_tracker_mutex);
    
    for (Memory_Annotation_Tracker_Node *node = memory_tracker.first;
         node != 0;
         node = node->next){
        Memory_Annotation_Node *r_node = push_array(arena, Memory_Annotation_Node, 1);
        sll_queue_push(result.first, result.last, r_node);
        result.count += 1;
        r_node->location = node->location;
        r_node->address = node + 1;
        r_node->size = node->size;
    }
    
    LeaveCriticalSection(&memory_tracker_mutex);
    return(result);
}

//
// 4ed path
//

extern "C" BOOL CALL_CONVENTION
GetUserProfileDirectoryW(HANDLE  hToken, LPWSTR  lpProfileDir, LPDWORD lpcchSize);

global String_Const_u8 w32_override_user_directory = {};

internal
system_get_path_sig(){
    String_Const_u8 result = {};
    switch (path_code){
        case SystemPath_CurrentDirectory:
        {
            DWORD size = GetCurrentDirectory_utf8(arena, 0, 0);
            u8 *out = push_array(arena, u8, size);
            size = GetCurrentDirectory_utf8(arena, size, out);
            result = SCu8(out, size);
        }break;
        
        case SystemPath_Binary:
        {
            local_persist b32 has_stashed_4ed_path = false;
            if (!has_stashed_4ed_path){
                has_stashed_4ed_path = true;
                local_const i32 binary_path_capacity = KB(32);
                u8 *memory = (u8*)system_memory_allocate(binary_path_capacity, string_u8_litexpr(file_name_line_number));
                i32 size = GetModuleFileName_utf8(arena, 0, memory, binary_path_capacity);
                Assert(size <= binary_path_capacity - 1);
                win32vars.binary_path = SCu8(memory, size);
                win32vars.binary_path = string_remove_last_folder(win32vars.binary_path);
                win32vars.binary_path.str[win32vars.binary_path.size] = 0;
            }
            result = push_string_copy(arena, win32vars.binary_path);
        }break;
        
        case SystemPath_UserDirectory:
        {
            if (w32_override_user_directory.size == 0){
                HANDLE current_process_token = GetCurrentProcessToken();
                DWORD size = 0;
                GetUserProfileDirectoryW(current_process_token, 0, &size);
                u16 *buffer_u16 = push_array(arena, u16, size);
                if (GetUserProfileDirectoryW(current_process_token, (WCHAR*)buffer_u16, &size)){
                    String8 path = string_u8_from_string_u16(arena, SCu16(buffer_u16, size), StringFill_NullTerminate).string;
                    result = push_stringf(arena, "%.*s\\4coder\\", string_expand(path));
                }
            }
            else{
                result = w32_override_user_directory;
            }
        }break;
    }
    return(result);
}

//
// Files
//

internal String_Const_u8
win32_remove_unc_prefix_characters(String_Const_u8 path){
    if (string_match(string_prefix(path, 7), string_u8_litexpr("\\\\?\\UNC"))){
#if 0
        // TODO(allen): Why no just do
        path = string_skip(path, 7);
        path.str[0] = '\\';
        // ?
#endif
        path.size -= 7;
        block_copy(path.str, path.str + 7, path.size);
        path.str[0] = '\\';
    }
    else if (string_match(string_prefix(path, 4), string_u8_litexpr("\\\\?\\"))){
        // TODO(allen): Same questions essentially.
        path.size -= 4;
        block_copy(path.str, path.str + 4, path.size);
    }
    return(path);
}

internal
system_get_canonical_sig(){
    String_Const_u8 result = {};
    if ((character_is_alpha(string_get_character(name, 0)) &&
         string_get_character(name, 1) == ':') ||
        string_match(string_prefix(name, 2), string_u8_litexpr("\\\\"))){
        
        u8 *c_name = push_array(arena, u8, name.size + 1);
        block_copy(c_name, name.str, name.size);
        c_name[name.size] = 0;
        HANDLE file = CreateFile_utf8(arena, c_name, GENERIC_READ, 0, 0, OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL, 0);
        
        if (file != INVALID_HANDLE_VALUE){
            DWORD capacity = GetFinalPathNameByHandle_utf8(arena, file, 0, 0, 0);
            u8 *buffer = push_array(arena, u8, capacity);
            DWORD length = GetFinalPathNameByHandle_utf8(arena, file, buffer, capacity, 0);
            if (length > 0 && buffer[length - 1] == 0){
                length -= 1;
            }
            result = SCu8(buffer, length);
            result = win32_remove_unc_prefix_characters(result);
            CloseHandle(file);
        }
        else{
            String_Const_u8 path = string_remove_front_of_path(name);
            String_Const_u8 front = string_front_of_path(name);
            
            u8 *c_path = push_array(arena, u8, path.size + 1);
            block_copy(c_path, path.str, path.size);
            c_path[path.size] = 0;
            
            HANDLE dir = CreateFile_utf8(arena, c_path, FILE_LIST_DIRECTORY,
                                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 0,
                                         OPEN_EXISTING,
                                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED, 0);
            
            if (dir != INVALID_HANDLE_VALUE){
                DWORD capacity = GetFinalPathNameByHandle_utf8(arena, dir, 0, 0, 0);
                u8 *buffer = push_array(arena, u8, capacity + front.size + 1);
                DWORD length = GetFinalPathNameByHandle_utf8(arena, dir, buffer, capacity, 0);
                if (length > 0 && buffer[length - 1] == 0){
                    length -= 1;
                }
                buffer[length] = '\\';
                length += 1;
                block_copy(buffer + length, front.str, front.size);
                length += (DWORD)front.size;
                result = SCu8(buffer, length);
                result = win32_remove_unc_prefix_characters(result);
                CloseHandle(dir);
            }
        }
    }
    return(result);
}

internal File_Attribute_Flag
win32_convert_file_attribute_flags(DWORD dwFileAttributes){
    File_Attribute_Flag result = {};
    MovFlag(dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY, result, FileAttribute_IsDirectory);
    return(result);
}

internal u64
win32_u64_from_u32_u32(u32 hi, u32 lo){
    return( (((u64)hi) << 32) | ((u64)lo) );
}

internal u64
win32_u64_from_filetime(FILETIME time){
    return(win32_u64_from_u32_u32(time.dwHighDateTime, time.dwLowDateTime));
}

internal File_Attributes
win32_file_attributes_from_HANDLE(HANDLE file){
    BY_HANDLE_FILE_INFORMATION info = {};
    GetFileInformationByHandle(file, &info);
    File_Attributes result = {};
    result.size = win32_u64_from_u32_u32(info.nFileSizeHigh, info.nFileSizeLow);
    result.last_write_time = win32_u64_from_filetime(info.ftLastWriteTime);
    result.flags = win32_convert_file_attribute_flags(info.dwFileAttributes);
    return(result);
}

internal
system_get_file_list_sig(){
    File_List result = {};
    String_Const_u8 search_pattern = {};
    if (character_is_slash(string_get_character(directory, directory.size - 1))){
        search_pattern = push_u8_stringf(arena, "%.*s*", string_expand(directory));
    }
    else{
        search_pattern = push_u8_stringf(arena, "%.*s\\*", string_expand(directory));
    }
    
    WIN32_FIND_DATA find_data = {};
    HANDLE search = FindFirstFile_utf8(arena, search_pattern.str, &find_data);
    if (search != INVALID_HANDLE_VALUE){
        File_Info *first = 0;
        File_Info *last = 0;
        i32 count = 0;
        
        for (;;){
            String_Const_u16 file_name_utf16 = SCu16(find_data.cFileName);
            if (!(string_match(file_name_utf16, string_u16_litexpr(L".")) ||
                  string_match(file_name_utf16, string_u16_litexpr(L"..")))){
                String_Const_u8 file_name = string_u8_from_string_u16(arena, file_name_utf16,
                                                                      StringFill_NullTerminate).string;
                
                File_Info *info = push_array(arena, File_Info, 1);
                sll_queue_push(first, last, info);
                count += 1;
                
                info->file_name = file_name;
                info->attributes.size = win32_u64_from_u32_u32(find_data.nFileSizeHigh,
                                                               find_data.nFileSizeLow);
                info->attributes.last_write_time = win32_u64_from_filetime(find_data.ftLastWriteTime);
                info->attributes.flags = win32_convert_file_attribute_flags(find_data.dwFileAttributes);
            }
            if (!FindNextFile(search, &find_data)){
                break;
            }
        }
        
        result.infos = push_array(arena, File_Info*, count);
        result.count = count;
        
        i32 counter = 0;
        for (File_Info *node = first;
             node != 0;
             node = node->next){
            result.infos[counter] = node;
            counter += 1;
        }
        FindClose(search);
    }
    
    return(result);
}

internal
system_quick_file_attributes_sig(){
    WIN32_FILE_ATTRIBUTE_DATA info = {};
    File_Attributes result = {};
    if (GetFileAttributesEx_utf8String(scratch, file_name, GetFileExInfoStandard, &info)){
        result.size = ((u64)info.nFileSizeHigh << 32LL) | ((u64)info.nFileSizeLow);
        result.last_write_time = ((u64)info.ftLastWriteTime.dwHighDateTime << 32LL) | ((u64)info.ftLastWriteTime.dwLowDateTime);
        result.flags = win32_convert_file_attribute_flags(info.dwFileAttributes);
    }
    return(result);
}

internal
system_load_handle_sig(){
    b32 result = false;
    HANDLE file = CreateFile_utf8(scratch, (u8*)file_name, GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    if (file != INVALID_HANDLE_VALUE){
        *(HANDLE*)out = file;
        result = true;
    }
    return(result);
}

internal
system_load_attributes_sig(){
    HANDLE file = *(HANDLE*)(&handle);
    return(win32_file_attributes_from_HANDLE(file));
}

internal
system_load_file_sig(){
    HANDLE file = *(HANDLE*)(&handle);
    DWORD read_size = 0;
    b32 result = false;
    if (ReadFile(file, buffer, size, &read_size, 0)){
        if (read_size == size){
            result = true;
        }
    }
    return(result);
}

internal
system_load_close_sig(){
    b32 result = false;
    HANDLE file = *(HANDLE*)(&handle);
    if (CloseHandle(file)){
        result = true;
    }
    return(result);
}

internal
system_save_file_sig(){
    File_Attributes result = {};
    
    HANDLE file = CreateFile_utf8(scratch, (u8*)file_name, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
    
    if (file != INVALID_HANDLE_VALUE){
        u64 written_total = 0;
        
        b32 success = true;
        for (;written_total < data.size;){
            DWORD read_size = max_u32;
            DWORD write_size = 0;
            if ((data.size - written_total) < max_u32){
                read_size = (DWORD)data.size;
            }
            if (!WriteFile(file, data.str + written_total, read_size, &write_size, 0)){
                success = false;
                break;
            }
            written_total += write_size;
        }
        
        if (success){
            result = win32_file_attributes_from_HANDLE(file);
        }
        
        CloseHandle(file);
    }
    
    return(result);
}

////////////////////////////////

internal ARGB_Color
swap_r_and_b(ARGB_Color a){
    ARGB_Color result = a & 0xff00ff00;
    result |= ((a >> 16) & 0xff);
    result |= ((a & 0xff) << 16);
    return(result);
}

internal ARGB_Color
int_color_from_colorref(COLORREF ref, ARGB_Color alpha_from){
    ARGB_Color rgb = swap_r_and_b(ref & 0xffffff);
    ARGB_Color result = ((0xff000000 & alpha_from) | rgb);
    return(result);
}

internal UINT_PTR CALLBACK
color_picker_hook(HWND Window, UINT Message, WPARAM WParam, LPARAM LParam){
    UINT_PTR result = 0;
    switch(Message)
    {
        // TODO(allen): review
        case WM_INITDIALOG:
        {
            CHOOSECOLORW *win32_params = (CHOOSECOLORW *)LParam;
            Color_Picker *picker = (Color_Picker*)win32_params->lCustData;
            SetWindowLongPtr(Window, GWLP_USERDATA, (LONG_PTR)LParam);
            
            Scratch_Block scratch(win32vars.tctx);
            String_u16 temp = string_u16_from_string_u8(scratch, picker->title, StringFill_NullTerminate);
            SetWindowTextW(Window, (LPCWSTR)temp.str);
        } break;
        
        case WM_CTLCOLORSTATIC:
        {
            // NOTE(casey): I can't believe I'm 42 years old and I still have to do
            // this fucking crap. Microsoft is so fucking fired every god damn day.
            // Would it have killed you to update rgbResult continuously, or at least
            // provide a GetCurrentColor() call???
            //
            // Anyway, since the color picker doesn't tell us when the color is
            // changed, what we do is watch for messages that repaint the color
            // swatch, which is dialog id 0x2c5, and then we sample it to see what
            // color it is. No, I'm not fucking kidding, that's what we do.
            HWND swatch_window = (HWND)LParam;
            if(GetDlgCtrlID(swatch_window) == 0x2c5)
            {
                CHOOSECOLORW *win32_params =
                (CHOOSECOLORW *)GetWindowLongPtr(Window, GWLP_USERDATA);
                if(win32_params)
                {
                    Color_Picker *picker = (Color_Picker*)win32_params->lCustData;
                    
                    RECT rect;
                    GetClientRect(swatch_window, &rect);
                    HDC swatch_dc = (HDC)WParam;
                    COLORREF Probe = GetPixel(swatch_dc,
                                              (rect.left + rect.right)/4,
                                              (rect.top + rect.bottom)/2);
                    ARGB_Color new_color =
                        int_color_from_colorref(Probe, *picker->dest);
                    
                    if(*picker->dest != new_color)
                    {
                        *picker->dest = new_color;
                        system_signal_step(0);
                    }
                }
            }
        } break;
        
        default:
        {
#if 0
            // NOTE(casey): Enable this if you want to dump the color edit dialog messages to the debug log
            short Temp[256];
            wsprintf((LPWSTR)Temp, L"%u 0x%x 0x%x\n", Message, WParam, LParam);
            OutputDebugStringW((LPWSTR)Temp);
#endif
        } break;
    }
    
    return(result);
}

// TODO(allen): review
internal DWORD WINAPI
color_picker_thread(LPVOID Param)
{
    Color_Picker *picker = (Color_Picker*)Param;
    
    ARGB_Color color = 0;
    if (picker->dest){
        color = *picker->dest;
    }
    
    COLORREF custom_colors[16] = {};
    
    CHOOSECOLORW win32_params = {};
    win32_params.lStructSize = sizeof(win32_params);
    //win32_params.hwndOwner = win32vars.window_handle;
    win32_params.hInstance = win32vars.window_handle;
    win32_params.rgbResult = swap_r_and_b(color) & 0xffffff;
    win32_params.lpCustColors = custom_colors;
    win32_params.Flags = CC_RGBINIT | CC_FULLOPEN | CC_ANYCOLOR | CC_ENABLEHOOK;
    win32_params.lCustData = (LPARAM)picker;
    win32_params.lpfnHook = color_picker_hook;
    
    if (ChooseColorW(&win32_params)){
        color = int_color_from_colorref(win32_params.rgbResult, color);
    }
    
    if(picker->dest){
        *picker->dest = color;
    }
    
    if (picker->finished){
        *picker->finished = true;
    }
    
    system_memory_free(picker, sizeof(*picker));
    
    return(0);
}

internal
system_open_color_picker_sig(){
    // TODO(allen): review
    // NOTE(casey): Because this is going to be used by a semi-permanent thread, we need to
    // copy it to system memory where it can live as long as it wants, no matter what we do
    // over here on the 4coder threads.
    Color_Picker *perm = (Color_Picker*)system_memory_allocate(sizeof(Color_Picker), string_u8_litexpr(file_name_line_number));
    *perm = *picker;
    
    HANDLE ThreadHandle = CreateThread(0, 0, color_picker_thread, perm, 0, 0);
    CloseHandle(ThreadHandle);
}

internal
system_get_screen_scale_factor_sig(){
    return(win32vars.screen_scale_factor);
}

// BOTTOM



// end --- win32_4ed_functions.cpp --- 



// begin --- win32_audio.cpp --- 

////////////////////////////////
// NOTE(allen): Quick Mutex

// TODO(allen): intrinsics wrappers
#include <intrin.h>

function u32
AtomicAddU32AndReturnOriginal(u32 volatile *Value, u32 Addend)
{
    // NOTE(casey): Returns the original value _prior_ to adding
    u32 Result = _InterlockedExchangeAdd((long volatile*)Value, (long)Addend);
    return(Result);
}

global volatile u32 win32_audio_ticket = 0;
global volatile u32 win32_audio_serving = 0;

function void
win32_audio_begin_ticket_mutex(void)
{
    u32 Ticket = AtomicAddU32AndReturnOriginal(&win32_audio_ticket, 1);
    while(Ticket != win32_audio_serving) {_mm_pause();}
}
function void
win32_audio_end_ticket_mutex(void)
{
    AtomicAddU32AndReturnOriginal(&win32_audio_serving, 1);
}

////////////////////////////////
// NOTE(allen): Fallback Mixers

function void
win32_default_mix_sources(void *ctx, f32 *mix_buffer, u32 sample_count){
}

function void
win32_default_mix_destination(i16 *dst, f32 *src, u32 sample_count){
    u32 opl = sample_count*2;
    for(u32 i = 0; i < sample_count; i += 1){
        dst[i] = (i16)src[i];
    }
}

////////////////////////////////
// NOTE(allen): Win32 Audio System API

internal
system_set_source_mixer_sig(){
    win32_audio_begin_ticket_mutex();
    win32vars.audio_mix_ctx = ctx;
    win32vars.audio_mix_sources = mix_func;
    win32_audio_end_ticket_mutex();
}

internal
system_set_destination_mixer_sig(){
    win32_audio_begin_ticket_mutex();
    win32vars.audio_mix_destination = mix_func;
    win32_audio_end_ticket_mutex();
}

////////////////////////////////
// NOTE(allen): Win32 Audio Loop

function b32
win32_submit_audio(HWAVEOUT WaveOut, WAVEHDR *Header, u32 SampleCount, f32 *mix_buffer){
    b32 Result = false;
    
    // NOTE(allen): prep buffers
    u32 mix_buffer_size = SampleCount*2*sizeof(f32);
    memset(mix_buffer, 0, mix_buffer_size);
    i16 *Samples = (i16 *)Header->lpData;
    
    // NOTE(allen): prep mixer pointers
    win32_audio_begin_ticket_mutex();
    void *audio_mix_ctx = win32vars.audio_mix_ctx;
    Audio_Mix_Sources_Function *audio_mix_sources = win32vars.audio_mix_sources;
    Audio_Mix_Destination_Function *audio_mix_destination = win32vars.audio_mix_destination;
    win32_audio_end_ticket_mutex();
    
    if (audio_mix_sources == 0){
        audio_mix_sources = win32_default_mix_sources;
    }
    if (audio_mix_destination == 0){
        audio_mix_destination = win32_default_mix_destination;
    }
    
    // NOTE(allen): mix
    audio_mix_sources(audio_mix_ctx, mix_buffer, SampleCount);
    audio_mix_destination(Samples, mix_buffer, SampleCount);
    
    // NOTE(allen): send final samples to win32
    DWORD Error = waveOutPrepareHeader(WaveOut, Header, sizeof(*Header));
    if(Error == MMSYSERR_NOERROR)
    {
        Error = waveOutWrite(WaveOut, Header, sizeof(*Header));
        if(Error == MMSYSERR_NOERROR)
        {
            // NOTE(casey): Success
            Result = true;
        }
    }
    
    return(Result);
}

function DWORD WINAPI
win32_audio_loop(void *Passthrough){
    //
    // NOTE(casey): Set up our audio output buffer
    //
    u32 SamplesPerSecond = 48000;
    u32 SamplesPerBuffer = 16*SamplesPerSecond/1000;
    u32 ChannelCount = 2;
    u32 BytesPerChannelValue = 2;
    u32 BytesPerSample = ChannelCount*BytesPerChannelValue;
    
    u32 BufferCount = 3;
    u32 BufferSize = SamplesPerBuffer*BytesPerSample;
    u32 HeaderSize = sizeof(WAVEHDR);
    u32 TotalBufferSize = (BufferSize+HeaderSize);
    u32 MixBufferSize = (SamplesPerBuffer*ChannelCount*sizeof(f32));
    u32 TotalAudioMemorySize = BufferCount*TotalBufferSize + MixBufferSize;
    
    //
    // NOTE(casey): Initialize audio out
    //
    HWAVEOUT WaveOut = {};
    
    WAVEFORMATEX Format = {};
    Format.wFormatTag = WAVE_FORMAT_PCM;
    Format.nChannels = (WORD)ChannelCount;
    Format.wBitsPerSample = (WORD)(8*BytesPerChannelValue);
    Format.nSamplesPerSec = SamplesPerSecond;
    Format.nBlockAlign = (Format.nChannels*Format.wBitsPerSample)/8;
    Format.nAvgBytesPerSec = Format.nBlockAlign * Format.nSamplesPerSec;
    
    b32 quit = false;
    
    void *MixBuffer = 0;
    void *AudioBufferMemory = 0;
    if(waveOutOpen(&WaveOut, WAVE_MAPPER, &Format, GetCurrentThreadId(), 0, CALLBACK_THREAD) == MMSYSERR_NOERROR)
    {
        AudioBufferMemory = VirtualAlloc(0, TotalAudioMemorySize, MEM_COMMIT, PAGE_READWRITE);
        if(AudioBufferMemory)
        {
            u8 *At = (u8 *)AudioBufferMemory;
			MixBuffer = At;
            At += MixBufferSize;
            
            for(u32 BufferIndex = 0;
                BufferIndex < BufferCount;
                ++BufferIndex)
            {
                WAVEHDR *Header = (WAVEHDR *)At;
                Header->lpData = (char *)(Header + 1);
                Header->dwBufferLength = BufferSize;
                
                At += TotalBufferSize;
                
                win32_submit_audio(WaveOut, Header, SamplesPerBuffer, (f32*)MixBuffer);
            }
        }
        else
        {
            // TODO(allen): audio error
            quit = true;
        }
    }
    else
    {
        // TODO(allen): audio error
        quit = true;
    }
    
    //
    // NOTE(casey): Serve audio forever (until we are told to stop)
    //
    
    SetTimer(0, 0, 100, 0);
    for (;!quit;)
    {
        MSG Message = {};
        GetMessage(&Message, 0, 0, 0);
        if(Message.message == MM_WOM_DONE)
        {
            WAVEHDR *Header = (WAVEHDR *)Message.lParam;
            if(Header->dwFlags & WHDR_DONE)
            {
                Header->dwFlags &= ~WHDR_DONE;
            }
            
            waveOutUnprepareHeader(WaveOut, Header, sizeof(*Header));
            
            win32_submit_audio(WaveOut, Header, SamplesPerBuffer, (f32*)MixBuffer);
        }
    }
    
    if(WaveOut)
    {
        waveOutClose(WaveOut);
    }
    
    if(AudioBufferMemory)
    {
        VirtualFree(AudioBufferMemory, 0, MEM_RELEASE);
    }
    
    return(0);
}

function DWORD
win32_audio_init(void){
    DWORD thread_id = 0;
    HANDLE handle = CreateThread(0, 0, win32_audio_loop, 0, 0, &thread_id);
    CloseHandle(handle);
    return(thread_id);
}


// end --- win32_audio.cpp --- 



////////////////////////////////

internal
system_load_library_sig(){
    HMODULE lib = LoadLibrary_utf8String(scratch, file_name);
    b32 result = false;
    if (lib != 0){
        result = true;
        *out = handle_type(lib);
    }
    return(result);
}

internal
system_release_library_sig(){
    HMODULE lib = (HMODULE)handle_type(handle);
    return(FreeLibrary(lib));
}

internal
system_get_proc_sig(){
    HMODULE lib = (HMODULE)handle_type(handle);
    return((Void_Func*)(GetProcAddress(lib, proc_name)));
}

//-

internal void
system_schedule_step(u32 code){
    PostMessage(win32vars.window_handle, WM_4coder_ANIMATE, code, 0);
}

//-

// NOTE(jack): Query win32 API to get montior refresh rate.
internal u64
win32_get_frame_rate() {
    u64 frame_rate = 60;
    
    DEVMODE device_mode = { 0 };
    // memset(&device_mode, 0, sizeof(DEVMODE));
    device_mode.dmSize = sizeof(DEVMODE);
    device_mode.dmDriverExtra = 0;
    
    // If the Display settings can be retrieved use the device's refresh rate
    if(EnumDisplaySettings(NULL, ENUM_CURRENT_SETTINGS, &device_mode) != 0){
        frame_rate = device_mode.dmDisplayFrequency;
    }
    
    return frame_rate;
}


//-

internal void
win32_toggle_fullscreen(){
    HWND win = win32vars.window_handle;
    DWORD style = GetWindowLongW(win, GWL_STYLE);
    b32 is_full = ((style & WS_OVERLAPPEDWINDOW) == 0);
    if (!is_full){
        MONITORINFO info = {sizeof(MONITORINFO)};
        if (GetWindowPlacement(win, &win32vars.bordered_win_pos) && GetMonitorInfo(MonitorFromWindow(win, MONITOR_DEFAULTTOPRIMARY), &info)){
            SetWindowLongW(win, GWL_STYLE, style & ~WS_OVERLAPPEDWINDOW);
            
            i32 x = info.rcMonitor.left;
            i32 y = info.rcMonitor.top;
            i32 w = info.rcMonitor.right - info.rcMonitor.left;
            i32 h = info.rcMonitor.bottom - info.rcMonitor.top;
            
            SetWindowPos(win, HWND_TOP, x, y, w, h, SWP_NOOWNERZORDER | SWP_FRAMECHANGED | SWP_SHOWWINDOW);
            win32vars.full_screen = true;
        }
    }
    else{
        SetWindowLongW(win, GWL_STYLE, style | WS_OVERLAPPEDWINDOW);
        SetWindowPlacement(win, &win32vars.bordered_win_pos);
        SetWindowPos(win, 0, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_FRAMECHANGED);
        win32vars.full_screen = false;
    }
}

// TODO(allen): add a "shown but auto-hides on timer" setting here.
internal
system_show_mouse_cursor_sig(){
    win32vars.cursor_show = show;
}

internal
system_set_fullscreen_sig(){
    // NOTE(allen): If the new value of full_screen does not match the current value,
    // set toggle to true.
    win32vars.do_toggle = (win32vars.full_screen != full_screen);
    b32 success = true;
    return(success);
}

internal
system_is_fullscreen_sig(){
    // NOTE(allen): Report the fullscreen status as it would be set at the beginning of the
    // next frame. That is, take into account all fullscreen toggle requests that have come in
    // already this frame. Read: "full_screen XOR do_toggle"
    b32 result = (win32vars.full_screen != win32vars.do_toggle);
    return(result);
}

internal
system_get_keyboard_modifiers_sig(){
    return(copy_modifier_set(arena, &win32vars.input_chunk.pers.modifiers));
}

internal
system_set_key_mode_sig(){
    win32vars.key_mode = mode;
}

//-
// NOTE(allen): Clipboard

internal String_Const_u8
win32_read_clipboard_contents(Thread_Context *tctx, Arena *arena){
    Scratch_Block scratch(tctx, arena);
    
    String_Const_u8 result = {};
    
    if (OpenClipboard(win32vars.window_handle)){
        b32 got_result = false;
        if (!got_result){
            HANDLE clip_data = GetClipboardData(CF_UNICODETEXT);
            if (clip_data != 0){
                u16 *clip_16_ptr = (u16*)GlobalLock(clip_data);
                if (clip_16_ptr != 0){
                    String_Const_u16 clip_16 = SCu16(clip_16_ptr);
                    got_result = true;
                    result = string_u8_from_string_u16(arena, clip_16, StringFill_NullTerminate).string;
                }
                GlobalUnlock(clip_data);
            }
        }
        if (!got_result){
            HANDLE clip_data = GetClipboardData(CF_TEXT);
            if (clip_data != 0){
                char *clip_ascii_ptr = (char*)GlobalLock(clip_data);
                if (clip_ascii_ptr != 0){
                    String_Const_char clip_ascii = SCchar(clip_ascii_ptr);
                    got_result = true;
                    result = string_u8_from_string_char(arena, clip_ascii, StringFill_NullTerminate).string;
                }
                GlobalUnlock(clip_data);
            }
        }
        CloseClipboard();
    }
    
    
    return(result);
}

internal void
win32_post_clipboard(Arena *scratch, char *text, i32 len){
    if (OpenClipboard(win32vars.window_handle)){
        if (!EmptyClipboard()){
            String_Const_u8 error_string = win32_get_error_string();
            win32_output_error_string(error_string);
        }
        HANDLE memory_handle = GlobalAlloc(GMEM_MOVEABLE, len  + 1);
        if (memory_handle){
            char *dest = (char*)GlobalLock(memory_handle);
            memmove(dest, text, len);
            dest[len] = 0;
            GlobalUnlock(memory_handle);
            SetClipboardData(CF_TEXT, memory_handle);
        }
        CloseClipboard();
        win32vars.clipboard_sequence = GetClipboardSequenceNumber();
    }
}

internal
system_get_clipboard_sig(){
    String_Const_u8 result = {};
    DWORD new_number = GetClipboardSequenceNumber();
    if (new_number != win32vars.clipboard_sequence){
        result = win32_read_clipboard_contents(win32vars.tctx, arena);
        if (result.str != 0){
            win32vars.clipboard_sequence = new_number;
        }
    }
    return(result);
}

internal
system_post_clipboard_sig(){
    Arena *arena = &win32vars.clip_post_arena;
    if (arena->base_allocator == 0){
        *arena = make_arena_system();
    }
    else{
        linalloc_clear(arena);
    }
    win32vars.clip_post.str = push_array(arena, u8, str.size + 1);
    if (win32vars.clip_post.str != 0){
        block_copy(win32vars.clip_post.str, str.str, str.size);
        win32vars.clip_post.str[str.size] = 0;
        win32vars.clip_post.size = str.size;
    }
    else{
        log_os("Failed to allocate buffer for clipboard post (%d)\n", (i32)str.size + 1);
    }
}

internal
system_set_clipboard_catch_all_sig(){
    win32vars.clip_catch_all = enabled?true:false;
}

internal
system_get_clipboard_catch_all_sig(){
    return(win32vars.clip_catch_all);
}

//
// Command Line Exectuion
//

internal
system_cli_call_sig(){
    Assert(sizeof(Plat_Handle) >= sizeof(HANDLE));
    
    char cmd[] = "c:\\windows\\system32\\cmd.exe";
    char *env_variables = 0;
    
    Temp_Memory temp = begin_temp(scratch);
    String_Const_u8 s = push_u8_stringf(scratch, "/C %s", script);
    
    b32 success = false;
    
    *(HANDLE*)&cli_out->proc = INVALID_HANDLE_VALUE;
    *(HANDLE*)&cli_out->out_read = INVALID_HANDLE_VALUE;
    *(HANDLE*)&cli_out->out_write = INVALID_HANDLE_VALUE;
    *(HANDLE*)&cli_out->in_read = INVALID_HANDLE_VALUE;
    *(HANDLE*)&cli_out->in_write = INVALID_HANDLE_VALUE;
    
    SECURITY_ATTRIBUTES security_atrb = {};
    security_atrb.nLength = sizeof(SECURITY_ATTRIBUTES);
    security_atrb.bInheritHandle = TRUE;
    
    HANDLE out_read = INVALID_HANDLE_VALUE;
    HANDLE out_write = INVALID_HANDLE_VALUE;
    if (CreatePipe(&out_read, &out_write, &security_atrb, 0)){
        if (SetHandleInformation(out_read, HANDLE_FLAG_INHERIT, 0)){
            STARTUPINFO startup = {};
            startup.cb = sizeof(STARTUPINFO);
            startup.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
            
            HANDLE in_read = CreateFileA("nul", GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE, &security_atrb, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
            
            startup.hStdInput = in_read;
            startup.hStdOutput = out_write;
            startup.hStdError = out_write;
            startup.wShowWindow = SW_HIDE;
            
            PROCESS_INFORMATION info = {};
            if (CreateProcess_utf8(scratch, (u8*)cmd, s.str, 0, 0, TRUE, 0, env_variables, (u8*)path, &startup, &info)){
                success = true;
                CloseHandle(info.hThread);
                *(HANDLE*)&cli_out->proc = info.hProcess;
                *(HANDLE*)&cli_out->out_read = out_read;
                *(HANDLE*)&cli_out->out_write = out_write;
                
                ++win32vars.running_cli;
            }
            else{
                CloseHandle(out_read);
                CloseHandle(out_write);
                CloseHandle(in_read);
            }
        }
        else{
            // TODO(allen): failed SetHandleInformation
            CloseHandle(out_read);
            CloseHandle(out_write);
        }
    }
    else{
        // TODO(allen): failed CreatePipe
    }
    
    end_temp(temp);
    
    return(success);
}

struct CLI_Loop_Control{
    u32 remaining_amount;
};

internal
system_cli_begin_update_sig(){
    Assert(sizeof(cli->scratch_space) >= sizeof(CLI_Loop_Control));
    CLI_Loop_Control *loop = (CLI_Loop_Control*)cli->scratch_space;
    loop->remaining_amount = 0;
}

internal
system_cli_update_step_sig(){
    HANDLE handle = *(HANDLE*)&cli->out_read;
    CLI_Loop_Control *loop = (CLI_Loop_Control*)cli->scratch_space;
    b32 has_more = 0;
    DWORD remaining = loop->remaining_amount;
    u32 pos = 0;
    DWORD read_amount = 0;
    
    for (;;){
        if (remaining == 0){
            if (!PeekNamedPipe(handle, 0, 0, 0, &remaining, 0)) break;
            if (remaining == 0) break;
        }
        
        if (remaining + pos < max){
            has_more = 1;
            ReadFile(handle, dest + pos, remaining, &read_amount, 0);
            Assert(remaining == read_amount);
            pos += remaining;
            remaining = 0;
        }
        else{
            has_more = 1;
            ReadFile(handle, dest + pos, max - pos, &read_amount, 0);
            Assert(max - pos == read_amount);
            loop->remaining_amount = remaining - (max - pos);
            pos = max;
            break;
        }
    }
    *amount = pos;
    
    return(has_more);
}

internal
system_cli_end_update_sig(){
    b32 close_me = false;
    HANDLE proc = *(HANDLE*)&cli->proc;
    DWORD result = 0;
    
    if (WaitForSingleObject(proc, 0) == WAIT_OBJECT_0){
        if (GetExitCodeProcess(proc, &result) == 0){
            cli->exit = -1;
        }
        else{
            cli->exit = (i32)result;
        }
        
        close_me = true;
        CloseHandle(*(HANDLE*)&cli->proc);
        CloseHandle(*(HANDLE*)&cli->out_read);
        CloseHandle(*(HANDLE*)&cli->out_write);
        if (*(HANDLE*)&cli->in_read != INVALID_HANDLE_VALUE){
            CloseHandle(*(HANDLE*)&cli->in_read);
        }
        if (*(HANDLE*)&cli->in_write != INVALID_HANDLE_VALUE){
            CloseHandle(*(HANDLE*)&cli->in_write);
        }
        
        --win32vars.running_cli;
    }
    
    return(close_me);
}

function void
os_popup_error(char *title, char *message){
    MessageBoxA(0, message, title, MB_OK);
    ExitProcess(1);
}

#if defined( WIN32_DX11 )

// begin --- win32_dx11.cpp --- 


#include <initguid.h>
#include <d3d11_1.h>
#include <dxgi1_3.h>
#include <d3dcompiler.h>

#if !SHIP_MODE
#include <dxgidebug.h>
IDXGIDebug1* dxgi_debug;
#endif

internal LRESULT CALL_CONVENTION
win32_proc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

internal b32
win32_gl_create_window(HWND *wnd_out, DWORD style, RECT rect){
    
    local_persist b32 srgb_support = false;
    local_persist b32 first_call = true;
    
    b32 result = false;
    
    *wnd_out = 0;
    
    Assert( g_dx11.initialized == 0 );
    Assert( g_dx11.device == 0 );
    Assert( g_dx11.context == 0 );
    Assert( g_dx11.swap_chain == 0 );
    Assert( g_dx11.sampler == 0 );
    Assert( g_dx11.render_target_view == 0 );
    Assert( g_dx11.gpu_program.vertex == 0 );
    Assert( g_dx11.gpu_program.layout == 0 );
    Assert( g_dx11.gpu_program.pixel == 0 );
    Assert( g_dx11.gpu_program.valid == 0 );
    Assert( g_dx11.vertex_buffer == 0 );
    Assert( g_dx11.constants_buffer == 0 );
    Assert( g_dx11.texture_count == 0 );
    
    g_dx11 = { };
    
    HINSTANCE this_instance = GetModuleHandle(0);
    
    HWND wnd = 0;
    
    ID3D11Device* base_device = 0;
    ID3D11DeviceContext* base_device_context = 0;
    IDXGIDevice1* dxgi_device = 0;
    IDXGIAdapter* dxgi_adapter = 0;
    IDXGIFactory2* dxgi_factory = 0;
    
    ID3D11BlendState* blend_state = 0;
    ID3D11RasterizerState1* rasterizer_state = 0;
    
    do {
        
        // NOTE(simon, 28/02/24): There is nothing in the code suggesting that this function could
        // be called several time. If it is called several time, we would need to make sure that
        // we cleaned up previous dx11 resources. The reason this function could be called twice
        // would be if it failed previously, and in that case we clean up everything before
        // exiting the function so we should be good. Still we assume it's only ever call once.
        Assert( first_call );
        
        if (first_call){
            
            first_call = false;
            
            log_os( " Registering graphics class...\n" );
            
            WNDCLASSW wndclass = {};
            wndclass.style = CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS;
            wndclass.lpfnWndProc = win32_proc;
            wndclass.hIcon = LoadIconW(GetModuleHandle(0), L"main");
            wndclass.hInstance = this_instance;
            wndclass.lpszClassName = L"GRAPHICS-WINDOW-NAME";
            if (RegisterClassW(&wndclass) == 0){
                log_os("  Failed.\n");
                break;
            }
        }
        
        log_os( " Creating graphics window...\n" );
        
        wnd = CreateWindowExW(0, L"GRAPHICS-WINDOW-NAME", L"GRAPHICS", style,
                              CW_USEDEFAULT, CW_USEDEFAULT, rect.right - rect.left, rect.bottom - rect.top,
                              0, 0, this_instance, 0);
        
        if (wnd == 0) {
            log_os( "  Failed.\n" );
            break;
        }
        
        log_os( " Creating a d3d11 hardware device and context...\n" );
        // NOTE(simon, 28/02/24): We are creating a directx 11.1 device and context (supported
        // since windows 8).
        D3D_FEATURE_LEVEL feature_levels[ ] = { D3D_FEATURE_LEVEL_11_1 };
        
        u32 device_flags = 0;
        // device_flags = D3D11_CREATE_DEVICE_BGRA_SUPPORT;
        
#if !SHIP_MODE
        device_flags |= D3D11_CREATE_DEVICE_DEBUG;
#endif
        
        HRESULT hr = D3D11CreateDevice( 0, D3D_DRIVER_TYPE_HARDWARE, 0, device_flags, feature_levels, ArrayCount( feature_levels ), D3D11_SDK_VERSION, &base_device, 0, &base_device_context );
        
        if ( FAILED( hr ) ) {
            log_os( "  Failed.\n" );
            log_os( " Creating a d3d11 software (WARP) device and context...\n" );
            // NOTE(simon, 28/02/24): Try creating a high performance software device as a fallback.
            hr = D3D11CreateDevice( 0, D3D_DRIVER_TYPE_WARP, 0, device_flags, feature_levels, ArrayCount( feature_levels ), D3D11_SDK_VERSION, &base_device, 0, &base_device_context );
        }
        
        if ( FAILED( hr ) ) {
            log_os( "  Failed.\n" );
            break;
        }
        
        log_os( " Creating a ID3D11Device1...\n" );
        hr = base_device->QueryInterface( __uuidof( ID3D11Device1 ), ( void** ) &g_dx11.device );
        
        if ( FAILED( hr ) ) {
            log_os( "  Failed.\n" );
            break;
        }
        
        log_os( " Creating a ID3D11DeviceContext1...\n" );
        hr = base_device_context->QueryInterface( __uuidof( ID3D11DeviceContext1 ), ( void** ) &g_dx11.context );
        
        if ( FAILED( hr ) ) {
            log_os( "  Failed.\n" );
            break;
        }
        
        ID3D11Device1* device = g_dx11.device;
        ID3D11DeviceContext1* context = g_dx11.context;
        
#if !SHIP_MODE
        log_os( " Getting ID3D11InfoQueue. This is not important if you're not debugging graphics...\n" );
        ID3D11InfoQueue* info;
        hr = device->QueryInterface( __uuidof( ID3D11InfoQueue ), ( void** ) &info );
        
        if ( FAILED( hr ) ) {
            log_os( "  Failed.\n" );
        } else {
            info->SetBreakOnSeverity( D3D11_MESSAGE_SEVERITY_CORRUPTION, TRUE );
            info->SetBreakOnSeverity( D3D11_MESSAGE_SEVERITY_ERROR, TRUE );
            info->Release( );
        }
        
        log_os( " Getting IDXGIDebug1. This is not important if you're not debugging graphics...\n" );
        hr = DXGIGetDebugInterface1( 0, __uuidof( IDXGIDebug1 ), ( void** ) &dxgi_debug );
        
        if ( FAILED( hr ) ) {
            log_os( "  Failed.\n" );
        }
#endif
        
        // NOTE(simon, 28/02/24): sRGB should be supported by any hardware now, but there was a
        // check so I added one. The OpenGL version never enables sRGB.
        DXGI_FORMAT back_buffer_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
        UINT format_support = 0;
        
        if ( SUCCEEDED( device->CheckFormatSupport( back_buffer_format, &format_support ) ) ) {
            u32 required = D3D11_FORMAT_SUPPORT_RENDER_TARGET | D3D11_FORMAT_SUPPORT_DISPLAY;
            srgb_support = ( ( format_support & required ) == required );
        }
        
        if ( !srgb_support ) {
            log_os( " sRBG back buffer not supported.\n" );
            back_buffer_format = DXGI_FORMAT_R8G8B8A8_UNORM;
        } else {
            log_os( " sRBG back buffer supported.\n" );
        }
        
        log_os( " Getting a IDXGIFactory2...\n" );
        
        log_os( "  Qurey for the IDXGIDevice1...\n" );
        hr = device->QueryInterface( __uuidof( IDXGIDevice1 ), ( void** ) &dxgi_device );
        
        if ( FAILED( hr ) ) {
            log_os( "   Failed.\n" );
            break;
        }
        
        log_os( "  Getting the IDXGIAdapter...\n" );
        dxgi_device->GetAdapter( &dxgi_adapter );
        
        if ( FAILED( hr ) ) {
            log_os( "   Failed.\n" );
            break;
        }
        
        log_os( "  Getting the IDXGIFactor2...\n" );
        dxgi_adapter->GetParent( __uuidof( IDXGIFactory2 ), ( void** ) &dxgi_factory );
        
        if ( FAILED( hr ) ) {
            log_os( "   Failed.\n" );
            break;
        }
        
        DXGI_SWAP_CHAIN_DESC1 swap_chain_desc = { };
        // NOTE(simon, 28/02/24): Can't request sRGB format here when using FLIP_* swap chain. It's
        // requested when creating the render target view.
        swap_chain_desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        swap_chain_desc.SampleDesc.Count = 1;
        swap_chain_desc.SampleDesc.Quality = 0;
        swap_chain_desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
        swap_chain_desc.BufferCount = 2;
        swap_chain_desc.Scaling = DXGI_SCALING_NONE;
        swap_chain_desc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
        
        log_os( " Creating a IDXGISwapChain1...\n" );
        hr = dxgi_factory->CreateSwapChainForHwnd( device, wnd, &swap_chain_desc, 0, 0, &g_dx11.swap_chain );
        
        if ( FAILED( hr ) ) {
            log_os( "  Failed.\n" );
            break;
        }
        
        log_os( " Prevent DXGI handling ALT + ENTER...\n" );
        hr = dxgi_factory->MakeWindowAssociation( wnd, DXGI_MWA_NO_ALT_ENTER );
        
        if ( FAILED( hr ) ) {
            log_os( "  Failed.\n" );
        }
        
        // NOTE(simon, 28/02/24): We setup alpha blending here as it's always on in 4coder.
        D3D11_BLEND_DESC blend_state_desc = { };
        blend_state_desc.RenderTarget[ 0 ].BlendEnable = TRUE;
        blend_state_desc.RenderTarget[ 0 ].SrcBlend = D3D11_BLEND_SRC_ALPHA;
        blend_state_desc.RenderTarget[ 0 ].DestBlend = D3D11_BLEND_INV_SRC_ALPHA;
        blend_state_desc.RenderTarget[ 0 ].BlendOp = D3D11_BLEND_OP_ADD;
        blend_state_desc.RenderTarget[ 0 ].SrcBlendAlpha = D3D11_BLEND_SRC_ALPHA;
        blend_state_desc.RenderTarget[ 0 ].DestBlendAlpha = D3D11_BLEND_INV_SRC_ALPHA;
        blend_state_desc.RenderTarget[ 0 ].BlendOpAlpha = D3D11_BLEND_OP_ADD;
        blend_state_desc.RenderTarget[ 0 ].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
        
        log_os( " Creating a blend state...\n" );
        hr = device->CreateBlendState( &blend_state_desc, &blend_state );
        
        if ( FAILED( hr ) ) {
            log_os( "  Failed.\n" );
            break;
        }
        
        context->OMSetBlendState( blend_state, 0, 0xffffffff );
        
        // NOTE(simon, 28/02/24): Enable scissor and disable backface culling.
        D3D11_RASTERIZER_DESC1 rasterizer_desc = { };
        rasterizer_desc.FillMode = D3D11_FILL_SOLID;
        rasterizer_desc.CullMode = D3D11_CULL_NONE;
        rasterizer_desc.DepthClipEnable = TRUE;
        rasterizer_desc.ScissorEnable = TRUE;
        
        log_os( " Creating a rasterizer state...\n" );
        hr = device->CreateRasterizerState1( &rasterizer_desc, &rasterizer_state );
        
        if ( FAILED( hr ) ) {
            log_os( "  Failed.\n" );
            break;
        }
        
        context->RSSetState( rasterizer_state );
        
        // NOTE(simon, 28/02/24): Not setting depth stencil as 4coder doesn't use it.
        // NOTE(simon, 28/02/24): Swap interval is a parameter of swap_chain->present.
        
        D3D11_SAMPLER_DESC linear_desc = { };
        linear_desc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
        linear_desc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
        linear_desc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
        linear_desc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
        linear_desc.ComparisonFunc = D3D11_COMPARISON_NEVER;
        linear_desc.MinLOD = 0;
        linear_desc.MaxLOD = D3D11_FLOAT32_MAX;
        
        log_os( " Creating a sampler state...\n" );
        hr = device->CreateSamplerState( &linear_desc, &g_dx11.sampler );
        
        if ( FAILED( hr ) ) {
            log_os( "  Failed.\n" );
            break;
        }
        
        // NOTE(simon, 28/02/24): We create the vertex buffer, constants buffers and shader here
        // because if we can't create them we won't be able to render anything and so we should
        // just exit the program.
        
        D3D11_BUFFER_DESC vertex_buffer_desc = { };
        // NOTE(simon, 28/02/24): Reserving 400K vertices which is about 11 megabytes and would
        // allow 100K characters. On a 1080p monitor, with 4 by 10 pixels characters we would need
        // (1920/4)*(1080/10) = 51840 characters to fill the screen.
        vertex_buffer_desc.ByteWidth = 400000 * sizeof( Render_Vertex );
        vertex_buffer_desc.Usage = D3D11_USAGE_DYNAMIC;
        vertex_buffer_desc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
        vertex_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
        
        log_os( " Creating a vertex buffer...\n" );
        hr = device->CreateBuffer( &vertex_buffer_desc, 0, &g_dx11.vertex_buffer );
        
        if ( FAILED( hr ) ) {
            log_os( "  Failed.\n" );
            break;
        }
        
        D3D11_BUFFER_DESC constants_buffer_desc = { };
        // NOTE(simon, 28/02/24): constants buffer size needs to be a multiple of 16.
        // NOTE(simon, 28/02/24): The layout is explained where we set the values in the buffer in
        // gl_render.
        constants_buffer_desc.ByteWidth = 32;
        constants_buffer_desc.Usage = D3D11_USAGE_DYNAMIC;
        constants_buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
        constants_buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
        
        log_os( " Creating a constants buffer...\n" );
        hr = device->CreateBuffer( &constants_buffer_desc, 0, &g_dx11.constants_buffer );
        
        if ( FAILED( hr ) ) {
            log_os( "  Failed.\n" );
            break;
        }
        
        g_dx11.gpu_program = gl__make_program( gl__vertex, gl__fragment );
        
        if ( !g_dx11.gpu_program.valid ) {
            break;
        }
        
        *wnd_out = wnd;
        // NOTE(simon, 28/02/24): Reserve the first texture slot as a invalid/unbind texture.
        g_dx11.texture_count = 1;
        g_dx11.initialized = true;
        result = true;
        
    } while ( 0 );
    
    if ( !result ) {
        
        if ( wnd ) {
            DestroyWindow( wnd );
            ( *wnd_out ) = 0;
        }
        
        if ( g_dx11.context ) {
            g_dx11.context->OMSetBlendState( 0, 0, 0xffffffff );
            g_dx11.context->RSSetState( 0 );
        }
        
        if ( g_dx11.constants_buffer ) {
            g_dx11.constants_buffer->Release( );
            g_dx11.constants_buffer = 0;
        }
        
        if ( g_dx11.vertex_buffer ) {
            g_dx11.vertex_buffer->Release( );
            g_dx11.vertex_buffer = 0;
        }
        
        if ( g_dx11.gpu_program.valid ) {
            
            if ( g_dx11.gpu_program.vertex ) {
                g_dx11.gpu_program.vertex->Release( );
                g_dx11.gpu_program.vertex = 0;
            }
            
            if ( g_dx11.gpu_program.layout ) {
                g_dx11.gpu_program.layout->Release( );
                g_dx11.gpu_program.layout = 0;
            }
            
            if ( g_dx11.gpu_program.pixel ) {
                g_dx11.gpu_program.pixel->Release( );
                g_dx11.gpu_program.pixel = 0;
            }
        }
        
        // NOTE(simon, 28/02/24): No render target view at this point as it's created in the
        // WM_SIZE message.
        
        if ( g_dx11.sampler ) {
            g_dx11.sampler->Release( );
            g_dx11.sampler = 0;
        }
        
        if ( g_dx11.swap_chain ) {
            g_dx11.swap_chain->Release( );
            g_dx11.swap_chain = 0;
        }
        
        if ( g_dx11.context ) {
            g_dx11.context->Release( );
            g_dx11.context = 0;
        }
        
        if ( g_dx11.device ) {
            g_dx11.device->Release( );
            g_dx11.device = 0;
        }
        
        g_dx11.initialized = false;
        
#if SHIP_MODE
        os_popup_error( "Error", "Window creation failed.");
#endif
    }
    
    if( base_device ) {
        base_device->Release( );
        base_device = 0;
    }
    
    if ( base_device_context ) {
        base_device_context->Release( );
        base_device_context = 0;
    }
    
    if ( dxgi_device ) {
        dxgi_device->Release( );
        dxgi_device = 0;
    }
    
    if ( dxgi_adapter ) {
        dxgi_adapter->Release( );
        dxgi_adapter = 0;
    }
    
    if ( dxgi_factory ) {
        dxgi_factory->Release( );
        dxgi_factory = 0;
    }
    
    if ( blend_state ) {
        blend_state->Release( );
        blend_state = 0;
    }
    
    if ( rasterizer_state ) {
        rasterizer_state->Release( );
        rasterizer_state = 0;
    }
    
    return(result);
}

#if !SHIP_MODE

// NOTE(simon, 28/02/24): Only call this when working on 4coder, to make sure we don't do something
// stupid. In SHIP_MODE we let the os clean up resources.
internal void
win32_gl_cleanup( void ) {
    
    if ( dxgi_debug && g_dx11.initialized ) {
        
        OutputDebugString( L"win32_gl_cleanup start report...\n" );
        dxgi_debug->ReportLiveObjects( DXGI_DEBUG_ALL, DXGI_DEBUG_RLO_ALL );
        
        g_dx11.initialized = false;
        
        if ( g_dx11.context ) {
            g_dx11.context->OMSetBlendState( 0, 0, 0xffffffff );
            g_dx11.context->RSSetState( 0 );
        }
        
        for ( u32 i = 1; i < g_dx11.texture_count; i++ ) {
            
            DX11Texture* texture = g_dx11.textures + i;
            
            if ( texture->view ) {
                texture->view->Release( );
                texture->view = 0;
            }
            
            if ( texture->pointer ) {
                texture->pointer->Release( );
                texture->pointer = 0;
            }
        }
        
        g_dx11.texture_count = 0;
        
        if ( g_dx11.constants_buffer ) {
            g_dx11.constants_buffer->Release( );
            g_dx11.constants_buffer = 0;
        }
        
        if ( g_dx11.vertex_buffer ) {
            g_dx11.vertex_buffer->Release( );
            g_dx11.vertex_buffer = 0;
        }
        
        if ( g_dx11.gpu_program.valid ) {
            
            if ( g_dx11.gpu_program.vertex ) {
                g_dx11.gpu_program.vertex->Release( );
                g_dx11.gpu_program.vertex = 0;
            }
            
            if ( g_dx11.gpu_program.layout ) {
                g_dx11.gpu_program.layout->Release( );
                g_dx11.gpu_program.layout = 0;
            }
            
            if ( g_dx11.gpu_program.pixel ) {
                g_dx11.gpu_program.pixel->Release( );
                g_dx11.gpu_program.pixel = 0;
            }
        }
        
        if ( g_dx11.render_target_view ) {
            g_dx11.render_target_view->Release( );
            g_dx11.render_target_view = 0;
        }
        
        if ( g_dx11.sampler ) {
            g_dx11.sampler->Release( );
            g_dx11.sampler = 0;
        }
        
        if ( g_dx11.swap_chain ) {
            g_dx11.swap_chain->Release( );
            g_dx11.swap_chain = 0;
        }
        
        if ( g_dx11.context ) {
            g_dx11.context->Release( );
            g_dx11.context = 0;
        }
        
        if ( g_dx11.device ) {
            g_dx11.device->Release( );
            g_dx11.device = 0;
        }
        
        OutputDebugString( L"win32_gl_cleanup end report (nothing printed after this line means everything is OK)...\n" );
        dxgi_debug->ReportLiveObjects( DXGI_DEBUG_ALL, DXGI_DEBUG_RLO_ALL );
    }
}
#endif

// end --- win32_dx11.cpp --- 


#else

// begin --- win32_opengl.cpp --- 



// begin --- win32_gl.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 27.01.2017
 *
 * WGL declarations for 4coder.
 *
 */

// TOP

#define WGL_NUMBER_PIXEL_FORMATS_ARB            0x2000
#define WGL_DRAW_TO_WINDOW_ARB                  0x2001
#define WGL_DRAW_TO_BITMAP_ARB                  0x2002
#define WGL_ACCELERATION_ARB                    0x2003
#define WGL_NEED_PALETTE_ARB                    0x2004
#define WGL_NEED_SYSTEM_PALETTE_ARB             0x2005
#define WGL_SWAP_LAYER_BUFFERS_ARB              0x2006
#define WGL_SWAP_METHOD_ARB                     0x2007
#define WGL_NUMBER_OVERLAYS_ARB                 0x2008
#define WGL_NUMBER_UNDERLAYS_ARB                0x2009
#define WGL_TRANSPARENT_ARB                     0x200A
#define WGL_TRANSPARENT_RED_VALUE_ARB           0x2037
#define WGL_TRANSPARENT_GREEN_VALUE_ARB         0x2038
#define WGL_TRANSPARENT_BLUE_VALUE_ARB          0x2039
#define WGL_TRANSPARENT_ALPHA_VALUE_ARB         0x203A
#define WGL_TRANSPARENT_INDEX_VALUE_ARB         0x203B
#define WGL_SHARE_DEPTH_ARB                     0x200C
#define WGL_SHARE_STENCIL_ARB                   0x200D
#define WGL_SHARE_ACCUM_ARB                     0x200E
#define WGL_SUPPORT_GDI_ARB                     0x200F
#define WGL_SUPPORT_OPENGL_ARB                  0x2010
#define WGL_DOUBLE_BUFFER_ARB                   0x2011
#define WGL_STEREO_ARB                          0x2012
#define WGL_PIXEL_TYPE_ARB                      0x2013
#define WGL_COLOR_BITS_ARB                      0x2014
#define WGL_RED_BITS_ARB                        0x2015
#define WGL_RED_SHIFT_ARB                       0x2016
#define WGL_GREEN_BITS_ARB                      0x2017
#define WGL_GREEN_SHIFT_ARB                     0x2018
#define WGL_BLUE_BITS_ARB                       0x2019
#define WGL_BLUE_SHIFT_ARB                      0x201A
#define WGL_ALPHA_BITS_ARB                      0x201B
#define WGL_ALPHA_SHIFT_ARB                     0x201C
#define WGL_ACCUM_BITS_ARB                      0x201D
#define WGL_ACCUM_RED_BITS_ARB                  0x201E
#define WGL_ACCUM_GREEN_BITS_ARB                0x201F
#define WGL_ACCUM_BLUE_BITS_ARB                 0x2020
#define WGL_ACCUM_ALPHA_BITS_ARB                0x2021
#define WGL_DEPTH_BITS_ARB                      0x2022
#define WGL_STENCIL_BITS_ARB                    0x2023
#define WGL_AUX_BUFFERS_ARB                     0x2024
#define WGL_NO_ACCELERATION_ARB                 0x2025
#define WGL_GENERIC_ACCELERATION_ARB            0x2026
#define WGL_FULL_ACCELERATION_ARB               0x2027
#define WGL_SWAP_EXCHANGE_ARB                   0x2028
#define WGL_SWAP_COPY_ARB                       0x2029
#define WGL_SWAP_UNDEFINED_ARB                  0x202A
#define WGL_TYPE_RGBA_ARB                       0x202B
#define WGL_TYPE_COLORINDEX_ARB                 0x202C

#define WGL_CONTEXT_MAJOR_VERSION_ARB           0x2091
#define WGL_CONTEXT_MINOR_VERSION_ARB           0x2092
#define WGL_CONTEXT_LAYER_PLANE_ARB             0x2093
#define WGL_CONTEXT_FLAGS_ARB                   0x2094
#define WGL_FRAMEBUFFER_SRGB_CAPABLE_ARB        0x20A9
#define WGL_CONTEXT_PROFILE_MASK_ARB            0x9126
#define WGL_CONTEXT_DEBUG_BIT_ARB               0x0001
#define WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB  0x0002
#define WGL_CONTEXT_CORE_PROFILE_BIT_ARB        0x00000001
#define WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB 0x00000002
#define ERROR_INVALID_VERSION_ARB               0x2095
#define ERROR_INVALID_PROFILE_ARB               0x2096

// BOTTOM



// end --- win32_gl.h --- 



#include <GL/gl.h>
#define GL_FUNC(N,R,P) typedef R (CALL_CONVENTION N##_Function)P; N##_Function *N = 0;

internal b32
win32_wgl_good(Void_Func *f){
    return(f != 0 &&
           f != (Void_Func*)1 &&
           f != (Void_Func*)2 &&
           f != (Void_Func*)3 &&
           f != (Void_Func*)-1);
}

typedef HGLRC (CALL_CONVENTION wglCreateContextAttribsARB_Function)(HDC,HGLRC,i32*);
typedef BOOL  (CALL_CONVENTION wglChoosePixelFormatARB_Function)(HDC,i32*,f32*,u32,i32*,u32*);
typedef char* (CALL_CONVENTION wglGetExtensionsStringEXT_Function)();
typedef VOID  (CALL_CONVENTION wglSwapIntervalEXT_Function)(i32);

global wglCreateContextAttribsARB_Function *wglCreateContextAttribsARB = 0;
global wglChoosePixelFormatARB_Function *wglChoosePixelFormatARB = 0;
global wglGetExtensionsStringEXT_Function *wglGetExtensionsStringEXT = 0;
global wglSwapIntervalEXT_Function *wglSwapIntervalEXT = 0;

internal LRESULT CALL_CONVENTION
win32_proc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

internal b32
win32_gl_create_window(HWND *wnd_out, HGLRC *context_out, DWORD style, RECT rect){
    HINSTANCE this_instance = GetModuleHandle(0);
    
    local_persist b32 srgb_support = false;
    local_persist b32 register_success = true;
    local_persist b32 first_call = true;
    if (first_call){
        log_os(" GL bootstrapping...\n");
        
        first_call = false;
        
        // NOTE(allen): Create the GL bootstrap window
        log_os(" registering bootstrap class...\n");
        WNDCLASSW wglclass = {};
        wglclass.lpfnWndProc = DefWindowProcW;
        wglclass.hInstance = this_instance;
        wglclass.lpszClassName = L"wgl-loader";
        if (RegisterClassW(&wglclass) == 0){
            register_success = false;
            goto fail_register;
        }
        
        log_os(" creating bootstrap window...\n");
        HWND wglwindow = CreateWindowW(wglclass.lpszClassName, L"", 0, 0, 0, 0, 0,
                                       0, 0, this_instance, 0);
        if (wglwindow == 0){
            register_success = false;
            goto fail_register;
        }
        
        // NOTE(allen): Create the GL bootstrap context
        log_os(" setting bootstrap pixel format...\n");
        
        HDC wgldc = GetDC(wglwindow);
        
        PIXELFORMATDESCRIPTOR format = {};
        format.nSize = sizeof(format);
        format.nVersion = 1;
        format.dwFlags = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER;
        format.iPixelType = PFD_TYPE_RGBA;
        format.cColorBits = 32;
        format.cAlphaBits = 8;
        format.cDepthBits = 24;
        format.iLayerType = PFD_MAIN_PLANE;
        i32 suggested_format_index = ChoosePixelFormat(wgldc, &format);
        if (!SetPixelFormat(wgldc, suggested_format_index, &format)){
            register_success = false;
            goto fail_register;
        }
        
        log_os(" creating bootstrap GL context...\n");
        HGLRC wglcontext = wglCreateContext(wgldc);
        if (wglcontext == 0){
            register_success = false;
            goto fail_register;
        }
        
        log_os(" making bootstrap GL context current...\n");
        if (!wglMakeCurrent(wgldc, wglcontext)){
            register_success = false;
            goto fail_register;
        }
        
        // NOTE(allen): Load wgl extensions
        log_os(" loading wgl extensions...\n");
        
#define LoadWGL(f,l) Stmnt((f) = (f##_Function*)wglGetProcAddress(#f); \
(l) = (l) && win32_wgl_good((Void_Func*)(f));)
        
        b32 load_success = true;
        LoadWGL(wglCreateContextAttribsARB, load_success);
        LoadWGL(wglChoosePixelFormatARB, load_success);
        LoadWGL(wglGetExtensionsStringEXT, load_success);
        
        if (!load_success){
            register_success = false;
            goto fail_register;
        }
        
        log_os(" checking wgl extensions...\n");
        char *extensions_c = wglGetExtensionsStringEXT();
        String_Const_u8 extensions = SCu8((u8*)extensions_c);
        
        {
            String_Const_u8 s = string_skip_whitespace(extensions);
            for (;s.size > 0;){
                u64 end = string_find_first_whitespace(s);
                String_Const_u8 m = string_prefix(s, end);
                if (string_match(m, string_u8_litexpr("WGL_EXT_framebuffer_sRGB")) ||
                    string_match(m, string_u8_litexpr("WGL_ARB_framebuffer_sRGB"))){
                    srgb_support = true;
                }
                else if (string_match(m, string_u8_litexpr("WGL_EXT_swap_interval"))){
                    b32 wgl_swap_interval_ext = true;
                    LoadWGL(wglSwapIntervalEXT, wgl_swap_interval_ext);
                    if (!wgl_swap_interval_ext){
                        wglSwapIntervalEXT = 0;
                    }
                }
                s = string_skip_whitespace(string_skip(s, end));
            }
        }
        
        // NOTE(allen): Load gl functions
        log_os(" loading core GL functions...\n");
        
#define GL_FUNC(f,R,P) LoadWGL(f,load_success);
        
        if (!load_success){
            register_success = false;
            goto fail_register;
        }
        
        // NOTE(allen): Cleanup the GL bootstrap resources
        log_os(" cleaning up boostrap resources...\n");
        
        ReleaseDC(wglwindow, wgldc);
        DestroyWindow(wglwindow);
        wglDeleteContext(wglcontext);
        
        // NOTE(allen): Register the graphics window class
        log_os(" registering graphics class...\n");
        
        WNDCLASSW wndclass = {};
        wndclass.style = CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS;
        wndclass.lpfnWndProc = win32_proc;
        wndclass.hIcon = LoadIconW(GetModuleHandle(0), L"main");
        wndclass.hInstance = this_instance;
        wndclass.lpszClassName = L"GRAPHICS-WINDOW-NAME";
        if (RegisterClassW(&wndclass) == 0){
            register_success = false;
            goto fail_register;
        }
    }
    fail_register:;
    
    b32 result = false;
    if (register_success){
        // NOTE(allen): Create the graphics window
        log_os(" creating graphics window...\n");
        
        HWND wnd = CreateWindowExW(0, L"GRAPHICS-WINDOW-NAME", L"GRAPHICS", style,
                                   CW_USEDEFAULT, CW_USEDEFAULT, rect.right - rect.left, rect.bottom - rect.top,
                                   0, 0, this_instance, 0);
        
        *wnd_out = 0;
        *context_out = 0;
        if (wnd != 0){
            log_os(" setting graphics pixel format...\n");
            
            HDC dc = GetDC(wnd);
            
            PIXELFORMATDESCRIPTOR format = {};
            
            i32 pixel_attrib_list[] = {
                /* 0*/WGL_DRAW_TO_WINDOW_ARB, TRUE,
                /* 2*/WGL_ACCELERATION_ARB, WGL_FULL_ACCELERATION_ARB,
                /* 4*/WGL_SUPPORT_OPENGL_ARB, TRUE,
                /* 6*/WGL_DOUBLE_BUFFER_ARB, GL_TRUE,
                /* 8*/WGL_PIXEL_TYPE_ARB, WGL_TYPE_RGBA_ARB,
                /*10*/WGL_FRAMEBUFFER_SRGB_CAPABLE_ARB, GL_TRUE,
                /*12*/0,
            };
            if (!srgb_support){
                pixel_attrib_list[10] = 0;
            }
            
            i32 suggested_format_index = 0;
            u32 ignore = 0;
            if (!wglChoosePixelFormatARB(dc, pixel_attrib_list, 0, 1, &suggested_format_index, &ignore)){
                goto fail_window_init;
            }
            
            DescribePixelFormat(dc, suggested_format_index, sizeof(format), &format);
            if (!SetPixelFormat(dc, suggested_format_index, &format)){
                goto fail_window_init;
            }
            
            log_os(" setting graphics attributes...\n");
            
            i32 context_attrib_list[] = {
                /*0*/WGL_CONTEXT_MAJOR_VERSION_ARB, 3,
                /*2*/WGL_CONTEXT_MINOR_VERSION_ARB, 2,
                /*4*/WGL_CONTEXT_FLAGS_ARB, WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB
#if GL_DEBUG_MODE
                |WGL_CONTEXT_DEBUG_BIT_ARB
#endif
                ,
                /*6*/WGL_CONTEXT_PROFILE_MASK_ARB, WGL_CONTEXT_CORE_PROFILE_BIT_ARB,
                /*8*/0
            };
            
            log_os(" creating graphics GL context...\n");
            HGLRC context = wglCreateContextAttribsARB(dc, 0, context_attrib_list);
            if (context == 0){
                goto fail_window_init;
            }
            
            log_os(" making graphics GL context current...\n");
            wglMakeCurrent(dc, context);
            
            
            if (wglSwapIntervalEXT != 0){
                log_os(" setting swap interval...\n");
                wglSwapIntervalEXT(1);
            }
            *wnd_out = wnd;
            *context_out = context;
            result = true;
            
            if (false){
                fail_window_init:;
                DWORD error = GetLastError();
                ReleaseDC(wnd, dc);
                DestroyWindow(wnd);
                SetLastError(error);
            }
        }
    }
    
    return(result);
}

// end --- win32_opengl.cpp --- 


#endif

internal
graphics_get_texture_sig(){
    return(gl__get_texture(dim, texture_kind));
}

internal
graphics_fill_texture_sig(){
    return(gl__fill_texture(texture_kind, texture, p, dim, data));
}

internal
font_make_face_sig(){
    return(ft__font_make_face(arena, description, scale_factor));
}

//
// Helpers
//

global Key_Code keycode_lookup_table[255];

internal void
win32_keycode_init(void){
    for (u32 i = 'A'; i <= 'Z'; i += 1){
        keycode_lookup_table[i] = KeyCode_A + i - 'A';
    }
    for (u32 i = '0'; i <= '9'; i += 1){
        keycode_lookup_table[i] = KeyCode_0 + i - '0';
    }
    
    keycode_lookup_table[VK_SPACE] = KeyCode_Space;
    keycode_lookup_table[VK_OEM_3] = KeyCode_Tick;
    keycode_lookup_table[VK_OEM_MINUS] = KeyCode_Minus;
    keycode_lookup_table[VK_OEM_PLUS] = KeyCode_Equal;
    keycode_lookup_table[VK_OEM_4] = KeyCode_LeftBracket;
    keycode_lookup_table[VK_OEM_6] = KeyCode_RightBracket;
    keycode_lookup_table[VK_OEM_1] = KeyCode_Semicolon;
    keycode_lookup_table[VK_OEM_7] = KeyCode_Quote;
    keycode_lookup_table[VK_OEM_COMMA] = KeyCode_Comma;
    keycode_lookup_table[VK_OEM_PERIOD] = KeyCode_Period;
    keycode_lookup_table[VK_OEM_2] = KeyCode_ForwardSlash;
    keycode_lookup_table[VK_OEM_5] = KeyCode_BackwardSlash;
    
    keycode_lookup_table[VK_TAB] = KeyCode_Tab;
    keycode_lookup_table[VK_PAUSE] = KeyCode_Pause;
    keycode_lookup_table[VK_ESCAPE] = KeyCode_Escape;
    
    keycode_lookup_table[VK_UP] = KeyCode_Up;
    keycode_lookup_table[VK_DOWN] = KeyCode_Down;
    keycode_lookup_table[VK_LEFT] = KeyCode_Left;
    keycode_lookup_table[VK_RIGHT] = KeyCode_Right;
    
    keycode_lookup_table[VK_BACK] = KeyCode_Backspace;
    keycode_lookup_table[VK_RETURN] = KeyCode_Return;
    
    keycode_lookup_table[VK_DELETE] = KeyCode_Delete;
    keycode_lookup_table[VK_INSERT] = KeyCode_Insert;
    keycode_lookup_table[VK_HOME] = KeyCode_Home;
    keycode_lookup_table[VK_END] = KeyCode_End;
    keycode_lookup_table[VK_PRIOR] = KeyCode_PageUp;
    keycode_lookup_table[VK_NEXT] = KeyCode_PageDown;
    
    keycode_lookup_table[VK_CAPITAL] = KeyCode_CapsLock;
    keycode_lookup_table[VK_NUMLOCK] = KeyCode_NumLock;
    keycode_lookup_table[VK_SCROLL] = KeyCode_ScrollLock;
    keycode_lookup_table[VK_APPS] = KeyCode_Menu;
    
    keycode_lookup_table[VK_SHIFT] = KeyCode_Shift;
    keycode_lookup_table[VK_LSHIFT] = KeyCode_Shift;
    keycode_lookup_table[VK_RSHIFT] = KeyCode_Shift;
    
    keycode_lookup_table[VK_CONTROL] = KeyCode_Control;
    keycode_lookup_table[VK_LCONTROL] = KeyCode_Control;
    keycode_lookup_table[VK_RCONTROL] = KeyCode_Control;
    
    keycode_lookup_table[VK_MENU] = KeyCode_Alt;
    keycode_lookup_table[VK_LMENU] = KeyCode_Alt;
    keycode_lookup_table[VK_RMENU] = KeyCode_Alt;
    
    keycode_lookup_table[VK_F1] = KeyCode_F1;
    keycode_lookup_table[VK_F2] = KeyCode_F2;
    keycode_lookup_table[VK_F3] = KeyCode_F3;
    keycode_lookup_table[VK_F4] = KeyCode_F4;
    keycode_lookup_table[VK_F5] = KeyCode_F5;
    keycode_lookup_table[VK_F6] = KeyCode_F6;
    keycode_lookup_table[VK_F7] = KeyCode_F7;
    keycode_lookup_table[VK_F8] = KeyCode_F8;
    
    keycode_lookup_table[VK_F9] = KeyCode_F9;
    keycode_lookup_table[VK_F10] = KeyCode_F10;
    keycode_lookup_table[VK_F11] = KeyCode_F11;
    keycode_lookup_table[VK_F12] = KeyCode_F12;
    keycode_lookup_table[VK_F13] = KeyCode_F13;
    keycode_lookup_table[VK_F14] = KeyCode_F14;
    keycode_lookup_table[VK_F15] = KeyCode_F15;
    keycode_lookup_table[VK_F16] = KeyCode_F16;
    
    keycode_lookup_table[VK_F17] = KeyCode_F17;
    keycode_lookup_table[VK_F18] = KeyCode_F18;
    keycode_lookup_table[VK_F19] = KeyCode_F19;
    keycode_lookup_table[VK_F20] = KeyCode_F20;
    keycode_lookup_table[VK_F21] = KeyCode_F21;
    keycode_lookup_table[VK_F22] = KeyCode_F22;
    keycode_lookup_table[VK_F23] = KeyCode_F23;
    keycode_lookup_table[VK_F24] = KeyCode_F24;
    
    keycode_lookup_table[VK_NUMPAD0] = KeyCode_NumPad0;
    keycode_lookup_table[VK_NUMPAD1] = KeyCode_NumPad1;
    keycode_lookup_table[VK_NUMPAD2] = KeyCode_NumPad2;
    keycode_lookup_table[VK_NUMPAD3] = KeyCode_NumPad3;
    keycode_lookup_table[VK_NUMPAD4] = KeyCode_NumPad4;
    keycode_lookup_table[VK_NUMPAD5] = KeyCode_NumPad5;
    keycode_lookup_table[VK_NUMPAD6] = KeyCode_NumPad6;
    keycode_lookup_table[VK_NUMPAD7] = KeyCode_NumPad7;
    keycode_lookup_table[VK_NUMPAD8] = KeyCode_NumPad8;
    keycode_lookup_table[VK_NUMPAD9] = KeyCode_NumPad9;
    
    for (i32 i = 0; i < 30; i += 1){
        keycode_lookup_table[0xDF + i] = KeyCode_Ex0 + i;
    }
}

internal b32
keycode_physical_translation_is_wrong(u64 vk){
    b32 result = false;
    switch (vk){
        case VK_UP: case VK_DOWN: case VK_LEFT: case VK_RIGHT:
        case VK_DELETE:
        case VK_INSERT:
        case VK_HOME:
        case VK_END:
        case VK_PRIOR:
        case VK_NEXT:
        case VK_NUMPAD0:
        case VK_NUMPAD1:
        case VK_NUMPAD2:
        case VK_NUMPAD3:
        case VK_NUMPAD4:
        case VK_NUMPAD5:
        case VK_NUMPAD6:
        case VK_NUMPAD7:
        case VK_NUMPAD8:
        case VK_NUMPAD9:
        case VK_MULTIPLY:
        case VK_ADD     :
        case VK_SUBTRACT:
        case VK_DECIMAL :
        case VK_DIVIDE  :
        {
            result = true;
        }break;
        
    }
    return(result);
}

internal void
win32_resize(i32 width, i32 height){
    if (width > 0 && height > 0){
        target.width = width;
        target.height = height;
        
#if defined( WIN32_DX11 )
        
        HRESULT hr = S_OK;
        ID3D11Texture2D* frame_buffer = 0;
        
        do {
            
            if ( g_dx11.initialized ) {
                
                if ( g_dx11.render_target_view ) {
                    g_dx11.render_target_view->Release( );
                    g_dx11.render_target_view = 0;
                }
                
                hr = g_dx11.swap_chain->ResizeBuffers( 0, 0, 0, DXGI_FORMAT_UNKNOWN, 0 );
                
                if ( FAILED( hr ) ) {
                    log_os( "Failed to resize the swap chain buffers.\n" );
                    break;
                }
                
                hr = g_dx11.swap_chain->GetBuffer( 0, __uuidof( ID3D11Texture2D ), ( void** ) &frame_buffer );
                
                if ( FAILED( hr ) ) {
                    log_os( "Failled to get the swap chain back buffer.\n" );
                    break;
                }
                
                D3D11_RENDER_TARGET_VIEW_DESC render_target_view_desc = { 0 };
                // NOTE(simon, 28/02/24): 4coder checks for sRGB support but never actually enables
                // it in the OpenGL version (never calls glEnable( GL_FRAMEBUFFER_SRGB ) ).
                // Note that enabling it would require to convert collors
                // passed to the shader to linear (when using sRBG back buffer, the shader values
                // must be linear values). This would be more problematic than just passing linear
                // values as the blending wouldn't produce the same result as with sRGB off.
                // render_target_view_desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                render_target_view_desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
                render_target_view_desc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2D;
                
                hr = g_dx11.device->CreateRenderTargetView( ( ID3D11Resource* ) frame_buffer, &render_target_view_desc, &g_dx11.render_target_view );
                
                if ( FAILED( hr ) ) {
                    log_os( "Failed to create a render target view.\n" );
                    break;
                }
            }
            
        } while ( 0 );
        
        if ( frame_buffer ) {
            frame_buffer->Release( );
            frame_buffer = 0;
        }
        
        if ( FAILED( hr ) ) {
            
            if ( g_dx11.render_target_view ) {
                g_dx11.render_target_view->Release( );
                g_dx11.render_target_view = 0;
            }
            
            // NOTE(simon, 28/02/24): Failing here means no rendering possible, so we exit.
            exit( 1 );
        }
        
#endif
    }
}

internal void
Win32SetCursorFromUpdate(Application_Mouse_Cursor cursor){
    switch (cursor){
        case APP_MOUSE_CURSOR_ARROW:
        {
            SetCursor(win32vars.cursor_arrow);
        }break;
        
        case APP_MOUSE_CURSOR_IBEAM:
        {
            SetCursor(win32vars.cursor_ibeam);
        }break;
        
        case APP_MOUSE_CURSOR_LEFTRIGHT:
        {
            SetCursor(win32vars.cursor_leftright);
        }break;
        
        case APP_MOUSE_CURSOR_UPDOWN:
        {
            SetCursor(win32vars.cursor_updown);
        }break;
    }
}

internal Win32_Object*
win32_alloc_object(Win32_Object_Kind kind){
    Win32_Object *result = 0;
    if (win32vars.free_win32_objects.next != &win32vars.free_win32_objects){
        result = CastFromMember(Win32_Object, node, win32vars.free_win32_objects.next);
    }
    if (result == 0){
        i32 count = 512;
        Win32_Object *objects = (Win32_Object*)system_memory_allocate(count*sizeof(Win32_Object), file_name_line_number_lit_u8);
        objects[0].node.prev = &win32vars.free_win32_objects;
        win32vars.free_win32_objects.next = &objects[0].node;
        for (i32 i = 1; i < count; i += 1){
            objects[i - 1].node.next = &objects[i].node;
            objects[i].node.prev = &objects[i - 1].node;
        }
        objects[count - 1].node.next = &win32vars.free_win32_objects;
        win32vars.free_win32_objects.prev = &objects[count - 1].node;
        result = CastFromMember(Win32_Object, node, win32vars.free_win32_objects.next);
    }
    Assert(result != 0);
    dll_remove(&result->node);
    block_zero_struct(result);
    result->kind = kind;
    return(result);
}

internal void
win32_free_object(Win32_Object *object){
    if (object->node.next != 0){
        dll_remove(&object->node);
    }
    dll_insert(&win32vars.free_win32_objects, &object->node);
}

//-

internal
system_now_time_sig(){
    u64 result = 0;
    LARGE_INTEGER t;
    if (QueryPerformanceCounter(&t)){
        result = (u64)(t.QuadPart*win32vars.usecond_per_count);
    }
    return(result);
}

internal void
date_time_from_win32_system_time(Date_Time *out, SYSTEMTIME *in){
    out->year = in->wYear;
    out->mon = (u8)(in->wMonth - 1);
    out->day = (u8)(in->wDay - 1);
    out->hour = (u8)(in->wHour);
    out->min = (u8)(in->wMinute);
    out->sec = (u8)(in->wSecond);
    out->msec = in->wMilliseconds;
}

internal void
win32_system_time_from_date_time(SYSTEMTIME *out, Date_Time *in){
    out->wYear = (WORD)(in->year);
    out->wMonth = in->mon + 1;
    out->wDay = in->day + 1;
    out->wHour = in->hour;
    out->wMinute = in->min;
    out->wSecond = in->sec;
    out->wMilliseconds = in->msec;
}

internal
system_now_date_time_universal_sig(){
    SYSTEMTIME systime = {};
    GetSystemTime(&systime);
    Date_Time result = {};
    date_time_from_win32_system_time(&result, &systime);
    return(result);
}

internal
system_local_date_time_from_universal_sig(){
    SYSTEMTIME systime = {};
    win32_system_time_from_date_time(&systime, date_time);
    FILETIME ftime = {};
    SystemTimeToFileTime(&systime, &ftime);
    FILETIME ftime_local = {};
    FileTimeToLocalFileTime(&ftime, &ftime_local);
    FileTimeToSystemTime(&ftime_local, &systime);
    Date_Time result = {};
    date_time_from_win32_system_time(&result, &systime);
    return(result);
}

internal
system_universal_date_time_from_local_sig(){
    SYSTEMTIME systime = {};
    win32_system_time_from_date_time(&systime, date_time);
    FILETIME ftime = {};
    SystemTimeToFileTime(&systime, &ftime);
    FILETIME ftime_local = {};
    LocalFileTimeToFileTime(&ftime, &ftime_local);
    FileTimeToSystemTime(&ftime_local, &systime);
    Date_Time result = {};
    date_time_from_win32_system_time(&result, &systime);
    return(result);
}

internal
system_wake_up_timer_create_sig(){
    Win32_Object *object = win32_alloc_object(Win32ObjectKind_Timer);
    dll_insert(&win32vars.timer_objects, &object->node);
    object->timer.id = ++win32vars.timer_counter;
    return(handle_type(object));
}

internal
system_wake_up_timer_release_sig(){
    Win32_Object *object = (Win32_Object*)handle_type_ptr(handle);
    if (object->kind == Win32ObjectKind_Timer){
        KillTimer(win32vars.window_handle, object->timer.id);
        win32_free_object(object);
    }
}

internal
system_wake_up_timer_set_sig(){
    Win32_Object *object = (Win32_Object*)handle_type_ptr(handle);
    if (object->kind == Win32ObjectKind_Timer){
        object->timer.id = SetTimer(win32vars.window_handle, object->timer.id, time_milliseconds, 0);
    }
}

internal
system_signal_step_sig(){
    system_schedule_step(code);
}

internal
system_sleep_sig(){
    u32 milliseconds = (u32)(microseconds/Thousand(1));
    Sleep(milliseconds);
}

//-

internal DWORD CALL_CONVENTION
win32_thread_wrapper(void *ptr){
    Win32_Object *object = (Win32_Object*)ptr;
    Thread_Function *proc = object->thread.proc;
    void *object_ptr = object->thread.ptr;
    EnterCriticalSection(&win32vars.thread_launch_mutex);
    win32vars.waiting_for_launch = false;
    WakeConditionVariable(&win32vars.thread_launch_cv);
    LeaveCriticalSection(&win32vars.thread_launch_mutex);
    proc(object_ptr);
    return(0);
}

internal
system_thread_launch_sig(){
    Win32_Object *object = win32_alloc_object(Win32ObjectKind_Thread);
    object->thread.proc = proc;
    object->thread.ptr = ptr;
    EnterCriticalSection(&win32vars.thread_launch_mutex);
    win32vars.waiting_for_launch = true;
    object->thread.thread = CreateThread(0, 0, win32_thread_wrapper, object, 0, 0);
    for (;win32vars.waiting_for_launch;){
        SleepConditionVariableCS(&win32vars.thread_launch_cv, &win32vars.thread_launch_mutex, INFINITE);
    }
    LeaveCriticalSection(&win32vars.thread_launch_mutex);
    return(handle_type(object));
}

internal
system_thread_join_sig(){
    Win32_Object *object = (Win32_Object*)handle_type_ptr(thread);
    if (object->kind == Win32ObjectKind_Thread){
        WaitForSingleObject(object->thread.thread, INFINITE);
    }
}

internal
system_thread_free_sig(){
    Win32_Object *object = (Win32_Object*)handle_type_ptr(thread);
    if (object->kind == Win32ObjectKind_Thread){
        CloseHandle(object->thread.thread);
        win32_free_object(object);
    }
}

internal
system_thread_get_id_sig(){
    DWORD result = GetCurrentThreadId();
    return((i32)result);
}

internal
system_mutex_make_sig(){
    Win32_Object *object = win32_alloc_object(Win32ObjectKind_Mutex);
    InitializeCriticalSection(&object->mutex);
    return(handle_type(object));
}

internal
system_mutex_acquire_sig(){
    Win32_Object *object = (Win32_Object*)handle_type_ptr(mutex);
    if (object->kind == Win32ObjectKind_Mutex){
        EnterCriticalSection(&object->mutex);
    }
}

internal
system_mutex_release_sig(){
    Win32_Object *object = (Win32_Object*)handle_type_ptr(mutex);
    if (object->kind == Win32ObjectKind_Mutex){
        LeaveCriticalSection(&object->mutex);
    }
}

global i32 global_frame_mutex_state_ticker = 0;

internal
system_acquire_global_frame_mutex_sig(){
    if (tctx->kind == ThreadKind_AsyncTasks ||
        tctx->kind == ThreadKind_Main){
        system_mutex_acquire(win32vars.global_frame_mutex);
        Assert(global_frame_mutex_state_ticker == 0);
        global_frame_mutex_state_ticker = 1;
    }
}

internal
system_release_global_frame_mutex_sig(){
    if (tctx->kind == ThreadKind_AsyncTasks ||
        tctx->kind == ThreadKind_Main){
        Assert(global_frame_mutex_state_ticker == 1);
        global_frame_mutex_state_ticker = 0;
        system_mutex_release(win32vars.global_frame_mutex);
    }
}

internal
system_mutex_free_sig(){
    Win32_Object *object = (Win32_Object*)handle_type_ptr(mutex);
    if (object->kind == Win32ObjectKind_Mutex){
        DeleteCriticalSection(&object->mutex);
        win32_free_object(object);
    }
}

internal
system_condition_variable_make_sig(){
    Win32_Object *object = win32_alloc_object(Win32ObjectKind_CV);
    InitializeConditionVariable(&object->cv);
    return(handle_type(object));
}

internal
system_condition_variable_wait_sig(){
    Win32_Object *object_cv = (Win32_Object*)handle_type_ptr(cv);
    Win32_Object *object_mutex = (Win32_Object*)handle_type_ptr(mutex);
    if (object_cv->kind == Win32ObjectKind_CV &&
        object_mutex->kind == Win32ObjectKind_Mutex){
        SleepConditionVariableCS(&object_cv->cv, &object_mutex->mutex, INFINITE);
    }
}

internal
system_condition_variable_signal_sig(){
    Win32_Object *object = (Win32_Object*)handle_type_ptr(cv);
    if (object->kind == Win32ObjectKind_CV){
        WakeConditionVariable(&object->cv);
    }
}

internal
system_condition_variable_free_sig(){
    Win32_Object *object = (Win32_Object*)handle_type_ptr(cv);
    if (object->kind == Win32ObjectKind_CV){
        win32_free_object(object);
    }
}

//-

internal LRESULT CALL_CONVENTION
win32_proc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam){
    LRESULT result = 0;
    Scratch_Block scratch(win32vars.tctx);
    
    switch (uMsg){
        case WM_MENUCHAR:
        {
            result = (MNC_CLOSE << 16);
        }break;
        
        case WM_SYSKEYDOWN:
        case WM_SYSKEYUP:
        case WM_KEYDOWN:
        case WM_KEYUP:
        {
            b8 release = HasFlag(lParam, bit_32);
            b8 down = !release;
            b8 is_right = HasFlag(lParam, bit_25);
            
            u64 vk = wParam;
            
            if (win32vars.key_mode == KeyMode_Physical &&
                !keycode_physical_translation_is_wrong(vk)){
                UINT scan_code = ((lParam >> 16) & bitmask_8);
                vk = MapVirtualKeyEx(scan_code, MAPVK_VSC_TO_VK_EX, win32vars.kl_universal);
            }
            
            Input_Modifier_Set_Fixed *mods = &win32vars.input_chunk.pers.modifiers;
            
            Control_Keys *controls = &win32vars.input_chunk.pers.controls;
            switch (vk){
                case VK_CONTROL:case VK_LCONTROL:case VK_RCONTROL:
                case VK_MENU:case VK_LMENU:case VK_RMENU:
                {
                    switch (vk){
                        case VK_CONTROL:case VK_LCONTROL:case VK_RCONTROL:
                        {
                            if (is_right){
                                controls->r_ctrl = down;
                            }
                            else{
                                controls->l_ctrl = down;
                            }
                        }break;
                        case VK_MENU:case VK_LMENU:case VK_RMENU:
                        {
                            if (is_right){
                                controls->r_alt = down;
                            }
                            else{
                                controls->l_alt = down;
                            }
                        }break;
                    }
                }break;
            }
            
            b8 ctrl = (controls->r_ctrl || (controls->l_ctrl && !controls->r_alt));
            b8 alt = (controls->l_alt || (controls->r_alt && !controls->l_ctrl));
            if (win32vars.lctrl_lalt_is_altgr && controls->l_alt && controls->l_ctrl){
                ctrl = false;
                alt = false;
            }
            set_modifier(mods, KeyCode_Control, ctrl);
            set_modifier(mods, KeyCode_Alt, alt);
            
            {
                b8 shift = ((GetKeyState(VK_SHIFT) & bit_16) != 0);
                set_modifier(mods, KeyCode_Shift, shift);
            }
            
            Key_Code key = keycode_lookup_table[(u8)vk];
            if (down){
                if (key != 0){
                    add_modifier(mods, key);
                    
                    Input_Event *event = push_input_event(&win32vars.frame_arena, &win32vars.input_chunk.trans.event_list);
                    event->kind = InputEventKind_KeyStroke;
                    event->key.code = key;
                    event->key.modifiers = copy_modifier_set(&win32vars.frame_arena, mods);
                    win32vars.active_key_stroke = event;
                    
                    win32vars.got_useful_event = true;
                }
            }
            else{
                win32vars.active_key_stroke = 0;
                win32vars.active_text_input = 0;
                win32vars.got_useful_event = true;
                
                if (key != 0){
                    Input_Event *event = push_input_event(&win32vars.frame_arena, &win32vars.input_chunk.trans.event_list);
                    event->kind = InputEventKind_KeyRelease;
                    event->key.code = key;
                    event->key.modifiers = copy_modifier_set(&win32vars.frame_arena, mods);
                    
                    remove_modifier(mods, key);
                }
            }
        }break;
        
        case WM_CHAR:
        {
            u16 c = wParam & bitmask_16;
            if (c == '\r'){
                c = '\n';
            }
            if (c > 127 || (' ' <= c && c <= '~') || c == '\t' || c == '\n'){
                String_Const_u16 str_16 = SCu16(&c, 1);
                String_Const_u8 str_8 = string_u8_from_string_u16(&win32vars.frame_arena, str_16).string;
                Input_Event *event = push_input_event(&win32vars.frame_arena, &win32vars.input_chunk.trans.event_list);
                event->kind = InputEventKind_TextInsert;
                event->text.string = str_8;
                event->text.next_text = 0;
                event->text.blocked = false;
                if (win32vars.active_text_input != 0){
                    win32vars.active_text_input->text.next_text = event;
                }
                else if (win32vars.active_key_stroke != 0){
                    win32vars.active_key_stroke->key.first_dependent_text = event;
                }
                win32vars.active_text_input = event;
                
                win32vars.got_useful_event = true;
            }
        }break;
        
        case WM_DEADCHAR:
        {
            if (win32vars.active_key_stroke != 0){
                AddFlag(win32vars.active_key_stroke->key.flags, KeyFlag_IsDeadKey);
            }
        }break;
        
        case WM_UNICHAR:
        {
            if (wParam == UNICODE_NOCHAR){
                result = true;
            }
            else{
                u32 c = (u32)wParam;
                if (c == '\r'){
                    c= '\n';
                }
                if (c > 127 || (' ' <= c && c <= '~') || c == '\t' || c == '\n'){
                    String_Const_u32 str_32 = SCu32(&c, 1);
                    String_Const_u8 str_8 = string_u8_from_string_u32(&win32vars.frame_arena, str_32).string;
                    Input_Event event = {};
                    event.kind = InputEventKind_TextInsert;
                    event.text.string = str_8;
                    push_input_event(&win32vars.frame_arena, &win32vars.input_chunk.trans.event_list, &event);
                    win32vars.got_useful_event = true;
                }
            }
        }break;
        
        case WM_MOUSEMOVE:
        {
            Vec2_i32 new_m = V2i32(LOWORD(lParam), HIWORD(lParam));
            if (new_m != win32vars.input_chunk.pers.mouse){
                win32vars.input_chunk.pers.mouse = new_m;
                win32vars.got_useful_event = true;
            }
        }break;
        
        case WM_MOUSEWHEEL:
        {
            win32vars.got_useful_event = true;
            i32 rotation = GET_WHEEL_DELTA_WPARAM(wParam);
            if (rotation > 0){
                win32vars.input_chunk.trans.mouse_wheel = -100;
            }
            else{
                win32vars.input_chunk.trans.mouse_wheel =  100;
            }
        }break;
        
        case WM_LBUTTONDOWN:
        {
            SetCapture(hwnd);
            win32vars.got_useful_event = true;
            win32vars.input_chunk.trans.mouse_l_press = true;
            win32vars.input_chunk.pers.mouse_l = true;
        }break;
        
        case WM_RBUTTONDOWN:
        {
            SetCapture(hwnd);
            win32vars.got_useful_event = true;
            win32vars.input_chunk.trans.mouse_r_press = true;
            win32vars.input_chunk.pers.mouse_r = true;
        }break;
        
        case WM_LBUTTONUP:
        {
            ReleaseCapture();
            win32vars.got_useful_event = true;
            win32vars.input_chunk.trans.mouse_l_release = true;
            win32vars.input_chunk.pers.mouse_l = false;
        }break;
        
        case WM_RBUTTONUP:
        {
            ReleaseCapture();
            win32vars.got_useful_event = true;
            win32vars.input_chunk.trans.mouse_r_release = true;
            win32vars.input_chunk.pers.mouse_r = false;
        }break;
        
        case WM_KILLFOCUS:
        case WM_SETFOCUS:
        {
            ReleaseCapture();
            win32vars.got_useful_event = true;
            win32vars.input_chunk.pers.mouse_l = false;
            win32vars.input_chunk.pers.mouse_r = false;
            block_zero_struct(&win32vars.input_chunk.pers.controls);
            block_zero_struct(&win32vars.input_chunk.pers.modifiers);
            win32vars.active_key_stroke = 0;
            win32vars.active_text_input = 0;
        }break;
        
        case WM_SIZE:
        {
            win32vars.got_useful_event = true;
            i32 new_width = LOWORD(lParam);
            i32 new_height = HIWORD(lParam);
            
            win32_resize(new_width, new_height);
        }break;
        
        case WM_DISPLAYCHANGE:
        {
            win32vars.got_useful_event = true;
            
            LONG_PTR style = GetWindowLongPtr(hwnd, GWL_STYLE);
            if (!(style & WS_OVERLAPPEDWINDOW)){
                MONITORINFO monitor_info = {sizeof(MONITORINFO)};
                if(GetMonitorInfo(MonitorFromWindow(hwnd, MONITOR_DEFAULTTOPRIMARY), &monitor_info))
                {
                    SetWindowPos(hwnd, HWND_TOP,
                                 monitor_info.rcMonitor.left, monitor_info.rcMonitor.top,
                                 monitor_info.rcMonitor.right - monitor_info.rcMonitor.left,
                                 monitor_info.rcMonitor.bottom - monitor_info.rcMonitor.top,
                                 SWP_NOOWNERZORDER | SWP_FRAMECHANGED);
                }
            }
        }break;
        
        case WM_PAINT:
        {
            win32vars.got_useful_event = true;
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hwnd, &ps);
            // NOTE(allen): Do nothing?
            EndPaint(hwnd, &ps);
        }break;
        
        case WM_CLIPBOARDUPDATE:
        {
            if (win32vars.clip_catch_all){
                win32vars.got_useful_event = true;
                LogEventLit(win32vars.log_string(M), scratch, 0, 0, system_thread_get_id(),
                            "new clipboard contents");
            }
        }break;
        
        case WM_CLOSE:
        case WM_DESTROY:
        {
            win32vars.got_useful_event = true;
            win32vars.input_chunk.trans.trying_to_kill = true;
        }break;
        
        case WM_TIMER:
        {
            UINT_PTR timer_id = (UINT_PTR)wParam;
            KillTimer(win32vars.window_handle, timer_id);
            win32vars.got_useful_event = true;
        }break;
        
        case WM_4coder_ANIMATE:
        {
            win32vars.got_useful_event = true;
        }break;
        
        default:
        {
            result = DefWindowProc(hwnd, uMsg, wParam, lParam);
        }break;
    }
    
    return(result);
}

//-



//-

int CALL_CONVENTION
WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow){
    i32 argc = __argc;
    char **argv = __argv;
    
    // NOTE(allen): someone get my shit togeth :(er for me
    
    for (i32 i = 0; i < argc; i += 1){
        String_Const_u8 arg = SCu8(argv[i]);
        printf("arg[%d]: %.*s\n", i, string_expand(arg));
        if (string_match(arg, str8_lit("-L"))){
            log_os_enabled = true;
        }
    }
    
    log_os("Logging startup...\n");
    
    log_os("Initializing thread context...\n");
    
    // NOTE(allen): This thing
    InitializeCriticalSection(&memory_tracker_mutex);
    
    // NOTE(allen): context setup
    Thread_Context _tctx = {};
    thread_ctx_init(&_tctx, ThreadKind_Main, get_base_allocator_system(), get_base_allocator_system());
    
    block_zero_struct(&win32vars);
    win32vars.tctx = &_tctx;
    
    log_os("Filling API v-tables...\n");
    
    API_VTable_system system_vtable = {};
    system_api_fill_vtable(&system_vtable);
    
    API_VTable_graphics graphics_vtable = {};
    graphics_api_fill_vtable(&graphics_vtable);
    
    API_VTable_font font_vtable = {};
    font_api_fill_vtable(&font_vtable);
    
    log_os("Setting up memory management...\n");
    
    // NOTE(allen): memory
    win32vars.frame_arena = make_arena_system();
    // TODO(allen): *arena;
    target.arena = make_arena_system(KB(256));
    
    win32vars.cursor_show = MouseCursorShow_Always;
    win32vars.prev_cursor_show = MouseCursorShow_Always;
    
    log_os("Setting up threading primitives...\n");
    
    dll_init_sentinel(&win32vars.free_win32_objects);
    dll_init_sentinel(&win32vars.timer_objects);
    
    InitializeCriticalSection(&win32vars.thread_launch_mutex);
    InitializeConditionVariable(&win32vars.thread_launch_cv);
    
    log_os("Setting up DPI awareness...\n");
    
    SetProcessDPIAware();
    
    {
        HDC dc = GetDC(0);
        i32 x_dpi = GetDeviceCaps(dc, LOGPIXELSX);
        i32 y_dpi = GetDeviceCaps(dc, LOGPIXELSY);
        i32 max_dpi = max(x_dpi, y_dpi);
        win32vars.screen_scale_factor = ((f32)max_dpi)/96.f;
        ReleaseDC(0, dc);
        log_os(" detected dpi %f\n", win32vars.screen_scale_factor);
    }
    
    // NOTE(allen): load core
    log_os("Loading 4ed core...\n");
    
    System_Library core_library = {};
    App_Functions app = {};
    {
        App_Get_Functions *get_funcs = 0;
        Scratch_Block scratch(win32vars.tctx);
        
        List_String_Const_u8 search_list = {};
        def_search_list_add_system_path(scratch, &search_list, SystemPath_Binary);
        
        String_Const_u8 core_path =
            def_search_get_full_path(scratch, &search_list, SCu8("4ed_app.dll"));
        
        log_os(" path to core: '%.*s'\n", string_expand(core_path));
        
        if (system_load_library(scratch, core_path, &core_library)){
            get_funcs = (App_Get_Functions*)system_get_proc(core_library, "app_get_functions");
            if (get_funcs != 0){
                app = get_funcs();
            }
            else{
                char msg[] = "Failed to get application code from '4ed_app.dll'.";
                system_error_box(msg);
            }
        }
        else{
            char msg[] = "Could not load '4ed_app.dll'. This file should be in the same directory as the main '4ed' executable.";
            system_error_box(msg);
        }
    }
    
    log_os(" core loaded\n");
    
    // NOTE(allen): send system vtable to core
    log_os("Linking vtables...\n");
    
    app.load_vtables(&system_vtable, &font_vtable, &graphics_vtable);
    win32vars.log_string = app.get_logger();
    
    // NOTE(allen): init & command line parameters
    log_os("Parsing command line...\n");
    
    Plat_Settings plat_settings = {};
    void *base_ptr = 0;
    {
        Scratch_Block scratch(win32vars.tctx);
        String_Const_u8 curdir = system_get_path(scratch, SystemPath_CurrentDirectory);
        curdir = string_mod_replace_character(curdir, '\\', '/');
        char **files = 0;
        i32 *file_count = 0;
        base_ptr = app.read_command_line(win32vars.tctx, curdir, &plat_settings, &files, &file_count, argc, argv);
        {
            i32 end = *file_count;
            i32 i = 0, j = 0;
            for (; i < end; ++i){
                if (system_file_can_be_made(scratch, (u8*)files[i])){
                    files[j] = files[i];
                    ++j;
                }
            }
            *file_count = j;
        }
    }
    
    // NOTE(allen): setup user directory override
    log_os("User directory override: '%s'\n", plat_settings.user_directory);
    
    if (plat_settings.user_directory != 0){
        w32_override_user_directory = SCu8((u8*)plat_settings.user_directory);
    }
    
    // NOTE(allen): load custom layer
    log_os("Loading custom layer...\n");
    
    System_Library custom_library = {};
    Custom_API custom = {};
    {
        char custom_not_found_msg[] = "Did not find a library for the custom layer.";
        char custom_fail_version_msg[] = "Failed to load custom code due to missing version information or a version mismatch.  Try rebuilding with buildsuper.";
        char custom_fail_init_apis[] = "Failed to load custom code due to missing 'init_apis' symbol.  Try rebuilding with buildsuper";
        
        Scratch_Block scratch(win32vars.tctx);
        String_Const_u8 default_file_name = string_u8_litexpr("custom_4coder.dll");
        List_String_Const_u8 search_list = {};
        def_search_list_add_system_path(scratch, &search_list, SystemPath_UserDirectory);
        def_search_list_add_system_path(scratch, &search_list, SystemPath_Binary);
        
        if (log_os_enabled){
            log_os(" search list (paths):");
            for (Node_String_Const_u8 *node = search_list.first;
                 node != 0;
                 node = node->next){
                log_os("'%.*s'", string_expand(node->string));
                if (node->next != 0){
                    log_os(", ");
                }
            }
            log_os("\n");
        }
        
        String_Const_u8 custom_file_names[2] = {};
        i32 custom_file_count = 1;
        if (plat_settings.custom_dll != 0){
            custom_file_names[0] = SCu8(plat_settings.custom_dll);
            if (!plat_settings.custom_dll_is_strict){
                custom_file_names[1] = default_file_name;
                custom_file_count += 1;
            }
        }
        else{
            custom_file_names[0] = default_file_name;
        }
        
        log_os(" search list (file names): '%.*s', '%.*s'\n",
               string_expand(custom_file_names[0]), string_expand(custom_file_names[1]));
        
        String_Const_u8 custom_file_name = {};
        for (i32 i = 0; i < custom_file_count; i += 1){
            custom_file_name = def_search_get_full_path(scratch, &search_list, custom_file_names[i]);
            if (custom_file_name.size > 0){
                break;
            }
        }
        
        log_os(" trying to load: '%.*s'\n", string_expand(custom_file_name));
        
        b32 has_library = false;
        if (custom_file_name.size > 0){
            if (system_load_library(scratch, custom_file_name, &custom_library)){
                has_library = true;
            }
        }
        
        if (!has_library){
            system_error_box(custom_not_found_msg);
        }
        custom.get_version = (_Get_Version_Type*)system_get_proc(custom_library, "get_version");
        if (custom.get_version == 0 || custom.get_version(MAJOR, MINOR, PATCH) == 0){
            system_error_box(custom_fail_version_msg);
        }
        custom.init_apis = (_Init_APIs_Type*)system_get_proc(custom_library, "init_apis");
        if (custom.init_apis == 0){
            system_error_box(custom_fail_init_apis);
        }
    }
    
    log_os(" loaded successfully\n");
    
    // NOTE(allen): Window Init
    log_os("Initializing graphical window...\n");
    
    log_os(" getting initial settings...\n");
    RECT window_rect = {};
    if (plat_settings.set_window_size){
        window_rect.right = plat_settings.window_w;
        window_rect.bottom = plat_settings.window_h;
    }
    else{
        window_rect.right = 800;
        window_rect.bottom = 600;
    }
    AdjustWindowRect(&window_rect, WS_OVERLAPPEDWINDOW, false);
    i32 window_style = WS_OVERLAPPEDWINDOW;
    if (!plat_settings.fullscreen_window && plat_settings.maximize_window){
        window_style |= WS_MAXIMIZE;
    }
    log_os(" windowed dimensions: %d, %d\n"
           " initially maximized: %d\n",
           window_rect.right - window_rect.left,
           window_rect.bottom - window_rect.top,
           ((window_style & WS_MAXIMIZE) != 0));
    
#if defined( WIN32_DX11 )
    if( !win32_gl_create_window( &win32vars.window_handle, window_style, window_rect ) ) {
        exit(1);
    }
#else
    HGLRC window_opengl_context = 0;
    if (!win32_gl_create_window(&win32vars.window_handle, &window_opengl_context, window_style, window_rect)){
        exit(1);
    }
#endif
    
    log_os(" window created successfully\n");
    
    GetClientRect(win32vars.window_handle, &window_rect);
    win32_resize(window_rect.right - window_rect.left, window_rect.bottom - window_rect.top);
    
    // NOTE(allen): Audio Init
    log_os("Initializing audio...\n");
    win32vars.audio_thread_id = win32_audio_init();
    
    // NOTE(allen): Misc Init
    log_os("Initializing clipboard listener...\n");
    if (!AddClipboardFormatListener(win32vars.window_handle)){
        String_Const_u8 error_string = win32_get_error_string();
        win32_output_error_string(error_string);
    }
    win32vars.clip_wakeup_timer = system_wake_up_timer_create();
    win32vars.clipboard_sequence = 0;
    
    log_os("Setting up keyboard layout...\n");
    win32vars.kl_universal = LoadKeyboardLayoutW(L"00000409", 0);
    win32_keycode_init();
    
    log_os("Loading cursors...\n");
    win32vars.cursor_ibeam = LoadCursor(NULL, IDC_IBEAM);
    win32vars.cursor_arrow = LoadCursor(NULL, IDC_ARROW);
    win32vars.cursor_leftright = LoadCursor(NULL, IDC_SIZEWE);
    win32vars.cursor_updown = LoadCursor(NULL, IDC_SIZENS);
    
    log_os("Initializing performance counter...\n");
    LARGE_INTEGER f;
    if (QueryPerformanceFrequency(&f)){
        win32vars.usecond_per_count = 1000000.f/(f32)f.QuadPart;
    }
    else{
        // NOTE(allen): Just guess.
        win32vars.usecond_per_count = 1.f;
        log_os(" load failed, guessing usecond_per_count = 1\n");
    }
    if (win32vars.usecond_per_count <= 0.f){
        win32vars.usecond_per_count = 1.f;
    }
    
    //
    // App init
    //
    
    log_os("Initializing 4ed core...\n");
    {
        Scratch_Block scratch(win32vars.tctx);
        String_Const_u8 curdir = system_get_path(scratch, SystemPath_CurrentDirectory);
        curdir = string_mod_replace_character(curdir, '\\', '/');
        app.init(win32vars.tctx, &target, base_ptr, curdir, custom);
    }
    
    //
    // Main loop
    //
    
    log_os("Starting main loop...\n");
    
    b32 keep_running = true;
    win32vars.first = true;
    timeBeginPeriod(1);
    
    if (plat_settings.fullscreen_window){
        win32_toggle_fullscreen();
    }
    
    SetForegroundWindow(win32vars.window_handle);
    SetActiveWindow(win32vars.window_handle);
    ShowWindow(win32vars.window_handle, SW_SHOW);
    
    //- @Added by jack
    u64 frame_rate = win32_get_frame_rate();
    u64 frame_useconds = (1000000 / frame_rate);
    //-
    
    win32vars.global_frame_mutex = system_mutex_make();
    system_acquire_global_frame_mutex(win32vars.tctx);
    
    u64 timer_start = system_now_time();
    MSG msg;
    for (;keep_running;){
        linalloc_clear(&win32vars.frame_arena);
        block_zero_struct(&win32vars.input_chunk.trans);
        win32vars.active_key_stroke = 0;
        win32vars.active_text_input = 0;
        
        // TODO(allen): Find a good way to wait on a pipe
        // without interfering with the reading process.
        // NOTE(allen): Looks like we can ReadFile with a
        // size of zero in an IOCP for this effect.
        if (!win32vars.first){
            if (win32vars.running_cli == 0){
                win32vars.got_useful_event = false;
            }
            
            // NOTE(allen): while we're doing this (and possibly sleeping)
            // we can let async processes get there time in.
            system_release_global_frame_mutex(win32vars.tctx);
            
            b32 get_more_messages = true;
            do{
                if (win32vars.got_useful_event == 0){
                    get_more_messages = GetMessage(&msg, 0, 0, 0);
                }
                else{
                    get_more_messages = PeekMessage(&msg, 0, 0, 0, 1);
                }
                
                if (get_more_messages){
                    if (msg.message == WM_QUIT){
                        keep_running = false;
                    }
                    else{
                        b32 treat_normally = true;
                        if (msg.message == WM_KEYDOWN || msg.message == WM_SYSKEYDOWN){
                            switch (msg.wParam){
                                case VK_CONTROL:case VK_LCONTROL:case VK_RCONTROL:
                                case VK_MENU:case VK_LMENU:case VK_RMENU:
                                case VK_SHIFT:case VK_LSHIFT:case VK_RSHIFT:break;
                                
                                default: treat_normally = false; break;
                            }
                        }
                        
                        if (treat_normally){
                            TranslateMessage(&msg);
                            DispatchMessage(&msg);
                        }
                        else{
                            Control_Keys *controls = &win32vars.input_chunk.pers.controls;
                            
                            b8 ctrl = (controls->r_ctrl || (controls->l_ctrl && !controls->r_alt));
                            b8 alt = (controls->l_alt || (controls->r_alt && !controls->l_ctrl));
                            
                            if (win32vars.lctrl_lalt_is_altgr){
                                if (controls->l_alt && controls->l_ctrl){
                                    ctrl = 0;
                                    alt = 0;
                                }
                            }
                            
                            BYTE ctrl_state = 0, alt_state = 0;
                            BYTE state[256];
                            if (ctrl || alt){
                                GetKeyboardState(state);
                                if (ctrl){
                                    ctrl_state = state[VK_CONTROL];
                                    state[VK_CONTROL] = 0;
                                }
                                if (alt){
                                    alt_state = state[VK_MENU];
                                    state[VK_MENU] = 0;
                                }
                                SetKeyboardState(state);
                                
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                                
                                if (ctrl){
                                    state[VK_CONTROL] = ctrl_state;
                                }
                                if (alt){
                                    state[VK_MENU] = alt_state;
                                }
                                SetKeyboardState(state);
                            }
                            else{
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                        }
                    }
                }
            }while (get_more_messages);
            
            system_acquire_global_frame_mutex(win32vars.tctx);
        }
        
        // NOTE(allen): Mouse Out of Window Detection
        POINT mouse_point;
        if (GetCursorPos(&mouse_point) &&
            ScreenToClient(win32vars.window_handle, &mouse_point)){
            Rect_i32 screen = Ri32(0, 0, target.width, target.height);
            Vec2_i32 mp = V2i32(mouse_point.x, mouse_point.y);
            win32vars.input_chunk.trans.out_of_window = (!rect_contains_point(screen, mp));
            win32vars.input_chunk.pers.mouse = mp;
        }
        else{
            win32vars.input_chunk.trans.out_of_window = true;
        }
        
        // NOTE(allen): Prepare the Frame Input
        
        // TODO(allen): CROSS REFERENCE WITH LINUX SPECIAL CODE "TIC898989"
        Win32_Input_Chunk input_chunk = win32vars.input_chunk;
        
        Scratch_Block scratch(win32vars.tctx);
        Application_Step_Input input = {};
        
        input.first_step = win32vars.first;
        input.dt = frame_useconds/1000000.f;
        input.events = input_chunk.trans.event_list;
        
        input.mouse.out_of_window = input_chunk.trans.out_of_window;
        
        input.mouse.l = input_chunk.pers.mouse_l;
        input.mouse.press_l = input_chunk.trans.mouse_l_press;
        input.mouse.release_l = input_chunk.trans.mouse_l_release;
        
        input.mouse.r = input_chunk.pers.mouse_r;
        input.mouse.press_r = input_chunk.trans.mouse_r_press;
        input.mouse.release_r = input_chunk.trans.mouse_r_release;
        
        input.mouse.wheel = input_chunk.trans.mouse_wheel;
        input.mouse.p = input_chunk.pers.mouse;
        
        input.trying_to_kill = input_chunk.trans.trying_to_kill;
        
        // TODO(allen): Not really appropriate to round trip this all the way to the OS layer, redo this system.
        // NOTE(allen): Ask the Core About Exiting if We Have an Exit Signal
        if (win32vars.send_exit_signal){
            input.trying_to_kill = true;
            win32vars.send_exit_signal = false;
        }
        
        // NOTE(allen): Frame Clipboard Input
        if (win32vars.clip_catch_all){
            input.clipboard = system_get_clipboard(scratch, 0);
        }
        
        win32vars.clip_post.size = 0;
        
        
        // NOTE(allen): Application Core Update
        Application_Step_Result result = app.step(win32vars.tctx, &target, base_ptr, &input);
        
        // NOTE(allen): Finish the Loop
        if (result.perform_kill){
            keep_running = false;
        }
        
        // NOTE(allen): Post New Clipboard Content
        if (win32vars.clip_post.size > 0){
            win32_post_clipboard(scratch, (char*)win32vars.clip_post.str, (i32)win32vars.clip_post.size);
        }
        
        // NOTE(allen): Switch to New Title
        if (result.has_new_title){
            SetWindowText_utf8(scratch, win32vars.window_handle, (u8*)result.title_string);
        }
        
        // NOTE(allen): Switch to New Cursor
        Win32SetCursorFromUpdate(result.mouse_cursor_type);
        if (win32vars.cursor_show != win32vars.prev_cursor_show){
            win32vars.prev_cursor_show = win32vars.cursor_show;
            switch (win32vars.cursor_show){
                case MouseCursorShow_Never:
                {
                    i32 counter = 0;
                    do{
                        counter = ShowCursor(false);
                    }while(counter >= 0);
                }break;
                
                case MouseCursorShow_Always:
                {
                    i32 counter = 0;
                    do{
                        counter = ShowCursor(true);
                    }while(counter <= 0);
                }break;
                
                // TODO(allen): MouseCursorShow_HideWhenStill
            }
        }
        
        // NOTE(allen): update lctrl_lalt_is_altgr status
        win32vars.lctrl_lalt_is_altgr = (b8)result.lctrl_lalt_is_altgr;
        
        // NOTE(allen): render
#if defined( WIN32_DX11 )
        gl_render(&target);
        g_dx11.swap_chain->Present( 1, 0 );
#else
        HDC hdc = GetDC(win32vars.window_handle);
        gl_render(&target);
        SwapBuffers(hdc);
        ReleaseDC(win32vars.window_handle, hdc);
#endif
        
        // NOTE(allen): toggle full screen
        if (win32vars.do_toggle){
            win32_toggle_fullscreen();
            win32vars.do_toggle = false;
        }
        
        // NOTE(allen): schedule another step if needed
        if (result.animating){
            system_schedule_step(0);
        }
        else if (win32vars.clip_catch_all){
            system_wake_up_timer_set(win32vars.clip_wakeup_timer, 250);
        }
        
        // NOTE(allen): sleep a bit to cool off :)
        system_release_global_frame_mutex(win32vars.tctx);
        
        u64 timer_end = system_now_time();
        u64 end_target = timer_start + frame_useconds;
        
        for (;timer_end < end_target;){
            DWORD samount = (DWORD)((end_target - timer_end)/1000);
            if (samount > 0){
                Sleep(samount);
            }
            timer_end = system_now_time();
        }
        timer_start = system_now_time();
        
        system_acquire_global_frame_mutex(win32vars.tctx);
        
        win32vars.first = false;
    }
    
#if defined( WIN32_DX11 ) && !SHIP_MODE
    win32_gl_cleanup( );
#endif
    
    return(0);
}

// begin --- win32_utf8.cpp --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 23.03.2017
 *
 * UTF8 versions of WIN32 calls.
 *
 */

// TOP

#if !defined(FRED_WIN32_UTF8_CPP)
#define FRED_WIN32_UTF8_CPP

internal HANDLE
CreateFile_utf8(Arena *scratch, u8 *name, DWORD access, DWORD share, LPSECURITY_ATTRIBUTES security, DWORD creation, DWORD flags, HANDLE template_file){
    Temp_Memory temp = begin_temp(scratch);
    String_u16 name_16 = string_u16_from_string_u8(scratch, SCu8(name), StringFill_NullTerminate);
    HANDLE result = CreateFileW((LPWSTR)name_16.str, access, share, security, creation, flags, template_file);
    end_temp(temp);
    return(result);
}

internal DWORD
GetFinalPathNameByHandle_utf8(Arena *scratch, HANDLE file, u8 *file_path_out, DWORD path_max, DWORD flags){
    DWORD result = 0;
    
    if (file_path_out == 0){
        result = GetFinalPathNameByHandleW(file, 0, 0, flags);
        result *= 2;
    }
    else{
        Temp_Memory temp = begin_temp(scratch);
        
        u32 path_16_max = KB(32);
        u16 *path_16 = push_array(scratch, u16, path_16_max);
        
        DWORD length_16 = GetFinalPathNameByHandleW(file, (LPWSTR)path_16, path_16_max, flags);
        
        if (length_16 != 0 && length_16 < path_16_max){
            b32 convert_error = false;
            String_Const_u16 path_16_str = SCu16(path_16, length_16);
            String_u8 path_8 = string_u8_from_string_u16(scratch, path_16_str, StringFill_NullTerminate);
            if (path_8.size + 1 <= path_max && !convert_error){
                block_copy(file_path_out, path_8.str, path_8.size + 1);
                result = (DWORD)path_8.size;
            }
            else{
                result = (DWORD)path_8.size + 1;
            }
        }
        
        end_temp(temp);
    }
    
    return(result);
}

internal HANDLE
FindFirstFile_utf8(Arena *scratch, u8 *name, LPWIN32_FIND_DATA find_data){
    Temp_Memory temp = begin_temp(scratch);
    String_u16 name_16 = string_u16_from_string_u8(scratch, SCu8(name), StringFill_NullTerminate);
    HANDLE result = FindFirstFileW((LPWSTR)name_16.str, find_data);
    end_temp(temp);
    return(result);
}

internal DWORD
GetFileAttributes_utf8(Arena *scratch, u8 *name){
    Temp_Memory temp = begin_temp(scratch);
    String_u16 name_16 = string_u16_from_string_u8(scratch, SCu8(name), StringFill_NullTerminate);
    DWORD result = GetFileAttributesW((LPWSTR)name_16.str);
    end_temp(temp);
    return(result);
}

internal DWORD
GetModuleFileName_utf8(Arena *scratch, HMODULE module, u8 *file_out, DWORD max){
    Temp_Memory temp = begin_temp(scratch);
    u32 file_16_max = KB(40);
    u16 *file_16 = push_array(scratch, u16, file_16_max);
    DWORD file_16_len = GetModuleFileNameW(module, (LPWSTR)file_16, file_16_max);
    String_u8 file_8 = string_u8_from_string_u16(scratch, SCu16(file_16, file_16_len), StringFill_NullTerminate);
    DWORD result = 0;
    if (file_8.size + 1 <= max){
        block_copy(file_out, file_8.str, file_8.size + 1);
        result = (DWORD)file_8.size;
    }
    end_temp(temp);
    return(result);
}

internal BOOL
CreateProcess_utf8(Arena *scratch, u8 *app_name, u8 *command, LPSECURITY_ATTRIBUTES security, LPSECURITY_ATTRIBUTES thread, BOOL inherit_handles, DWORD creation, LPVOID environment, u8 *curdir, LPSTARTUPINFO startup, LPPROCESS_INFORMATION process){
    Temp_Memory temp = begin_temp(scratch);
    String_u16 app_name_16 = string_u16_from_string_u8(scratch, SCu8(app_name), StringFill_NullTerminate);
    String_u16 command_16 = string_u16_from_string_u8(scratch, SCu8(command), StringFill_NullTerminate);
    String_u16 curdir_16 = string_u16_from_string_u8(scratch, SCu8(curdir), StringFill_NullTerminate);
    BOOL result = CreateProcessW((LPWSTR)app_name_16.str, (LPWSTR)command_16.str, security, thread, inherit_handles, creation, environment, (LPWSTR)curdir_16.str, startup, process);
    end_temp(temp);
    return(result);
}

internal DWORD
GetCurrentDirectory_utf8(Arena *scratch, DWORD max, u8 *buffer){
    DWORD result = 0;
    
    if (buffer != 0){
        Temp_Memory temp = begin_temp(scratch);
        u32 buffer_16_max = KB(40);
        u16 *buffer_16 = push_array(scratch, u16, buffer_16_max);
        DWORD buffer_16_len = GetCurrentDirectoryW(buffer_16_max, (LPWSTR)buffer_16);
        String_u8 curdir_8 = string_u8_from_string_u16(scratch, SCu16(buffer_16, buffer_16_len), StringFill_NullTerminate);
        if (curdir_8.size + 1 <= max){
            block_copy(buffer, curdir_8.str, curdir_8.size + 1);
            result = (DWORD)curdir_8.size;
        }
        else{
            result = (DWORD)curdir_8.size + 1;
        }
        end_temp(temp);
    }
    else{
        result = GetCurrentDirectoryW(0, 0);
        result *= 2;
    }
    
    return(result);
}

internal int
MessageBox_utf8(Arena *scratch, HWND owner, u8 *text, u8 *caption, UINT type){
    Temp_Memory temp = begin_temp(scratch);
    String_u16 text_16 = string_u16_from_string_u8(scratch, SCu8(text), StringFill_NullTerminate);
    String_u16 caption_16 = string_u16_from_string_u8(scratch, SCu8(caption), StringFill_NullTerminate);
    int result = MessageBoxW(owner, (LPWSTR)text_16.str, (LPWSTR)caption_16.str, type);
    end_temp(temp);
    return(result);
}

internal BOOL
SetWindowText_utf8(Arena *scratch, HWND window, u8 *string){
    Temp_Memory temp = begin_temp(scratch);
    String_u16 string_16 = string_u16_from_string_u8(scratch, SCu8(string), StringFill_NullTerminate);
    BOOL result = SetWindowTextW(window, (LPWSTR)string_16.str);
    end_temp(temp);
    return(result);
}

internal BOOL
GetFileAttributesEx_utf8String(Arena *scratch, String_Const_u8 file_name, GET_FILEEX_INFO_LEVELS info_level_id, LPVOID file_info){
    Temp_Memory temp = begin_temp(scratch);
    String_u16 string_16 = string_u16_from_string_u8(scratch, file_name, StringFill_NullTerminate);
    BOOL result = GetFileAttributesExW((LPWSTR)string_16.str, info_level_id, file_info);
    end_temp(temp);
    return(result);
}

function HMODULE
LoadLibrary_utf8String(Arena *scratch, String_Const_u8 name){
    Temp_Memory temp = begin_temp(scratch);
    String_u16 string_16 = string_u16_from_string_u8(scratch, name, StringFill_NullTerminate);
    HMODULE result = LoadLibraryW((LPWSTR)string_16.str);
    end_temp(temp);
    return(result);
}

#endif

// BOTTOM



// end --- win32_utf8.cpp --- 



#if 0
// NOTE(allen): In case I want to switch back to a console application at some point.
int main(int argc, char **argv){
    HINSTANCE hInstance = GetModuleHandle(0);
}
#endif

// BOTTOM



// end --- win32_4ed.cpp --- 



// begin --- font_api.h --- 

#define font_make_face_sig() Face* font_make_face(Arena* arena, Face_Description* description, f32 scale_factor)
typedef Face* font_make_face_type(Arena* arena, Face_Description* description, f32 scale_factor);
struct API_VTable_font{
font_make_face_type *make_face;
};
#if defined(STATIC_LINK_API)
internal Face* font_make_face(Arena* arena, Face_Description* description, f32 scale_factor);
#undef STATIC_LINK_API
#elif defined(DYNAMIC_LINK_API)
global font_make_face_type *font_make_face = 0;
#undef DYNAMIC_LINK_API
#endif


// end --- font_api.h --- 



// begin --- graphics_api.h --- 

#define graphics_get_texture_sig() u32 graphics_get_texture(Vec3_i32 dim, Texture_Kind texture_kind)
#define graphics_fill_texture_sig() b32 graphics_fill_texture(Texture_Kind texture_kind, u32 texture, Vec3_i32 p, Vec3_i32 dim, void* data)
typedef u32 graphics_get_texture_type(Vec3_i32 dim, Texture_Kind texture_kind);
typedef b32 graphics_fill_texture_type(Texture_Kind texture_kind, u32 texture, Vec3_i32 p, Vec3_i32 dim, void* data);
struct API_VTable_graphics{
graphics_get_texture_type *get_texture;
graphics_fill_texture_type *fill_texture;
};
#if defined(STATIC_LINK_API)
internal u32 graphics_get_texture(Vec3_i32 dim, Texture_Kind texture_kind);
internal b32 graphics_fill_texture(Texture_Kind texture_kind, u32 texture, Vec3_i32 p, Vec3_i32 dim, void* data);
#undef STATIC_LINK_API
#elif defined(DYNAMIC_LINK_API)
global graphics_get_texture_type *graphics_get_texture = 0;
global graphics_fill_texture_type *graphics_fill_texture = 0;
#undef DYNAMIC_LINK_API
#endif


// end --- graphics_api.h --- 



// begin --- 4ed_opengl_defines.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 10.11.2017
 *
 * OpenGL defines for 4coder
 *
 */

// TOP

#if !defined(FRED_OPENGL_DEFINES_H)
#define FRED_OPENGL_DEFINES_H

#define GL_TEXTURE_MAX_LEVEL 0x813D

#define GL_MULTISAMPLE                    0x809D
#define GL_CLAMP_TO_EDGE                  0x812F
#define GL_DEBUG_OUTPUT_SYNCHRONOUS       0x8242
#define GL_DEBUG_SEVERITY_NOTIFICATION    0x826B
#define GL_TEXTURE0                       0x84C0
#define GL_TEXTURE1                       0x84C1
#define GL_TEXTURE2                       0x84C2
#define GL_TEXTURE3                       0x84C3
#define GL_TEXTURE4                       0x84C4
#define GL_TEXTURE5                       0x84C5
#define GL_TEXTURE6                       0x84C6
#define GL_TEXTURE7                       0x84C7
#define GL_TEXTURE8                       0x84C8
#define GL_TEXTURE9                       0x84C9
#define GL_TEXTURE10                      0x84CA
#define GL_TEXTURE11                      0x84CB
#define GL_TEXTURE12                      0x84CC
#define GL_TEXTURE13                      0x84CD
#define GL_TEXTURE14                      0x84CE
#define GL_TEXTURE15                      0x84CF
#define GL_TEXTURE16                      0x84D0
#define GL_TEXTURE17                      0x84D1
#define GL_TEXTURE18                      0x84D2
#define GL_TEXTURE19                      0x84D3
#define GL_TEXTURE20                      0x84D4
#define GL_TEXTURE21                      0x84D5
#define GL_TEXTURE22                      0x84D6
#define GL_TEXTURE23                      0x84D7
#define GL_TEXTURE24                      0x84D8
#define GL_TEXTURE25                      0x84D9
#define GL_TEXTURE26                      0x84DA
#define GL_TEXTURE27                      0x84DB
#define GL_TEXTURE28                      0x84DC
#define GL_TEXTURE29                      0x84DD
#define GL_TEXTURE30                      0x84DE
#define GL_TEXTURE31                      0x84DF
#define GL_ARRAY_BUFFER                   0x8892
#define GL_STREAM_DRAW                    0x88E0
#define GL_STREAM_READ                    0x88E1
#define GL_STREAM_COPY                    0x88E2
#define GL_STATIC_DRAW                    0x88E4
#define GL_STATIC_READ                    0x88E5
#define GL_STATIC_COPY                    0x88E6
#define GL_DYNAMIC_DRAW                   0x88E8
#define GL_DYNAMIC_READ                   0x88E9
#define GL_DYNAMIC_COPY                   0x88EA
#define GL_FRAGMENT_SHADER                0x8B30
#define GL_VERTEX_SHADER                  0x8B31
#define GL_DELETE_STATUS                  0x8B80
#define GL_COMPILE_STATUS                 0x8B81
#define GL_LINK_STATUS                    0x8B82
#define GL_VALIDATE_STATUS                0x8B83
#define GL_INFO_LOG_LENGTH                0x8B84
#define GL_ATTACHED_SHADERS               0x8B85
#define GL_ACTIVE_UNIFORMS                0x8B86
#define GL_ACTIVE_UNIFORM_MAX_LENGTH      0x8B87
#define GL_SHADER_SOURCE_LENGTH           0x8B88
#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D
#define GL_SRGB                           0x8C40
#define GL_SRGB8                          0x8C41
#define GL_SRGB_ALPHA                     0x8C42
#define GL_SRGB8_ALPHA8                   0x8C43
#define GL_READ_FRAMEBUFFER               0x8CA8
#define GL_DRAW_FRAMEBUFFER               0x8CA9
#define GL_FRAMEBUFFER_COMPLETE                      0x8CD5
#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT         0x8CD6
#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT 0x8CD7
#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER        0x8CDB
#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER        0x8CDC
#define GL_FRAMEBUFFER_UNSUPPORTED                   0x8CDD
#define GL_MAX_COLOR_ATTACHMENTS          0x8CDF
#define GL_COLOR_ATTACHMENT0              0x8CE0
#define GL_COLOR_ATTACHMENT1              0x8CE1
#define GL_COLOR_ATTACHMENT2              0x8CE2
#define GL_COLOR_ATTACHMENT3              0x8CE3
#define GL_COLOR_ATTACHMENT4              0x8CE4
#define GL_COLOR_ATTACHMENT5              0x8CE5
#define GL_COLOR_ATTACHMENT6              0x8CE6
#define GL_COLOR_ATTACHMENT7              0x8CE7
#define GL_COLOR_ATTACHMENT8              0x8CE8
#define GL_COLOR_ATTACHMENT9              0x8CE9
#define GL_COLOR_ATTACHMENT10             0x8CEA
#define GL_COLOR_ATTACHMENT11             0x8CEB
#define GL_COLOR_ATTACHMENT12             0x8CEC
#define GL_COLOR_ATTACHMENT13             0x8CED
#define GL_COLOR_ATTACHMENT14             0x8CEE
#define GL_COLOR_ATTACHMENT15             0x8CEF
#define GL_COLOR_ATTACHMENT16             0x8CF0
#define GL_COLOR_ATTACHMENT17             0x8CF1
#define GL_COLOR_ATTACHMENT18             0x8CF2
#define GL_COLOR_ATTACHMENT19             0x8CF3
#define GL_COLOR_ATTACHMENT20             0x8CF4
#define GL_COLOR_ATTACHMENT21             0x8CF5
#define GL_COLOR_ATTACHMENT22             0x8CF6
#define GL_COLOR_ATTACHMENT23             0x8CF7
#define GL_COLOR_ATTACHMENT24             0x8CF8
#define GL_COLOR_ATTACHMENT25             0x8CF9
#define GL_COLOR_ATTACHMENT26             0x8CFA
#define GL_COLOR_ATTACHMENT27             0x8CFB
#define GL_COLOR_ATTACHMENT28             0x8CFC
#define GL_COLOR_ATTACHMENT29             0x8CFD
#define GL_COLOR_ATTACHMENT30             0x8CFE
#define GL_COLOR_ATTACHMENT31             0x8CFF
#define GL_DEPTH_ATTACHMENT               0x8D00
#define GL_STENCIL_ATTACHMENT             0x8D20
#define GL_FRAMEBUFFER                    0x8D40
#define GL_FRAMEBUFFER_SRGB               0x8DB9
#define GL_TEXTURE_2D_MULTISAMPLE         0x9100
#define GL_DEBUG_SEVERITY_HIGH            0x9146
#define GL_DEBUG_SEVERITY_MEDIUM          0x9147
#define GL_DEBUG_SEVERITY_LOW             0x9148

#define GL_TEXTURE_3D                     0x806F
#define GL_TEXTURE_2D_ARRAY               0x8C1A

////////////////////////////////

#define GL_R8                             0x8229
#define GL_R16                            0x822A
#define GL_RG8                            0x822B
#define GL_RG16                           0x822C
#define GL_R16F                           0x822D
#define GL_R32F                           0x822E
#define GL_RG16F                          0x822F
#define GL_RG32F                          0x8230
#define GL_R8I                            0x8231
#define GL_R8UI                           0x8232
#define GL_R16I                           0x8233
#define GL_R16UI                          0x8234
#define GL_R32I                           0x8235
#define GL_R32UI                          0x8236
#define GL_RG8I                           0x8237
#define GL_RG8UI                          0x8238
#define GL_RG16I                          0x8239
#define GL_RG16UI                         0x823A
#define GL_RG32I                          0x823B
#define GL_RG32UI                         0x823C

#define GL_RGBA32UI                       0x8D70
#define GL_RGB32UI                        0x8D71
#define GL_RGBA16UI                       0x8D76
#define GL_RGB16UI                        0x8D77
#define GL_RGBA8UI                        0x8D7C
#define GL_RGB8UI                         0x8D7D
#define GL_RGBA32I                        0x8D82
#define GL_RGB32I                         0x8D83
#define GL_RGBA16I                        0x8D88
#define GL_RGB16I                         0x8D89
#define GL_RGBA8I                         0x8D8E
#define GL_RGB8I                          0x8D8F

#define GL_RGBA32F                        0x8814
#define GL_RGB32F                         0x8815
#define GL_RGBA16F                        0x881A
#define GL_RGB16F                         0x881B

#define GL_R8_SNORM                       0x8F94
#define GL_RG8_SNORM                      0x8F95
#define GL_RGB8_SNORM                     0x8F96
#define GL_RGBA8_SNORM                    0x8F97
#define GL_R16_SNORM                      0x8F98
#define GL_RG16_SNORM                     0x8F99
#define GL_RGB16_SNORM                    0x8F9A
#define GL_RGBA16_SNORM                   0x8F9B

#define GL_DEPTH_COMPONENT16              0x81A5
#define GL_DEPTH_COMPONENT24              0x81A6
#define GL_DEPTH_COMPONENT32              0x81A7
#define GL_DEPTH_COMPONENT32F             0x8CAC
#define GL_DEPTH24_STENCIL8               0x88F0

#define GL_DEPTH_STENCIL                  0x84F9
#define GL_UNSIGNED_INT_24_8              0x84FA

#define GL_DEPTH_STENCIL_ATTACHMENT       0x821A

#define GL_DEBUG_OUTPUT                   0x92E0

////////////////////////////////

#define GL_FRAMEBUFFER_UNDEFINED          0x8219

#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT 0x8CD6
#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT 0x8CD7
#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER 0x8CDB
#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER 0x8CDC
#define GL_FRAMEBUFFER_UNSUPPORTED        0x8CDD
#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE 0x8D56
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS 0x8DA8

////////////////////////////////

typedef char GLchar;
typedef short GLshort;
typedef signed char GLbyte;
typedef unsigned short GLushort;

#if !OS_LINUX
typedef ptrdiff_t GLsizeiptr;
typedef ptrdiff_t GLintptr;
#endif

typedef void GL_Debug_Function(GLenum src,
                               GLenum type,
                               GLuint id,
                               GLenum severity,
                               GLsizei length,
                               const GLchar* message,
                               const void *user_data);

typedef GL_Debug_Function *GLDEBUGPROC;

#endif

// BOTTOM



// end --- 4ed_opengl_defines.h --- 



// begin --- 4ed_opengl_funcs.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 10.11.2017
 *
 * OpenGL functions for 4coder
 *
 */

// TOP
/* Usage:
#define GL_FUNC(N,R,P) ~~~~
*/

#if OS_WINDOWS || OS_LINUX
GL_FUNC(glDebugMessageControl, void, (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled))
GL_FUNC(glDebugMessageCallback, void, (GLDEBUGPROC callback, const void *userParam))

GL_FUNC(glGenVertexArrays,    void, (GLsizei n, GLuint *arrays))
GL_FUNC(glBindVertexArray,    void, (GLuint array))

GL_FUNC(glDeleteVertexArrays, void, (GLsizei n, const GLuint *arrays))

#if !OS_LINUX
GL_FUNC(glTexImage3D, void, (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels))
GL_FUNC(glTexSubImage3D, void, (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels))
GL_FUNC(glActiveTexture, void, (GLenum texture))
#endif

GL_FUNC(glGenBuffers, void, (GLsizei n, GLuint *buffers))
GL_FUNC(glBindBuffer, void, (GLenum target, GLuint buffer))
GL_FUNC(glBufferData, void, (GLenum target, GLsizeiptr size, const void *data, GLenum usage))
GL_FUNC(glBufferSubData, void, (GLenum target, GLsizeiptr offset, GLsizeiptr size, const void *data))

GL_FUNC(glCreateShader, GLuint, (GLenum type))
GL_FUNC(glShaderSource, void, (GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length))
GL_FUNC(glCompileShader, void, (GLuint shader))
GL_FUNC(glGetShaderiv, void, (GLuint shader, GLenum pname, GLint *params))
GL_FUNC(glGetShaderInfoLog, void, (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog))
GL_FUNC(glDeleteShader, void, (GLuint shader))
GL_FUNC(glCreateProgram, GLuint, (void))
GL_FUNC(glAttachShader, void, (GLuint program, GLuint shader))
GL_FUNC(glLinkProgram, void, (GLuint program))
GL_FUNC(glUseProgram, void, (GLuint program))
GL_FUNC(glGetProgramiv, void, (GLuint program, GLenum pname, GLint *params))
GL_FUNC(glGetProgramInfoLog, void, (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog))
GL_FUNC(glDeleteProgram, void, (GLuint program))
GL_FUNC(glValidateProgram, void, (GLuint program))

GL_FUNC(glGetUniformLocation, GLint, (GLuint program, const GLchar *name))
GL_FUNC(glGetAttribLocation, GLint, (GLuint program, const GLchar *name))

GL_FUNC(glBindAttribLocation, void, (GLuint program, GLuint index, const GLchar *name))
GL_FUNC(glDisableVertexAttribArray, void, (GLuint index))
GL_FUNC(glEnableVertexAttribArray, void, (GLuint index))

GL_FUNC(glVertexAttribPointer, void, (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer))

GL_FUNC(glVertexAttribIPointer, void, (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer))

GL_FUNC(glUniform1f, void, (GLint location, GLfloat v0))
GL_FUNC(glUniform2f, void, (GLint location, GLfloat v0, GLfloat v1))
GL_FUNC(glUniform3f, void, (GLint location, GLfloat v0, GLfloat v1, GLfloat v2))
GL_FUNC(glUniform4f, void, (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3))
GL_FUNC(glUniform1i, void, (GLint location, GLint v0))
GL_FUNC(glUniform2i, void, (GLint location, GLint v0, GLint v1))
GL_FUNC(glUniform3i, void, (GLint location, GLint v0, GLint v1, GLint v2))
GL_FUNC(glUniform4i, void, (GLint location, GLint v0, GLint v1, GLint v2, GLint v3))
GL_FUNC(glUniform1fv, void, (GLint location, GLsizei count, const GLfloat *value))
GL_FUNC(glUniform2fv, void, (GLint location, GLsizei count, const GLfloat *value))
GL_FUNC(glUniform3fv, void, (GLint location, GLsizei count, const GLfloat *value))
GL_FUNC(glUniform4fv, void, (GLint location, GLsizei count, const GLfloat *value))
GL_FUNC(glUniform1iv, void, (GLint location, GLsizei count, const GLint *value))
GL_FUNC(glUniform2iv, void, (GLint location, GLsizei count, const GLint *value))
GL_FUNC(glUniform3iv, void, (GLint location, GLsizei count, const GLint *value))
GL_FUNC(glUniform4iv, void, (GLint location, GLsizei count, const GLint *value))
GL_FUNC(glUniformMatrix2fv, void, (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GL_FUNC(glUniformMatrix3fv, void, (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))
GL_FUNC(glUniformMatrix4fv, void, (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value))

GL_FUNC(glGenFramebuffers, void, (GLsizei n, GLuint *framebuffers))
GL_FUNC(glBindFramebuffer, void, (GLenum target, GLuint framebuffer))
GL_FUNC(glCheckFramebufferStatus, GLenum, (GLenum target))
GL_FUNC(glFramebufferTexture1D, void, (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level))
GL_FUNC(glFramebufferTexture2D, void, (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level))
GL_FUNC(glFramebufferTexture3D, void, (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset))

GL_FUNC(glBlitFramebuffer, void, (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter))

GL_FUNC(glTexImage2DMultisample, void, (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations))

#elif OS_MAC

GL_FUNC(glDebugMessageControl, void, (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled))
GL_FUNC(glDebugMessageCallback, void, (GLDEBUGPROC callback, const void *userParam))

GL_FUNC(glGenVertexArrays,    void, (GLsizei n, GLuint *arrays))
GL_FUNC(glBindVertexArray,    void, (GLuint array))

GL_FUNC(glVertexAttribIPointer, void, (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer))

#endif

#undef GL_FUNC

// BOTTOM





// end --- 4ed_opengl_funcs.h --- 



// begin --- linux_semaphore_wrapper.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 07.11.2017
 *
 * Linux semaphore wrapper
 *
 */

// TOP

union Semaphore{
    sem_t s;
    FixSize(SEMAPHORE_TYPE_SIZE);
};

internal void
system_init_semaphore(Semaphore *s, u32 count){
    sem_init(&s->s, 0, 0);
}

internal void
system_wait_on_semaphore(Semaphore *s){
    sem_wait(&s->s);
}

internal void
system_release_semaphore(Semaphore *s){
    sem_post(&s->s);
}

// BOTTOM




// end --- linux_semaphore_wrapper.h --- 



// begin --- mac_4ed_opengl_funcs.h --- 

/* Mac OpenGL functions for 4coder */

// TOP
/* Usage:
#define GL_FUNC(N,R,P) ~~~~
*/

// TODO(allen): eliminate this
GL_FUNC(glDebugMessageControl, void, (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled))
GL_FUNC(glDebugMessageCallback, void, (GLDEBUGPROC callback, const void *userParam))

GL_FUNC(glGenVertexArrays,    void, (GLsizei n, GLuint *arrays))
GL_FUNC(glBindVertexArray,    void, (GLuint array))

GL_FUNC(glVertexAttribIPointer, void, (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer))

#undef GL_FUNC


// end --- mac_4ed_opengl_funcs.h --- 



// begin --- mac_4ed_renderer.h --- 

/* Mac Renderer Abstraction */

#if !defined(FRED_MAC_RENDERER_H)
#define FRED_MAC_RENDERER_H

////////////////////////////////

// TODO(yuval): This should be refactored into a platform independent renderer

struct Mac_Renderer;

#define mac_render_sig(name) void name(Mac_Renderer *renderer, Render_Target *target)
typedef mac_render_sig(mac_render_type);

#define mac_get_texture_sig(name) u32 name(Mac_Renderer *renderer, Vec3_i32 dim, Texture_Kind texture_kind)
typedef mac_get_texture_sig(mac_get_texture_type);

#define mac_fill_texture_sig(name) b32 name(Mac_Renderer *renderer, Texture_Kind texture_kind, u32 texture, Vec3_i32 p, Vec3_i32 dim, void* data)
typedef mac_fill_texture_sig(mac_fill_texture_type);

typedef i32 Mac_Renderer_Kind;
enum{
    MacRenderer_OpenGL,
    MacRenderer_Metal,
    //
    MacRenderer_COUNT
};

struct Mac_Renderer{
    mac_render_type *render;
    
    mac_get_texture_type *get_texture;
    mac_fill_texture_type *fill_texture;
};

////////////////////////////////

// NOTE(yuval): This is the actual platform dependent function that each renderer implementation implements and should be exported into a DLL
#define mac_load_renderer_sig(name) Mac_Renderer* name(NSWindow *window, Render_Target *target)
typedef mac_load_renderer_sig(mac_load_renderer_type);

////////////////////////////////

#endif

// end --- mac_4ed_renderer.h --- 



// begin --- mac_objective_c_to_cpp_links.h --- 

/* Types and functions for communication between C++ and Objective-C layers. */

#if !defined(MAC_OBJECTIVE_C_TO_CPP_LINKS_H)
#define MAC_OBJECTIVE_C_TO_CPP_LINKS_H

// In C++ layer
external String_Const_u8
mac_SCu8(u8* str, u64 size);

external String_Const_u8
mac_push_string_copy(Arena *arena, String_Const_u8 src);

external void
mac_init();

// In Objective-C layer
external String_Const_u8
mac_standardize_path(Arena* arena, String_Const_u8 path);

external i32
mac_get_binary_path(void* buffer, u32 size);

#endif



// end --- mac_objective_c_to_cpp_links.h --- 



// begin --- mac_semaphore_wrapper.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 07.11.2017
 *
 * Mac semaphore wrapper
 *
 */

// TOP

union Semaphore{
    semaphore_t s;
    FixSize(SEMAPHORE_TYPE_SIZE);
};

internal void
system_init_semaphore(Semaphore *s, u32 count){
    task_t task = mach_task_self();
    semaphore_create(task, &s->s, SYNC_POLICY_FIFO, 0);
}

internal void
system_wait_on_semaphore(Semaphore *s){
    semaphore_wait(s->s);
}

internal void
system_release_semaphore(Semaphore *s){
    semaphore_signal(s->s);
}

// BOTTOM




// end --- mac_semaphore_wrapper.h --- 



// begin --- unix_4ed_headers.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 18.07.2017
 *
 * General unix includes
 *
 */

// TOP

#error IS THIS STILL REAL? (February 27th 2020)

#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>

#include <dlfcn.h>
#include <fcntl.h>
#include <unistd.h>
#include <dirent.h>
#include <alloca.h>
#include <errno.h>
#include <time.h>
#include <pthread.h>
#include <semaphore.h>
#include <signal.h>

#if defined(USE_LOG)
# include <stdio.h>
#endif

// BOTTOM



// end --- unix_4ed_headers.h --- 



// begin --- unix_library_wrapper.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 18.07.2017
 *
 * Linux library wrapper.
 *
 */

// TOP

#error IS THIS STILL REAL? (February 27th 2020)

union Library{
    void *lib;
    FixSize(LIBRARY_TYPE_SIZE);
};

internal b32
system_load_library_direct(Library *library, char *name){
    AssertLibrarySizes();
    library->lib = dlopen(name, RTLD_LAZY);
    b32 success = (library->lib != 0);
    return(success);
}

internal void*
system_get_proc(Library *library, char *name){
    void *result = dlsym(library->lib, name);
    return(result);
}

internal void
system_free_library(Library *library){
    dlclose(library->lib);
    library->lib = 0;
}

// BOTTOM



// end --- unix_library_wrapper.h --- 



// begin --- unix_threading_wrapper.h --- 

/*
 * Mr. 4th Dimention - Allen Webster
 *
 * 18.07.2017
 *
 * Linux threading wrapper
 *
 */

// TOP

#error IS THIS STILL REAL? (February 27th 2020)

#if !defined(MAC_THREADING_WRAPPER)
#define MAC_THREADING_WRAPPER

#define PLAT_THREAD_SIG(n) void* n(void *ptr)
typedef PLAT_THREAD_SIG(Thread_Function);

union Thread{
    pthread_t t;
    FixSize(THREAD_TYPE_SIZE);
};

union Mutex{
    pthread_mutex_t crit;
    FixSize(MUTEX_TYPE_SIZE);
};

union Condition_Variable{
    pthread_cond_t cv;
    FixSize(CONDITION_VARIABLE_TYPE_SIZE);
};

internal void
system_init_and_launch_thread(Thread *t, Thread_Function *proc, void *ptr){
    pthread_create(&t->t, 0, proc, ptr);
}

internal void
system_init_lock(Mutex *m){
    pthread_mutex_init(&m->crit, NULL);
}

internal void
system_acquire_lock(Mutex *m){
    pthread_mutex_lock(&m->crit);
}

internal void
system_release_lock(Mutex *m){
    pthread_mutex_unlock(&m->crit);
}

internal void
system_init_cv(Condition_Variable *cv){
    pthread_cond_init(&cv->cv, NULL);
}

internal void
system_wait_cv(Condition_Variable *cv, Mutex *m){
    pthread_cond_wait(&cv->cv, &m->crit);
}

internal void
system_signal_cv(Condition_Variable *cv, Mutex *m){
    pthread_cond_signal(&cv->cv);
}

#endif

// BOTTOM



// end --- unix_threading_wrapper.h --- 



// begin --- 4ed_metal_render.mm --- 

/* 4coder Metal render implementation */

#undef clamp
#undef function
#import <simd/simd.h>
#import <MetalKit/MetalKit.h>
#define function static

////////////////////////////////

struct Metal_Buffer{
    Node node;
    
    id<MTLBuffer> buffer;
    u32 size;
    u64 last_reuse_time;
};

////////////////////////////////

typedef id<MTLTexture> Metal_Texture;

// NOTE(yuval): This is a locator used to describe where a specific slot is located.
union Metal_Texture_Slot_Locator{
    u32 packed;
    
    struct{
        u16 bucket_index;
        u16 slot_index;
    };
};

// NOTE(yuval): This is the ACTUAL texture slot. Each slot contains the texture handle, the slot locator, and a pointer to the next slot in the free list (in case the slot if not occupied).
struct Metal_Texture_Slot{
    // NOTE(yuval): This is a pointer to the next texture in the free texture slots list
    Metal_Texture_Slot *next;
    
    Metal_Texture texture;
    Metal_Texture_Slot_Locator locator;
};

global_const u32 metal__texture_slots_per_bucket = 256;

// NOTE(yuval): This a bucket of ACTUAL texture slots.
struct Metal_Texture_Slot_Bucket{
    Metal_Texture_Slot_Bucket *next;
    Metal_Texture_Slot slots[metal__texture_slots_per_bucket];
};

// NOTE(yuval): This a struct contaning all texture slot buckets and a list of the currently free slots.
struct Metal_Texture_Slot_List{
    Metal_Texture_Slot_Bucket *first_bucket;
    Metal_Texture_Slot_Bucket *last_bucket;
    u16 bucket_count;
    
    Metal_Texture_Slot *first_free_slot;
    Metal_Texture_Slot *last_free_slot;
};

global_const u32 metal__invalid_texture_slot_locator = (u32)-1;

////////////////////////////////

@interface Metal_Renderer : NSObject<MTKViewDelegate>
- (nonnull instancetype)initWithMetalKitView:(nonnull MTKView*)mtkView target:(Render_Target*)target;

- (u32)get_texture_of_dim:(Vec3_i32)dim kind:(Texture_Kind)kind;
- (b32)fill_texture:(u32)texture kind:(Texture_Kind)kind pos:(Vec3_i32)p dim:(Vec3_i32)dim data:(void*)data;
- (void)bind_texture:(u32)handle encoder:(id<MTLRenderCommandEncoder>)render_encoder;
- (Metal_Texture_Slot*)get_texture_slot_at_locator:(Metal_Texture_Slot_Locator)locator;
- (Metal_Texture_Slot*)get_texture_slot_at_handle:(u32)handle;

- (Metal_Buffer*)get_reusable_buffer_with_size:(NSUInteger)size;
- (void)add_reusable_buffer:(Metal_Buffer*)buffer;
@end

////////////////////////////////

global_const char *metal__shaders_source = R"(
#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

////////////////////////////////

typedef struct{
float2 xy [[attribute(0)]];
float3 uvw [[attribute(1)]];
uint32_t color [[attribute(2)]];
float half_thickness [[attribute(3)]];
} Vertex;

// NOTE(yuval): Vertex shader outputs and fragment shader inputs
typedef struct{
// NOTE(yuval): Vertex shader output
float4 position [[position]];

// NOTE(yuval): Fragment shader inputs
float4 color;
float3 uvw;
float2 xy;
float2 adjusted_half_dim;
float half_thickness;
} Rasterizer_Data;

////////////////////////////////

vertex Rasterizer_Data
vertex_shader(Vertex in [[stage_in]],
constant float4x4 &proj [[buffer(1)]]){
Rasterizer_Data out;

// NOTE(yuval): Calculate position in NDC
out.position = proj * float4(in.xy, 0.0, 1.0);

// NOTE(yuval): Convert color to float4 format
out.color.b = ((float((in.color       ) & 0xFFu)) / 255.0);
out.color.g = ((float((in.color >>  8u) & 0xFFu)) / 255.0);
out.color.r = ((float((in.color >> 16u) & 0xFFu)) / 255.0);
out.color.a = ((float((in.color >> 24u) & 0xFFu)) / 255.0);

// NOTE(yuval): Pass uvw coordinates to the fragment shader
out.uvw = in.uvw;

// NOTE(yuval): Calculate adjusted half dim
float2 center = in.uvw.xy;
float2 half_dim = abs(in.xy - center);
out.adjusted_half_dim = (half_dim - in.uvw.zz + float2(0.5, 0.5));

// NOTE(yuval): Pass half_thickness to the fragment shader
out.half_thickness = in.half_thickness;

// NOTE(yuval): Pass xy to the fragment shader
out.xy = in.xy;

return(out);
}

////////////////////////////////

float
rectangle_sd(float2 p, float2 b){
float2 d = (abs(p) - b);
float result = (length(max(d, float2(0.0, 0.0))) + min(max(d.x, d.y), 0.0));

return(result);
}

fragment float4
fragment_shader(Rasterizer_Data in [[stage_in]],
texture2d_array<half> in_texture [[texture(0)]]){
float has_thickness = step(0.49, in.half_thickness);
float does_not_have_thickness = (1.0 - has_thickness);

constexpr sampler texture_sampler(coord::normalized, min_filter::linear, mag_filter::linear, mip_filter::linear);
half sample_value = in_texture.sample(texture_sampler, in.uvw.xy, in.uvw.z).r;
sample_value *= does_not_have_thickness;

float2 center = in.uvw.xy;
float roundness = in.uvw.z;
float sd = rectangle_sd(in.xy - center, in.adjusted_half_dim);
sd = sd - roundness;
sd = (abs(sd + in.half_thickness) - in.half_thickness);
float shape_value = (1.0 - smoothstep(-1.0, 0.0, sd));
shape_value *= has_thickness;

float4 out_color = float4(in.color.xyz, in.color.a * (sample_value + shape_value));
return(out_color);
}
)";

////////////////////////////////

function Metal_Buffer*
metal__make_buffer(u32 size, id<MTLDevice> device){
    Metal_Buffer *result = (Metal_Buffer*)malloc(sizeof(Metal_Buffer));
    
    // NOTE(yuval): Create the vertex buffer
    MTLResourceOptions options = MTLCPUCacheModeWriteCombined|MTLResourceStorageModeManaged;
    result->buffer = [device newBufferWithLength:size options:options];
    result->size = size;
    
    // NOTE(yuval): Set the last_reuse_time to the current time
    result->last_reuse_time = system_now_time();
    
    return result;
}

////////////////////////////////

@implementation Metal_Renderer{
    Render_Target *_target;
    
    id<MTLDevice> _device;
    id<MTLRenderPipelineState> _pipeline_state;
    id<MTLCommandQueue> _command_queue;
    id<MTLCaptureScope> _capture_scope;
    
    Node _buffer_cache;
    u64 _last_buffer_cache_purge_time;
    
    Metal_Texture_Slot_List _texture_slots;
}

- (nonnull instancetype)initWithMetalKitView:(nonnull MTKView*)mtk_view target:(Render_Target*)target{
    self = [super init];
    if (self == nil){
        return(nil);
    }
    
    _target = target;
    
    NSError *error = nil;
    
    _device = mtk_view.device;
    
    // NOTE(yuval): Compile the shaders
    id<MTLFunction> vertex_function = nil;
    id<MTLFunction> fragment_function = nil;
    {
        NSString *shaders_source_str = [NSString stringWithUTF8String:metal__shaders_source];
        
        MTLCompileOptions *options = [[MTLCompileOptions alloc] init];
        options.fastMathEnabled = YES;
        
        id<MTLLibrary> shader_library = [_device newLibraryWithSource:shaders_source_str
                options:options error:&error];
        vertex_function = [shader_library newFunctionWithName:@"vertex_shader"];
        fragment_function = [shader_library newFunctionWithName:@"fragment_shader"];
        
        [options release];
    }
    
    Assert(error == nil);
    Assert((vertex_function != nil) && (fragment_function != nil));
    
    // NOTE(yuval): Configure the pipeline descriptor
    {
        MTLVertexDescriptor *vertexDescriptor = [MTLVertexDescriptor vertexDescriptor];
        vertexDescriptor.attributes[0].offset = OffsetOfMember(Render_Vertex, xy);
        vertexDescriptor.attributes[0].format = MTLVertexFormatFloat2; // position
        vertexDescriptor.attributes[0].bufferIndex = 0;
        vertexDescriptor.attributes[1].offset = OffsetOfMember(Render_Vertex, uvw);
        vertexDescriptor.attributes[1].format = MTLVertexFormatFloat3; // texCoords
        vertexDescriptor.attributes[1].bufferIndex = 0;
        vertexDescriptor.attributes[2].offset = OffsetOfMember(Render_Vertex, color);
        vertexDescriptor.attributes[2].format = MTLVertexFormatUInt; // color
        vertexDescriptor.attributes[2].bufferIndex = 0;
        vertexDescriptor.attributes[3].offset = OffsetOfMember(Render_Vertex, half_thickness);
        vertexDescriptor.attributes[3].format = MTLVertexFormatFloat; // position
        vertexDescriptor.attributes[3].bufferIndex = 0;
        vertexDescriptor.layouts[0].stepRate = 1;
        vertexDescriptor.layouts[0].stepFunction = MTLVertexStepFunctionPerVertex;
        vertexDescriptor.layouts[0].stride = sizeof(Render_Vertex);
        
        MTLRenderPipelineDescriptor *pipeline_state_descriptor = [[MTLRenderPipelineDescriptor alloc] init];
        pipeline_state_descriptor.label = @"4coder Metal Renderer Pipeline";
        pipeline_state_descriptor.vertexFunction = vertex_function;
        pipeline_state_descriptor.fragmentFunction = fragment_function;
        pipeline_state_descriptor.vertexDescriptor = vertexDescriptor;
        pipeline_state_descriptor.colorAttachments[0].pixelFormat = mtk_view.colorPixelFormat;
        pipeline_state_descriptor.colorAttachments[0].blendingEnabled = YES;
        pipeline_state_descriptor.colorAttachments[0].alphaBlendOperation = MTLBlendOperationAdd;
        pipeline_state_descriptor.colorAttachments[0].rgbBlendOperation = MTLBlendOperationAdd;
        pipeline_state_descriptor.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorSourceAlpha;
        pipeline_state_descriptor.colorAttachments[0].destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
        pipeline_state_descriptor.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactorOne;
        pipeline_state_descriptor.colorAttachments[0].destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
        
        _pipeline_state = [_device newRenderPipelineStateWithDescriptor:pipeline_state_descriptor
                error:&error];
    }
    
    Assert(error == nil);
    
    // NOTE(yuval): Create the command queue
    _command_queue = [_device newCommandQueue];
    
    // NOTE(yuval): Initialize buffer caching
    dll_init_sentinel(&_buffer_cache);
    _last_buffer_cache_purge_time = system_now_time();
    
    // NOTE(yuval): Initialize the texture slot list
    block_zero_struct(&_texture_slots);
    
    // NOTE(yuval): Create the fallback texture
    _target->fallback_texture_id = [self get_texture_of_dim:V3i32(2, 2, 1)
            kind:TextureKind_Mono];
    u8 white_block[] = {0xFF, 0xFF, 0xFF, 0xFF};
    [self fill_texture:_target->fallback_texture_id
            kind:TextureKind_Mono
            pos:V3i32(0, 0, 0)
            dim:V3i32(2, 2, 1)
            data:white_block];
    
    // NOTE(yuval): Create a capture scope for gpu frame capture
    _capture_scope = [[MTLCaptureManager sharedCaptureManager]
            newCaptureScopeWithDevice:_device];
    _capture_scope.label = @"4coder Metal Capture Scope";
    
    return(self);
}

- (void)mtkView:(nonnull MTKView*)view drawableSizeWillChange:(CGSize)size{
    // NOTE(yuval): Nothing to do here because we use the render target's dimentions for rendering
}

- (void)drawInMTKView:(nonnull MTKView*)view{
#if FRED_INTERNAL
    [_capture_scope beginScope];
#endif
    
    // HACK(yuval): This is the best way I found to force valid width and height without drawing on the next draw cycle (1 frame delay).
    CGSize drawable_size = [view drawableSize];
    i32 width = (i32)Min(_target->width, drawable_size.width);
    i32 height = (i32)Min(_target->height, drawable_size.height);
    
    Font_Set *font_set = (Font_Set*)_target->font_set;
    
    // NOTE(yuval): Free any textures in the target's texture free list
    for (Render_Free_Texture *free_texture = _target->free_texture_first;
         free_texture;
         free_texture = free_texture->next){
        Metal_Texture_Slot *texture_slot = [self get_texture_slot_at_handle:free_texture->tex_id];
        if (texture_slot){
            sll_queue_push(_texture_slots.first_free_slot, _texture_slots.last_free_slot, texture_slot);
        }
    }
    _target->free_texture_first = 0;
    _target->free_texture_last = 0;
    
    // NOTE(yuval): Create the command buffer
    id<MTLCommandBuffer> command_buffer = [_command_queue commandBuffer];
    command_buffer.label = @"4coder Metal Render Command";
    
    // NOTE(yuval): Obtain the render pass descriptor from the renderer's view
    MTLRenderPassDescriptor *render_pass_descriptor = view.currentRenderPassDescriptor;
    if (render_pass_descriptor != nil){
        render_pass_descriptor.colorAttachments[0].clearColor = MTLClearColorMake(0.0f, 0.0f, 0.0f, 1.0f);
        
        // NOTE(yuval): Create the render command encoder
        id<MTLRenderCommandEncoder> render_encoder =
            [command_buffer renderCommandEncoderWithDescriptor:render_pass_descriptor];
        render_encoder.label = @"4coder Render Encoder";
        
        // NOTE(yuval): Set the region of the drawable to draw into
        [render_encoder setViewport:(MTLViewport){0.0, 0.0, (double)width, (double)height, 0.0, 1.0}];
        
        // NOTE(yuval): Set the render pipeline to use for drawing
        [render_encoder setRenderPipelineState:_pipeline_state];
        
        // NOTE(yuval): Calculate the projection matrix
        float left = 0, right = (float)width;
        float bottom = (float)height, top = 0;
        float near_depth = -1.0f, far_depth = 1.0f;
        float proj[16] = {
            2.0f / (right - left), 0.0f, 0.0f, 0.0f,
            0.0f, 2.0f / (top - bottom), 0.0f, 0.0f,
            0.0f, 0.0f, -1.0f / (far_depth - near_depth), 0.0f,
            -((right + left) / (right - left)), -((top + bottom) / (top - bottom)),
            -(near_depth / (far_depth - near_depth)), 1.0f
        };
        
        // NOTE(yuval): Calculate required vertex buffer size
        i32 all_vertex_count = 0;
        for (Render_Group *group = _target->group_first;
             group;
             group = group->next){
            all_vertex_count += group->vertex_list.vertex_count;
        }
        
        u32 vertex_buffer_size = (all_vertex_count * sizeof(Render_Vertex));
        
        // NOTE(yuval): Find & Get a vertex buffer matching the required size
        Metal_Buffer *buffer = [self get_reusable_buffer_with_size:vertex_buffer_size];
        
        // NOTE(yuval): Pass the vertex buffer to the vertex shader
        [render_encoder setVertexBuffer:buffer->buffer
                offset:0
                atIndex:0];
        
        // NOTE(yuval): Pass the projection matrix to the vertex shader
        [render_encoder setVertexBytes:&proj
                length:sizeof(proj)
                atIndex:1];
        
        u32 buffer_offset = 0;
        for (Render_Group *group = _target->group_first;
             group;
             group = group->next){
            // NOTE(yuval): Set scissor rect
            {
                Rect_i32 box = Ri32(group->clip_box);
                
                NSUInteger x0 = (NSUInteger)Min(Max(0, box.x0), width - 1);
                NSUInteger x1 = (NSUInteger)Min(Max(0, box.x1), width);
                NSUInteger y0 = (NSUInteger)Min(Max(0, box.y0), height - 1);
                NSUInteger y1 = (NSUInteger)Min(Max(0, box.y1), height);
                
                MTLScissorRect scissor_rect;
                scissor_rect.x = x0;
                scissor_rect.y = y0;
                scissor_rect.width = (x1 - x0);
                scissor_rect.height = (y1 - y0);
                
                [render_encoder setScissorRect:scissor_rect];
            }
            
            i32 vertex_count = group->vertex_list.vertex_count;
            if (vertex_count > 0){
                // NOTE(yuval): Bind a texture
                {
                    Face* face = font_set_face_from_id(font_set, group->face_id);
                    if (face != 0){
                        // NOTE(yuval): Bind face texture
                        [self bind_texture:face->texture
                                encoder:render_encoder];
                    } else{
                        // NOTE(yuval): Bind fallback texture
                        [self bind_texture:_target->fallback_texture_id
                                encoder:render_encoder];
                    }
                }
                
                // NOTE(yuval): Copy the vertex data to the vertex buffer
                {
                    
                    u8 *group_buffer_contents = (u8*)[buffer->buffer contents] + buffer_offset;
                    u8 *cursor = group_buffer_contents;
                    for (Render_Vertex_Array_Node *node = group->vertex_list.first;
                         node;
                         node = node->next){
                        i32 size = node->vertex_count * sizeof(*node->vertices);
                        memcpy(cursor, node->vertices, size);
                        cursor += size;
                    }
                    
                    NSUInteger data_size = (NSUInteger)(cursor - group_buffer_contents);
                    NSRange modify_range = NSMakeRange(buffer_offset, data_size);
                    [buffer->buffer didModifyRange:modify_range];
                }
                
                // NOTE(yuval): Set the vertex buffer offset to the beginning of the group's vertices
                [render_encoder setVertexBufferOffset:buffer_offset atIndex:0];
                
                // NOTE(yuval): Draw the vertices
                [render_encoder drawPrimitives:MTLPrimitiveTypeTriangle
                        vertexStart:0
                        vertexCount:vertex_count];
                
                buffer_offset += (vertex_count * sizeof(Render_Vertex));
            }
        }
        
        [render_encoder endEncoding];
        
        // NOTE(yuval): Schedule a present once the framebuffer is complete using the current drawable
        [command_buffer presentDrawable:view.currentDrawable];
        
        [command_buffer addCompletedHandler:^(id<MTLCommandBuffer>){
                dispatch_async(dispatch_get_main_queue(), ^{
                               [self add_reusable_buffer:buffer];
                               });
            }];
    }
    
    // NOTE(yuval): Finalize rendering here and push the command buffer to the GPU
    [command_buffer commit];
    
#if FRED_INTERNAL
    [_capture_scope endScope];
#endif
}

- (u32)get_texture_of_dim:(Vec3_i32)dim kind:(Texture_Kind)kind{
    u32 handle = metal__invalid_texture_slot_locator;
    
    // NOTE(yuval): Check for a free texture slot and allocate another slot bucket if no free slot has been found
    if (!_texture_slots.first_free_slot){
        // NOTE(yuval): Assert that the next bucket's index can fit in a u16
        Assert(_texture_slots.bucket_count < ((u16)-1));
        
        Metal_Texture_Slot_Bucket *bucket = (Metal_Texture_Slot_Bucket*)system_memory_allocate(sizeof(Metal_Texture_Slot_Bucket),  file_name_line_number_lit_u8);
        
        for (u16 slot_index = 0;
             slot_index < ArrayCount(bucket->slots);
             ++slot_index){
            Metal_Texture_Slot *slot = &bucket->slots[slot_index];
            block_zero_struct(slot);
            slot->locator.bucket_index = _texture_slots.bucket_count;
            slot->locator.slot_index = slot_index;
            
            sll_queue_push(_texture_slots.first_free_slot, _texture_slots.last_free_slot, slot);
        }
        
        sll_queue_push(_texture_slots.first_bucket, _texture_slots.last_bucket, bucket);
        _texture_slots.bucket_count += 1;
    }
    
    // NOTE(yuval): Get the first free texture slot and remove it from the free list (a slot is guarenteed to exist because we assert that above).
    if (_texture_slots.first_free_slot){
        Metal_Texture_Slot *texture_slot = _texture_slots.first_free_slot;
        sll_queue_pop(_texture_slots.first_free_slot, _texture_slots.last_free_slot);
        texture_slot->next = 0;
        
        // NOTE(yuval): Create a texture descriptor.
        MTLTextureDescriptor *texture_descriptor = [[MTLTextureDescriptor alloc] init];
        texture_descriptor.textureType = MTLTextureType2DArray;
        texture_descriptor.pixelFormat = MTLPixelFormatR8Unorm;
        texture_descriptor.width = dim.x;
        texture_descriptor.height = dim.y;
        texture_descriptor.depth = dim.z;
        
        // NOTE(yuval): Create the texture from the device using the descriptor and add it to the textures array.
        Metal_Texture texture = [_device newTextureWithDescriptor:texture_descriptor];
        texture_slot->texture = texture;
        
        handle = texture_slot->locator.packed;
    }
    
    return handle;
}

- (b32)fill_texture:(u32)handle kind:(Texture_Kind)kind pos:(Vec3_i32)p dim:(Vec3_i32)dim data:(void*)data{
    b32 result = false;
    
    if (data){
        Metal_Texture_Slot *texture_slot = [self get_texture_slot_at_handle:handle];
        if (texture_slot){
            Metal_Texture texture = texture_slot->texture;
            
            if (texture != 0){
                MTLRegion replace_region = {
                    {(NSUInteger)p.x, (NSUInteger)p.y, (NSUInteger)p.z},
                    {(NSUInteger)dim.x, (NSUInteger)dim.y, (NSUInteger)dim.z}
                };
                
                // NOTE(yuval): Fill the texture with data
                [texture replaceRegion:replace_region
                        mipmapLevel:0
                        withBytes:data
                        bytesPerRow:dim.x];
                
                result = true;
            }
        }
    }
    
    return(result);
}

- (void)bind_texture:(u32)handle encoder:(id<MTLRenderCommandEncoder>)render_encoder{
    Metal_Texture_Slot *texture_slot = [self get_texture_slot_at_handle:handle];
    if (texture_slot){
        Metal_Texture texture = texture_slot->texture;
        if (texture != 0){
            [render_encoder setFragmentTexture:texture
                    atIndex:0];
        }
    }
}

- (Metal_Texture_Slot*)get_texture_slot_at_locator:(Metal_Texture_Slot_Locator)locator{
    Metal_Texture_Slot *result = 0;
    
    if (locator.packed != metal__invalid_texture_slot_locator){
        Metal_Texture_Slot_Bucket *bucket = _texture_slots.first_bucket;
        for (u16 bucket_index = 0;
             (bucket_index < locator.bucket_index) && bucket;
             ++bucket_index, bucket = bucket->next);
        
        if (bucket && (locator.slot_index < metal__texture_slots_per_bucket)){
            result = &bucket->slots[locator.slot_index];
        }
    }
    
    return(result);
}

- (Metal_Texture_Slot*)get_texture_slot_at_handle:(u32)handle{
    Metal_Texture_Slot_Locator locator;
    locator.packed = handle;
    
    Metal_Texture_Slot *result = [self get_texture_slot_at_locator:locator];
    return(result);
}

- (Metal_Buffer*)get_reusable_buffer_with_size:(NSUInteger)size{
    // NOTE(yuval): This routine is a modified version of Dear ImGui's MetalContext::dequeueReusableBufferOfLength in imgui_impl_metal.mm
    
    u64 now = system_now_time();
    
    // NOTE(yuval): Purge old buffers that haven't been useful for a while
    if ((now - _last_buffer_cache_purge_time) > 1000000){
        Node prev_buffer_cache = _buffer_cache;
        dll_init_sentinel(&_buffer_cache);
        
        for (Node *node = prev_buffer_cache.next;
             node != &_buffer_cache;
             node = node->next){
            Metal_Buffer *candidate = CastFromMember(Metal_Buffer, node, node);
            if (candidate->last_reuse_time > _last_buffer_cache_purge_time){
                dll_insert(&_buffer_cache, node);
            }
        }
        
        _last_buffer_cache_purge_time = now;
    }
    
    // NOTE(yuval): See if we have a buffer we can reuse
    Metal_Buffer *best_candidate = 0;
    for (Node *node = _buffer_cache.next;
         node != &_buffer_cache;
         node = node->next){
        Metal_Buffer *candidate = CastFromMember(Metal_Buffer, node, node);
        if ((candidate->size >= size) && ((!best_candidate) || (best_candidate->last_reuse_time > candidate->last_reuse_time))){
            best_candidate = candidate;
        }
    }
    
    Metal_Buffer *result;
    if (best_candidate){
        // NOTE(yuval): A best candidate has been found! Remove it from the buffer list and set its last reuse time.
        dll_remove(&best_candidate->node);
        best_candidate->last_reuse_time = now;
        result = best_candidate;
    } else{
        // NOTE(yuval): No luck; make a new buffer.
        result = metal__make_buffer(size, _device);
    }
    
    return(result);
}

- (void)add_reusable_buffer:(Metal_Buffer*)buffer{
    // NOTE(yuval): This routine is a modified version of Dear ImGui's MetalContext::enqueueReusableBuffer in imgui_impl_metal.mm
    
    dll_insert(&_buffer_cache, &buffer->node);
}
@end


// end --- 4ed_metal_render.mm --- 



// begin --- mac_4ed.mm --- 

/* Mac Objective-C layer for 4coder */

#include <stdio.h>

#define FPS 60
#define frame_useconds (1000000 / FPS)

// NOTE(allen): This is a very unfortunate hack, but hopefully there will never be a need to use the Marker
// type in the platform layer. If that changes then instead change the name of Marker and make a transition
// macro that is only included in custom code.
#define Marker Marker__SAVE_THIS_IDENTIFIER
#undef Marker
#define STATIC_LINK_API
#define STATIC_LINK_API
#define STATIC_LINK_API

#undef function
#undef internal
#undef global
#undef external
#import <Cocoa/Cocoa.h>

#include <libproc.h> // NOTE(yuval): Used for proc_pidpath
#include <Carbon/Carbon.h> // NOTE(yuval): Used for virtual key codes
#include <mach/mach_time.h> // NOTE(yuval): Used for mach_absolute_time, mach_timebase_info, mach_timebase_info_data_t

#include <dirent.h> // NOTE(yuval): Used for opendir, readdir
#include <dlfcn.h> // NOTE(yuval): Used for dlopen, dlclose, dlsym
#include <errno.h> // NOTE(yuval): Used for errno
#include <fcntl.h> // NOTE(yuval): Used for open
#include <pthread.h> // NOTE(yuval): Used for threads, mutexes, cvs
#include <unistd.h> // NOTE(yuval): Used for getcwd, read, write, getpid
#include <sys/mman.h> // NOTE(yuval): Used for mmap, munmap, mprotect
#include <sys/stat.h> // NOTE(yuval): Used for stat
#include <sys/types.h> // NOTE(yuval): Used for struct stat, pid_t
#include <sys/syslimits.h> // NOTE(yuval): Used for PATH_MAX

#include <stdlib.h> // NOTE(yuval): Used for free
#include <time.h> // NOTE(allen): I don't know a better way to get Date_Time data; replace if there is a Mac low-level option time.h doesn't give milliseconds

#define function static
#define internal static
#define global static
#define external extern "C"

struct Control_Keys{
    b8 l_ctrl;
    b8 r_ctrl;
    b8 l_alt;
    b8 r_alt;
    b8 l_shift;
    b8 r_shift;
    b8 l_command;
    b8 r_command;
};

struct Mac_Input_Chunk_Transient{
    Input_List event_list;
    b8 mouse_l_press;
    b8 mouse_l_release;
    b8 mouse_r_press;
    b8 mouse_r_release;
    b8 out_of_window;
    b8 trying_to_kill;
    i32 mouse_wheel;
};

struct Mac_Input_Chunk_Persistent{
    Vec2_i32 mouse;
    Control_Keys controls;
    Input_Modifier_Set_Fixed modifiers;
    b8 mouse_l;
    b8 mouse_r;
};

struct Mac_Input_Chunk{
    Mac_Input_Chunk_Transient trans;
    Mac_Input_Chunk_Persistent pers;
};

////////////////////////////////

#define SLASH '/'
#define DLL "so"

////////////////////////////////

@interface FCoder_App_Delegate : NSObject<NSApplicationDelegate>
@end

@interface FCoder_Window_Delegate : NSObject<NSWindowDelegate>
- (void)process_focus_event;
@end

@interface FCoder_View : NSView <NSTextInputClient>
- (void)request_display;
- (void)check_clipboard;
- (void)process_keyboard_event:(NSEvent*)event down:(b8)down;
- (void)process_mouse_move_event:(NSEvent*)event;
@end

////////////////////////////////

typedef i32 Mac_Object_Kind;
enum{
    MacObjectKind_ERROR = 0,
    MacObjectKind_Timer = 1,
    MacObjectKind_Thread = 2,
    MacObjectKind_Mutex = 3,
    MacObjectKind_CV = 4,
};

struct Mac_Object{
    Node node;
    Mac_Object_Kind kind;

    union{
        NSTimer* timer;

        struct{
            pthread_t thread;
            Thread_Function *proc;
            void *ptr;
        } thread;

        pthread_mutex_t mutex;
        pthread_cond_t cv;
    };
};

struct Mac_Vars {
    i32 width, height;

    Thread_Context *tctx;

    Arena frame_arena;
    Input_Event *active_key_stroke;
    Input_Event *active_text_input;
    Mac_Input_Chunk input_chunk;
    b8 lctrl_lalt_is_altgr;

    Key_Mode key_mode;

    b8 full_screen;
    b8 do_toggle;
    b32 send_exit_signal;

    i32 cursor_show;
    i32 prev_cursor_show;
    NSCursor *cursor_ibeam;
    NSCursor *cursor_arrow;
    NSCursor *cursor_leftright;
    NSCursor *cursor_updown;

    String_Const_u8 binary_path;

    u32 clipboard_change_count;
    b32 next_clipboard_is_self;
    b32 clip_catch_all;

    Arena clip_post_arena;
    String_Const_u8 clip_post;

    NSWindow *window;
    FCoder_View *view;
    f32 screen_scale_factor;

    mach_timebase_info_data_t timebase_info;
    b32 first;
    void *base_ptr;

    u64 timer_start;
    b32 step_requested;
    i32 running_cli;

    Node free_mac_objects;
    Node timer_objects;

    pthread_mutex_t thread_launch_mutex;
    pthread_cond_t thread_launch_cv;
    b32 waiting_for_launch;

    System_Mutex global_frame_mutex;

    Log_Function *log_string;
};

////////////////////////////////

////////////////////////////////

global Mac_Vars mac_vars;
global Mac_Renderer *renderer;
global Render_Target target;
global App_Functions app;

////////////////////////////////

function Mac_Object*
mac_alloc_object(Mac_Object_Kind kind){
    Mac_Object *result = 0;

    if (mac_vars.free_mac_objects.next != &mac_vars.free_mac_objects){
        result = CastFromMember(Mac_Object, node, mac_vars.free_mac_objects.next);
    }

    if (!result){
        i32 count = 512;
        Mac_Object *objects = (Mac_Object*)system_memory_allocate(count * sizeof(Mac_Object), file_name_line_number_lit_u8);

        // NOTE(yuval): Link the first node of the dll to the sentinel
        objects[0].node.prev = &mac_vars.free_mac_objects;
        mac_vars.free_mac_objects.next = &objects[0].node;

        // NOTE(yuval): Link all dll nodes to each other
        for (i32 chain_index = 1; chain_index < count; chain_index += 1){
            objects[chain_index - 1].node.next = &objects[chain_index].node;
            objects[chain_index].node.prev = &objects[chain_index - 1].node;
        }

        // NOTE(yuval): Link the last node of the dll to the sentinel
        objects[count - 1].node.next = &mac_vars.free_mac_objects;
        mac_vars.free_mac_objects.prev = &objects[count - 1].node;

        result = CastFromMember(Mac_Object, node, mac_vars.free_mac_objects.next);
    }

    Assert(result);
    dll_remove(&result->node);
    block_zero_struct(result);
    result->kind = kind;

    return(result);
}

function void
mac_free_object(Mac_Object *object){
    if (object->node.next != 0){
        dll_remove(&object->node);
    }

    dll_insert(&mac_vars.free_mac_objects, &object->node);
}

function inline Plat_Handle
mac_to_plat_handle(Mac_Object *object){
    Plat_Handle result = *(Plat_Handle*)(&object);
    return(result);
}

function inline Mac_Object*
mac_to_object(Plat_Handle handle){
    Mac_Object *result = *(Mac_Object**)(&handle);
    return(result);
}

////////////////////////////////

function void
mac_init_recursive_mutex(pthread_mutex_t *mutex){
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
    pthread_mutex_init(mutex, &attr);
}

////////////////////////////////

function void
system_error_box(char *msg){
    NSAlert *alert = [[[NSAlert alloc] init] autorelease];

    NSString *title_string = @"Error";
    NSString *message_string = [NSString stringWithUTF8String:msg];
    [alert setMessageText:title_string];
    [alert setInformativeText:message_string];

    [alert runModal];

    exit(1);
}


function void
os_popup_error(char *title, char *message){
    // TODO(yuval): Condense this with mac_error_box

    NSAlert *alert = [[[NSAlert alloc] init] autorelease];

    NSString *title_string = [NSString stringWithUTF8String:title];
    NSString *message_string = [NSString stringWithUTF8String:message];
    [alert setMessageText:title_string];
    [alert setInformativeText:message_string];

    [alert runModal];

    exit(1);
}

////////////////////////////////

#if defined(FRED_INTERNAL)
function inline void
mac_profile(char *name, u64 begin, u64 end){
    printf("%s Time: %fs\n", name, ((end - begin) / 1000000.0f));
}

#define MacProfileScope(name) for (u64 glue(_i_, __LINE__) = 0, glue(_begin_, __LINE__) = system_now_time();\
glue(_i_, __LINE__) == 0;\
glue(_i_, __LINE__) = 1, mac_profile(name, glue(_begin_, __LINE__), system_now_time()))
#else
# define mac_profile(...)
# define MacProfileScope(...)
#endif

////////////////////////////////

#import "mac_4ed_renderer.mm"

#import "mac_4ed_functions.mm"

////////////////////////////////

global_const u8 kVK_Menu = 0x6E;

global Key_Code keycode_lookup_table[255] = {};

function void
mac_keycode_init(void){
    keycode_lookup_table[kVK_ANSI_A] = KeyCode_A;
    keycode_lookup_table[kVK_ANSI_B] = KeyCode_B;
    keycode_lookup_table[kVK_ANSI_C] = KeyCode_C;
    keycode_lookup_table[kVK_ANSI_D] = KeyCode_D;
    keycode_lookup_table[kVK_ANSI_E] = KeyCode_E;
    keycode_lookup_table[kVK_ANSI_F] = KeyCode_F;
    keycode_lookup_table[kVK_ANSI_G] = KeyCode_G;
    keycode_lookup_table[kVK_ANSI_H] = KeyCode_H;
    keycode_lookup_table[kVK_ANSI_I] = KeyCode_I;
    keycode_lookup_table[kVK_ANSI_J] = KeyCode_J;
    keycode_lookup_table[kVK_ANSI_K] = KeyCode_K;
    keycode_lookup_table[kVK_ANSI_L] = KeyCode_L;
    keycode_lookup_table[kVK_ANSI_M] = KeyCode_M;
    keycode_lookup_table[kVK_ANSI_N] = KeyCode_N;
    keycode_lookup_table[kVK_ANSI_O] = KeyCode_O;
    keycode_lookup_table[kVK_ANSI_P] = KeyCode_P;
    keycode_lookup_table[kVK_ANSI_Q] = KeyCode_Q;
    keycode_lookup_table[kVK_ANSI_R] = KeyCode_R;
    keycode_lookup_table[kVK_ANSI_S] = KeyCode_S;
    keycode_lookup_table[kVK_ANSI_T] = KeyCode_T;
    keycode_lookup_table[kVK_ANSI_U] = KeyCode_U;
    keycode_lookup_table[kVK_ANSI_V] = KeyCode_V;
    keycode_lookup_table[kVK_ANSI_W] = KeyCode_W;
    keycode_lookup_table[kVK_ANSI_X] = KeyCode_X;
    keycode_lookup_table[kVK_ANSI_Y] = KeyCode_Y;
    keycode_lookup_table[kVK_ANSI_Z] = KeyCode_Z;

    keycode_lookup_table[kVK_ANSI_0] = KeyCode_0;
    keycode_lookup_table[kVK_ANSI_1] = KeyCode_1;
    keycode_lookup_table[kVK_ANSI_2] = KeyCode_2;
    keycode_lookup_table[kVK_ANSI_3] = KeyCode_3;
    keycode_lookup_table[kVK_ANSI_4] = KeyCode_4;
    keycode_lookup_table[kVK_ANSI_5] = KeyCode_5;
    keycode_lookup_table[kVK_ANSI_6] = KeyCode_6;
    keycode_lookup_table[kVK_ANSI_7] = KeyCode_7;
    keycode_lookup_table[kVK_ANSI_8] = KeyCode_8;
    keycode_lookup_table[kVK_ANSI_9] = KeyCode_9;

    keycode_lookup_table[kVK_Space] = KeyCode_Space;
    keycode_lookup_table[kVK_ANSI_Grave] = KeyCode_Tick;
    keycode_lookup_table[kVK_ANSI_Minus] = KeyCode_Minus;
    keycode_lookup_table[kVK_ANSI_Equal] = KeyCode_Equal;
    keycode_lookup_table[kVK_ANSI_LeftBracket] = KeyCode_LeftBracket;
    keycode_lookup_table[kVK_ANSI_RightBracket] = KeyCode_RightBracket;
    keycode_lookup_table[kVK_ANSI_Semicolon] = KeyCode_Semicolon;
    keycode_lookup_table[kVK_ANSI_Quote] = KeyCode_Quote;
    keycode_lookup_table[kVK_ANSI_Comma] = KeyCode_Comma;
    keycode_lookup_table[kVK_ANSI_Period] = KeyCode_Period;
    keycode_lookup_table[kVK_ANSI_Slash] = KeyCode_ForwardSlash;
    keycode_lookup_table[kVK_ANSI_Backslash] = KeyCode_BackwardSlash;

    keycode_lookup_table[kVK_Tab] = KeyCode_Tab;
    // NOTE(yuval): No Pause key on macOS!
    keycode_lookup_table[kVK_Escape] = KeyCode_Escape;

    keycode_lookup_table[kVK_UpArrow] = KeyCode_Up;
    keycode_lookup_table[kVK_DownArrow] = KeyCode_Down;
    keycode_lookup_table[kVK_LeftArrow] = KeyCode_Left;
    keycode_lookup_table[kVK_RightArrow] = KeyCode_Right;

    keycode_lookup_table[kVK_Delete] = KeyCode_Backspace;
    keycode_lookup_table[kVK_Return] = KeyCode_Return;

    keycode_lookup_table[kVK_ForwardDelete] = KeyCode_Delete;
    //keycode_lookup_table[] = KeyCode_Insert; // TODO(yuval): Figure how to get keyDown events for the insert key
    keycode_lookup_table[kVK_Home] = KeyCode_Home;
    keycode_lookup_table[kVK_End] = KeyCode_End;
    keycode_lookup_table[kVK_PageUp] = KeyCode_PageUp;
    keycode_lookup_table[kVK_PageDown] = KeyCode_PageDown;

    keycode_lookup_table[kVK_CapsLock] = KeyCode_CapsLock;
    keycode_lookup_table[kVK_ANSI_KeypadClear] = KeyCode_NumLock;
    // NOTE(yuval): No Scroll Lock key on macOS!
    keycode_lookup_table[kVK_Menu] = KeyCode_Menu;

    keycode_lookup_table[kVK_Shift] = KeyCode_Shift;
    keycode_lookup_table[kVK_RightShift] = KeyCode_Shift;

    keycode_lookup_table[kVK_Control] = KeyCode_Control;
    keycode_lookup_table[kVK_RightControl] = KeyCode_Control;

    keycode_lookup_table[kVK_Option] = KeyCode_Alt;
    keycode_lookup_table[kVK_RightOption] = KeyCode_Alt;

    keycode_lookup_table[kVK_Command] = KeyCode_Command;
    keycode_lookup_table[kVK_RightCommand] = KeyCode_Command; // NOTE(yuval): Right Command

    keycode_lookup_table[kVK_F1] = KeyCode_F1;
    keycode_lookup_table[kVK_F2] = KeyCode_F2;
    keycode_lookup_table[kVK_F3] = KeyCode_F3;
    keycode_lookup_table[kVK_F4] = KeyCode_F4;
    keycode_lookup_table[kVK_F5] = KeyCode_F5;
    keycode_lookup_table[kVK_F6] = KeyCode_F6;
    keycode_lookup_table[kVK_F7] = KeyCode_F7;
    keycode_lookup_table[kVK_F8] = KeyCode_F8;
    keycode_lookup_table[kVK_F9] = KeyCode_F9;

    keycode_lookup_table[kVK_F10] = KeyCode_F10;
    keycode_lookup_table[kVK_F11] = KeyCode_F11;
    keycode_lookup_table[kVK_F12] = KeyCode_F12;
    keycode_lookup_table[kVK_F13] = KeyCode_F13;
    keycode_lookup_table[kVK_F14] = KeyCode_F14;
    keycode_lookup_table[kVK_F15] = KeyCode_F15;
    keycode_lookup_table[kVK_F16] = KeyCode_F16;

    keycode_lookup_table[kVK_ANSI_Keypad0] = KeyCode_NumPad0;
    keycode_lookup_table[kVK_ANSI_Keypad1] = KeyCode_NumPad1;
    keycode_lookup_table[kVK_ANSI_Keypad2] = KeyCode_NumPad2;
    keycode_lookup_table[kVK_ANSI_Keypad3] = KeyCode_NumPad3;
    keycode_lookup_table[kVK_ANSI_Keypad4] = KeyCode_NumPad4;
    keycode_lookup_table[kVK_ANSI_Keypad5] = KeyCode_NumPad5;
    keycode_lookup_table[kVK_ANSI_Keypad6] = KeyCode_NumPad6;
    keycode_lookup_table[kVK_ANSI_Keypad7] = KeyCode_NumPad7;
    keycode_lookup_table[kVK_ANSI_Keypad8] = KeyCode_NumPad8;
    keycode_lookup_table[kVK_ANSI_Keypad9] = KeyCode_NumPad9;

    keycode_lookup_table[kVK_ANSI_KeypadMultiply] = KeyCode_NumPadStar;
    keycode_lookup_table[kVK_ANSI_KeypadPlus] = KeyCode_NumPadPlus;
    keycode_lookup_table[kVK_ANSI_KeypadMinus] = KeyCode_NumPadMinus;
    keycode_lookup_table[kVK_ANSI_KeypadDecimal] = KeyCode_NumPadDot;
    keycode_lookup_table[kVK_ANSI_KeypadDivide] = KeyCode_NumPadSlash;
}

////////////////////////////////

function b32
mac_file_can_be_made(u8* filename){
    b32 result = access((char*)filename, W_OK) == 0;
    return(result);
}

////////////////////////////////

function void
mac_resize(float width, float height){
    if ((width > 0.0f) && (height > 0.0f)){
#if 1
        NSSize coord_size = NSMakeSize(width, height);
        NSSize backing_size = [mac_vars.view convertSizeToBacking:coord_size];

        mac_vars.width = (i32)backing_size.width;
        mac_vars.height = (i32)backing_size.height;

        target.width = (i32)backing_size.width;
        target.height = (i32)backing_size.height;
#else
        mac_vars.width = (i32)width;
        mac_vars.height = (i32)height;

        target.width = (i32)width;
        target.height = (i32)height;
#endif
    }

    system_signal_step(0);
}

function inline void
mac_resize(NSWindow *window){
    NSRect bounds = [[window contentView] bounds];
    mac_resize(bounds.size.width, bounds.size.height);
}

////////////////////////////////

function u32
mac_get_clipboard_change_count(void){
    NSPasteboard *board = [NSPasteboard generalPasteboard];
    u32 result = board.changeCount;

    return(result);
}

internal void
mac_post_clipboard(Arena *scratch, char *text, i32 len){
    NSPasteboard *board = [NSPasteboard generalPasteboard];

    NSString *utf8_type = @"public.utf8-plain-text";
    NSArray<NSString*> *types_array = [NSArray arrayWithObjects:utf8_type, nil];
    [board declareTypes:types_array
     owner:nil];

    NSString *paste_string = [[NSString alloc] initWithBytes:text
                              length:len
                              encoding:NSUTF8StringEncoding];
    [board setString:paste_string
     forType:utf8_type];
    [paste_string release];

    mac_vars.next_clipboard_is_self = true;
}

////////////////////////////////

internal
system_get_clipboard_sig(){
    String_Const_u8 result = {};
    u32 change_count = mac_get_clipboard_change_count();
    if (change_count != mac_vars.clipboard_change_count){
        if (mac_vars.next_clipboard_is_self){
            mac_vars.next_clipboard_is_self = false;
        } else {
            NSPasteboard *board = [NSPasteboard generalPasteboard];
            NSString *utf8_type = @"public.utf8-plain-text";
            NSArray *types_array = [NSArray arrayWithObjects:utf8_type, nil];
            NSString *has_string = [board availableTypeFromArray:types_array];
            if (has_string != nil){
                NSData *data = [board dataForType:utf8_type];
                if (data != nil){
                    u32 copy_length = data.length;
                    if (copy_length > 0){
                        result = string_const_u8_push(arena, copy_length);
                        [data getBytes:result.str length:result.size];
                    }
                }
            }
        }
        mac_vars.clipboard_change_count = change_count;
    }
    return(result);
}

internal
system_post_clipboard_sig(){
    Arena *arena = &mac_vars.clip_post_arena;
    if (arena->base_allocator == 0){
        *arena = make_arena_system();
    } else{
        linalloc_clear(arena);
    }

    mac_vars.clip_post.str = push_array(arena, u8, str.size + 1);
    if (mac_vars.clip_post.str != 0){
        block_copy(mac_vars.clip_post.str, str.str, str.size);
        mac_vars.clip_post.str[str.size] = 0;
        mac_vars.clip_post.size = str.size;
    } else{
        // NOTE(yuval): Failed to allocate buffer for clipboard post
    }
}

internal
system_set_clipboard_catch_all_sig(){
    mac_vars.clip_catch_all = enabled?true:false;
}

internal
system_get_clipboard_catch_all_sig(){
    return(mac_vars.clip_catch_all);
}

////////////////////////////////

function void
mac_toggle_fullscreen(void){
    [mac_vars.window toggleFullScreen:nil];
}

////////////////////////////////

@implementation FCoder_App_Delegate
- (void)applicationDidFinishLaunching:(id)sender{
}

- (BOOL)applicationShouldTerminateAfterLastWindowClosed:(NSApplication*)sender{
    return(YES);
}

- (void)applicationWillTerminate:(NSNotification*)notification{
}
@end

@implementation FCoder_Window_Delegate
- (BOOL)windowShouldClose:(id)sender{
    mac_vars.input_chunk.trans.trying_to_kill = true;
    system_signal_step(0);

    return(NO);
}

- (void)windowDidResize:(NSNotification*)notification{
    mac_resize(mac_vars.window);
    if (!mac_vars.do_toggle){
        [mac_vars.view display];
    }
}

- (void)windowDidMiniaturize:(NSNotification*)notification{
}

- (void)windowDidDeminiaturize:(NSNotification*)notification{
}

- (void)windowDidBecomeKey:(NSNotification *)notification{
    // NOTE(yuval): The window is the focused window
    [self process_focus_event];
}

- (void)windowDidResignKey:(NSNotification *)notification{
    // NOTE(yuval): The window has lost focus
    [self process_focus_event];
}

- (void)process_focus_event{
    mac_vars.input_chunk.pers.mouse_l = false;
    mac_vars.input_chunk.pers.mouse_r = false;
    block_zero_struct(&mac_vars.input_chunk.pers.controls);
    block_zero_struct(&mac_vars.input_chunk.pers.modifiers);
    mac_vars.active_key_stroke = 0;
    mac_vars.active_text_input = 0;

    system_signal_step(0);
}
@end

@implementation FCoder_View
- (id)init{
    self = [super init];
    return(self);
}

- (void)dealloc{
    [super dealloc];
}

- (void)viewDidChangeBackingProperties{
    // TODO(yuval): If the screen scale factor changed, modify the current face to use the new screen scale factor.
    mac_resize(mac_vars.window);
}

- (BOOL)wantsUpdateLayer{
    return YES;
}

- (void)updateLayer{
    u64 prev_timer_start;

    MacProfileScope("Draw Rect"){
        mac_vars.step_requested = false;

        // NOTE(yuval): Toggle full screen
        MacProfileScope("Toggle Full Screen"){
            if (mac_vars.do_toggle){
                mac_toggle_fullscreen();
                mac_vars.do_toggle = false;
            }
        }

        MacProfileScope("Acquire Frame Mutex"){
            // NOTE(yuval): Read comment in win32_4ed.cpp's main loop
            system_mutex_acquire(mac_vars.global_frame_mutex);
        }

        Application_Step_Input input = {};

        // NOTE(yuval): Prepare the Frame Input
        MacProfileScope("Prepare Input"){
            Mac_Input_Chunk input_chunk = mac_vars.input_chunk;

            input.first_step = mac_vars.first;
            input.dt = frame_useconds / 1000000.0f;
            input.events = input_chunk.trans.event_list;

            input.mouse.out_of_window = input_chunk.trans.out_of_window;

            input.mouse.l = input_chunk.pers.mouse_l;
            input.mouse.press_l = input_chunk.trans.mouse_l_press;
            input.mouse.release_l = input_chunk.trans.mouse_l_release;

            input.mouse.r = input_chunk.pers.mouse_r;
            input.mouse.press_r = input_chunk.trans.mouse_r_press;
            input.mouse.release_r = input_chunk.trans.mouse_r_release;

            input.mouse.wheel = input_chunk.trans.mouse_wheel;
            input.mouse.p = input_chunk.pers.mouse;

            input.trying_to_kill = input_chunk.trans.trying_to_kill;

            block_zero_struct(&mac_vars.input_chunk.trans);
            mac_vars.active_key_stroke = 0;
            mac_vars.active_text_input = 0;

            // NOTE(yuval): See comment in win32_4ed.cpp's main loop
            if (mac_vars.send_exit_signal){
                input.trying_to_kill = true;
                mac_vars.send_exit_signal = false;
            }
        }

        // NOTE(yuval): Frame clipboard input
        Scratch_Block scratch(mac_vars.tctx);
        MacProfileScope("Frame Clipboard Input"){
            if (mac_vars.clipboard_change_count != 0 && mac_vars.clip_catch_all){
                input.clipboard = system_get_clipboard(scratch, 0);
            }
        }

        mac_vars.clip_post.size = 0;

        // NOTE(yuval): Application Core Update
        Application_Step_Result result = {};
        MacProfileScope("Step"){
            if (app.step != 0){
                result = app.step(mac_vars.tctx, &target, mac_vars.base_ptr, &input);
            }
        }

        // NOTE(yuval): Quit the app if requested by the application core
        MacProfileScope("Perform Kill"){
            if (result.perform_kill){
                [NSApp terminate:nil];
            }
        }

        // NOTE(yuval): Post new clipboard content
        MacProfileScope("Post Clipboard"){
            if (mac_vars.clip_post.size > 0){
                mac_post_clipboard(scratch, (char*)mac_vars.clip_post.str, (i32)mac_vars.clip_post.size);
            }
        }

        // NOTE(yuval): Switch to a new title
        MacProfileScope("Switch Title"){
            if (result.has_new_title){
                NSString *str = [NSString stringWithUTF8String:result.title_string];
                [mac_vars.window setTitle:str];
            }
        }

        // NOTE(yuval): Switch to new cursor
        MacProfileScope("Switch Cursor"){
            // NOTE(yuval): Switch cursor type
            switch (result.mouse_cursor_type){
                case APP_MOUSE_CURSOR_ARROW:
                {
                    [mac_vars.cursor_arrow set];
                } break;

                case APP_MOUSE_CURSOR_IBEAM:
                {
                    [mac_vars.cursor_ibeam set];
                } break;

                case APP_MOUSE_CURSOR_LEFTRIGHT:
                {
                    [mac_vars.cursor_leftright set];
                } break;

                case APP_MOUSE_CURSOR_UPDOWN:
                {
                    [mac_vars.cursor_updown set];
                } break;
            }

            // NOTE(yuval): Show or hide cursor
            if (mac_vars.cursor_show != mac_vars.prev_cursor_show){
                switch (mac_vars.cursor_show){
                    case MouseCursorShow_Never:
                    {
                        [NSCursor hide];
                    } break;

                    case MouseCursorShow_Always:
                    {
                        [NSCursor unhide];
                    } break;
                }

                mac_vars.prev_cursor_show = mac_vars.cursor_show;
            }
        }

        // NOTE(yuval): Update lctrl_lalt_is_altgr status
        mac_vars.lctrl_lalt_is_altgr = (b8)result.lctrl_lalt_is_altgr;

        // NOTE(yuval): Render
        MacProfileScope("Render"){
            renderer->render(renderer, &target);
        }

        // NOTE(yuval): Toggle full screen
        MacProfileScope("Toggle Full Screen"){
            if (mac_vars.do_toggle){
                mac_toggle_fullscreen();
                mac_vars.do_toggle = false;
            }
        }

        // NOTE(yuval): Schedule another step if needed
        MacProfileScope("Schedule Step"){
            if (result.animating || (mac_vars.running_cli > 0)){
                system_signal_step(0);
            }
        }

        // NOTE(yuval): Sleep a bit to cool off
        MacProfileScope("Cool Down"){
            system_mutex_release(mac_vars.global_frame_mutex);
            {
                u64 timer_end = system_now_time();
                u64 end_target = (mac_vars.timer_start + frame_useconds);

                if (timer_end < end_target){
                    if ((end_target - timer_end) > 1000){
                        // NOTE(yuval): Sleep until the end target minus a millisecond (to allow the scheduler to wake the process in time)
                        system_sleep(end_target - timer_end - 1000);
                    }

                    // NOTE(yuval): Iterate through the rest of the time that's left using a regular for loop to make sure that we hit the end target
                    u64 now = system_now_time();
                    while (now < end_target){
                        now = system_now_time();
                    }
                }

                prev_timer_start = mac_vars.timer_start;
                mac_vars.timer_start = system_now_time();
            }
            system_mutex_acquire(mac_vars.global_frame_mutex);
        }

        MacProfileScope("Cleanup"){
            mac_vars.first = false;

            linalloc_clear(&mac_vars.frame_arena);

            // NOTE(yuval): Release the global frame mutex until the next drawRect call
            system_mutex_release(mac_vars.global_frame_mutex);
        }
    }

    mac_profile("Frame", prev_timer_start, mac_vars.timer_start);
#if FRED_INTERNAL
    printf("\n");
#endif
}

// NOTE(allen): Trying to figure out a way to stop the error bonk
// sound every time I use a key combo. This stopped the sound as the
// docs suggested, but also stopped the key combo from being processed?
// Maybe put process_keyboard_event in there? But is this only sent
// for key downs? And why doesn't this block normal text input but
// only key combos??
#if 1
- (BOOL)performKeyEquivalent:(NSEvent *)event{
    [self process_keyboard_event:event down:true];
    return(YES);
}
#endif

#if 1
- (void)cancelOperation:(id)sender
{}
#endif

- (BOOL)acceptsFirstResponder{
    return(YES);
}

- (BOOL)becomeFirstResponder{
    return(YES);
}

- (BOOL)resignFirstResponder{
    return(YES);
}

- (void)keyDown:(NSEvent*)event{
    // NOTE(yuval): Process keyboard event
    [self process_keyboard_event:event down:true];
	[self interpretKeyEvents:[NSArray arrayWithObject:event]];

    // TODO(allen): Deduplicate with insertText version
    // NOTE(allen): We need to manually send text for '\n' and '\t'
    {
        NSString *characters = [event characters];
        u32 len = [characters length];
        if (len == 1){
            // NOTE(yuval): Get the first utf-16 character
            u32 c = [characters characterAtIndex:0];
            if (c == '\r'){
                c = '\n';
            }
            if ((c == '\t') || (c == '\n')){
                u8 *str = push_array(&mac_vars.frame_arena, u8, 1);
	            str[0] = (u8)c;

Input_Event *event = push_input_event(&mac_vars.frame_arena, &mac_vars.input_chunk.trans.event_list);
                event->kind = InputEventKind_TextInsert;
                event->text.string = SCu8(str, 1);
                event->text.next_text = 0;
                event->text.blocked = false;
                if (mac_vars.active_text_input){
                    mac_vars.active_text_input->text.next_text = event;
                } else if (mac_vars.active_key_stroke){
                    mac_vars.active_key_stroke->key.first_dependent_text = event;
                }

                mac_vars.active_text_input = event;

                system_signal_step(0);
            }
        }
    }
}

- (void)keyUp:(NSEvent*)event{
    [self process_keyboard_event:event down:false];
}

- (void)flagsChanged:(NSEvent *)event{
    NSEventModifierFlags flags = [event modifierFlags];
    b8 ctrl_pressed = ((flags & NSEventModifierFlagControl) != 0);
    b8 alt_pressed = ((flags & NSEventModifierFlagOption) != 0);
    b8 shift_pressed = ((flags & NSEventModifierFlagShift) != 0);
    b8 command_pressed = ((flags & NSEventModifierFlagCommand) != 0);

    Control_Keys *controls = &mac_vars.input_chunk.pers.controls;
    u16 event_key_code = [event keyCode];
    if (event_key_code == kVK_Control){
        controls->l_ctrl = ctrl_pressed;
        [self process_keyboard_event:event down:ctrl_pressed];
    } else if (event_key_code == kVK_RightControl){
        controls->r_ctrl = ctrl_pressed;
        [self process_keyboard_event:event down:ctrl_pressed];
    } else if (event_key_code == kVK_Option){
        controls->l_alt = alt_pressed;
        [self process_keyboard_event:event down:alt_pressed];
    }  else if (event_key_code == kVK_RightOption){
        controls->r_alt = alt_pressed;
        [self process_keyboard_event:event down:alt_pressed];
    } else if (event_key_code == kVK_Shift){
        controls->l_shift = shift_pressed;
        [self process_keyboard_event:event down:shift_pressed];
    } else if (event_key_code == kVK_RightShift){
        controls->r_shift = shift_pressed;
        [self process_keyboard_event:event down:shift_pressed];
    } else if (event_key_code == kVK_Command){
        controls->l_command = command_pressed;
        [self process_keyboard_event:event down:command_pressed];
    } else if (event_key_code == kVK_RightCommand){
        controls->r_command = command_pressed;
        [self process_keyboard_event:event down:command_pressed];
    }
}

- (void)unmarkText{
}

- (NSArray<NSAttributedStringKey>*)validAttributesForMarkedText{
	return [NSArray array];
}

- (NSAttributedString *)attributedSubstringForProposedRange:(NSRange)range
                                                actualRange:(NSRangePointer)actualRange{
	return nil;
}

- (void)insertText:(id)string
  replacementRange:(NSRange)replacementRange{
  	NSString *text = (NSString*)string;
	u32 len = [text length];
	Scratch_Block scratch(mac_vars.tctx);
	u16 *utf16 = push_array(scratch, u16, len);
	[text getCharacters:utf16 range:NSMakeRange(0, len)];
	String_Const_u16 str_16 = SCu16(utf16, len);
	String_Const_u8 str_8 = string_u8_from_string_u16(&mac_vars.frame_arena, str_16).string;
	for (i64 i = 0; i < str_8.size; i += 1){
	  if (str_8.str[i] == '\r'){
		  str_8.str[i] = '\n';
	  }
	}

	Input_Event *event = push_input_event(&mac_vars.frame_arena, &mac_vars.input_chunk.trans.event_list);
	event->kind = InputEventKind_TextInsert;
	event->text.string = str_8;
	event->text.next_text = 0;
	event->text.blocked = false;
	if (mac_vars.active_text_input){
	  mac_vars.active_text_input->text.next_text = event;
	} else if (mac_vars.active_key_stroke){
	  mac_vars.active_key_stroke->key.first_dependent_text = event;
	}

	mac_vars.active_text_input = event;

	system_signal_step(0);
}

- (NSUInteger)characterIndexForPoint:(NSPoint)point{
	return NSNotFound;
}

- (NSRect)firstRectForCharacterRange:(NSRange)range
                         actualRange:(NSRangePointer)actualRange{
	return NSMakeRect(0, 0, 0, 0);
}

- (void)doCommandBySelector:(SEL)selector{
}

- (BOOL)hasMarkedText{
	return NO;
}

- (NSRange)markedRange{
	return NSMakeRange(NSNotFound, 0);
}

- (NSRange)selectedRange{
	return NSMakeRange(NSNotFound, 0);
}

- (void)setMarkedText:(id)string
        selectedRange:(NSRange)selectedRange
     replacementRange:(NSRange)replacementRange{
}

- (void)mouseMoved:(NSEvent*)event{
    [self process_mouse_move_event:event];
}

- (void)mouseDragged:(NSEvent*)event{
    [self process_mouse_move_event:event];
}

- (void)scrollWheel:(NSEvent *)event{
    f32 dy = event.scrollingDeltaY;
    if ([event hasPreciseScrollingDeltas]){
        mac_vars.input_chunk.trans.mouse_wheel = (i32)(-dy);
    }
    else{
        if (dy > 0){
            mac_vars.input_chunk.trans.mouse_wheel = -100;
        }
        else{
            mac_vars.input_chunk.trans.mouse_wheel = 100;
        }
    }
    system_signal_step(0);
}

- (void)mouseDown:(NSEvent*)event{
    mac_vars.input_chunk.trans.mouse_l_press = true;
    mac_vars.input_chunk.pers.mouse_l = true;

    system_signal_step(0);
}

- (void)mouseUp:(NSEvent*)event{
    mac_vars.input_chunk.trans.mouse_l_release = true;
    mac_vars.input_chunk.pers.mouse_l = false;

    system_signal_step(0);
}

- (void)rightMouseDown:(NSEvent*)event{
    [super rightMouseDown:event];

    mac_vars.input_chunk.trans.mouse_r_press = true;
    mac_vars.input_chunk.pers.mouse_r = true;

    system_signal_step(0);
}

- (void)rightMouseUp:(NSEvent*)event{
    mac_vars.input_chunk.trans.mouse_r_release = true;
    mac_vars.input_chunk.pers.mouse_r = false;

    system_signal_step(0);
}

- (void)request_display{
    CGRect cg_rect = CGRectMake(0, 0, mac_vars.width, mac_vars.height);
    NSRect rect = NSRectFromCGRect(cg_rect);
    [self setNeedsDisplayInRect:rect];
}

- (void)check_clipboard{
    u32 change_count = mac_get_clipboard_change_count();
    if (change_count != mac_vars.clipboard_change_count){
        system_signal_step(0);
    }
}

- (void)process_keyboard_event:(NSEvent*)event down:(b8)down{
    b8 release = !down;

    Input_Modifier_Set_Fixed *mods = &mac_vars.input_chunk.pers.modifiers;

    // NOTE(yuval): Set control modifiers
    {
        Control_Keys *controls = &mac_vars.input_chunk.pers.controls;

        b8 ctrl = (controls->r_ctrl || (controls->l_ctrl && !controls->r_alt));
        b8 alt = (controls->l_alt || (controls->r_alt && !controls->l_ctrl));
        if (mac_vars.lctrl_lalt_is_altgr && controls->l_alt && controls->l_ctrl){
            ctrl = false;
            alt = false;
        }

        b8 shift = (controls->r_shift || controls->l_shift);
        b8 command = (controls->r_command || controls->l_command);

        set_modifier(mods, KeyCode_Control, ctrl);
        set_modifier(mods, KeyCode_Alt, alt);
        set_modifier(mods, KeyCode_Shift, shift);
        set_modifier(mods, KeyCode_Command, command);
    }

    // NOTE(yuval): Process KeyStroke / KeyRelease event
    {
        // TODO(allen): We need to make sure we're mapping from this event's key code to the
        // universal key code value for the given key, which will be given by mapping through
        // the physical position/scan code in the standard US keyboard.
        u16 event_key_code = [event keyCode];
        Key_Code key = keycode_lookup_table[(u8)event_key_code];
        if (down){
            if (key != 0){
                add_modifier(mods, key);

                Input_Event *event = push_input_event(&mac_vars.frame_arena, &mac_vars.input_chunk.trans.event_list);
                event->kind = InputEventKind_KeyStroke;
                event->key.code = key;
                event->key.modifiers = copy_modifier_set(&mac_vars.frame_arena, mods);

                mac_vars.active_key_stroke = event;

                system_signal_step(0);
            }
        } else{
            mac_vars.active_key_stroke = 0;
            mac_vars.active_text_input = 0;

            if (key != 0){
                Input_Event *event = push_input_event(&mac_vars.frame_arena, &mac_vars.input_chunk.trans.event_list);
                event->kind = InputEventKind_KeyRelease;
                event->key.code = key;
                event->key.modifiers = copy_modifier_set(&mac_vars.frame_arena, mods);

                remove_modifier(mods, key);
            }

            system_signal_step(0);
        }
    }
}

- (void)process_mouse_move_event:(NSEvent*)event{
    NSPoint location = [event locationInWindow];
    NSPoint backing_location = [self convertPointToBacking:location];

    Vec2_i32 new_m = V2i32(backing_location.x, mac_vars.height - backing_location.y);
    if (new_m != mac_vars.input_chunk.pers.mouse){
        mac_vars.input_chunk.pers.mouse = new_m;

        Rect_i32 screen = Ri32(0, 0, target.width, target.height);
        mac_vars.input_chunk.trans.out_of_window = !rect_contains_point(screen, new_m);

    }

    system_signal_step(0);
}
@end

////////////////////////////////

int
main(int arg_count, char **args){
    @autoreleasepool{
        // NOTE(yuval): Create NSApplication & Delegate
        [NSApplication sharedApplication];
        Assert(NSApp != nil);

        [NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];

        FCoder_App_Delegate *app_delegate = [[FCoder_App_Delegate alloc] init];
        [NSApp setDelegate:app_delegate];

        mac_init_recursive_mutex(&memory_tracker_mutex);

        // NOTE(yuval): Context setup
        Thread_Context _tctx = {};
        thread_ctx_init(&_tctx, ThreadKind_Main,
                        get_base_allocator_system(),
                        get_base_allocator_system());

        block_zero_struct(&mac_vars);
        mac_vars.tctx = &_tctx;

        API_VTable_system system_vtable = {};
        system_api_fill_vtable(&system_vtable);

        API_VTable_graphics graphics_vtable = {};
        graphics_api_fill_vtable(&graphics_vtable);

        API_VTable_font font_vtable = {};
        font_api_fill_vtable(&font_vtable);

        // NOTE(yuval): Memory
        mac_vars.frame_arena = make_arena_system();
        target.arena = make_arena_system(KB(256));

        dll_init_sentinel(&mac_vars.free_mac_objects);
        dll_init_sentinel(&mac_vars.timer_objects);

        mac_init_recursive_mutex(&mac_vars.thread_launch_mutex);
        pthread_cond_init(&mac_vars.thread_launch_cv, 0);

        // NOTE(yuval): Screen scale factor calculation
        {
            NSScreen* screen = [NSScreen mainScreen];
            NSDictionary* desc = [screen deviceDescription];
            NSSize size = [[desc valueForKey:NSDeviceResolution] sizeValue];
            f32 max_dpi = Max(size.width, size.height);
            mac_vars.screen_scale_factor = (max_dpi / 72.0f);
        }

        // NOTE(yuval): Load core
        System_Library core_library = {};
        {
            App_Get_Functions *get_funcs = 0;
            Scratch_Block scratch(mac_vars.tctx);
            String8List search_list = {};
            def_search_list_add_system_path(scratch, &search_list, SystemPath_Binary);

            String_Const_u8 core_path = def_search_get_full_path(scratch, &search_list, SCu8("4ed_app.so"));
            if (system_load_library(scratch, core_path, &core_library)){
                get_funcs = (App_Get_Functions*)system_get_proc(core_library, "app_get_functions");
                if (get_funcs != 0){
                    app = get_funcs();
                }
                else{
                    char msg[] = "Failed to get application code from '4ed_app.so'.";
                    system_error_box(msg);
                }
            }
            else{
                char msg[] = "Could not load '4ed_app.so'. This file should be in the same directory as the main '4ed' executable.";
                system_error_box(msg);
            }
        }

        // NOTE(yuval): Send api vtables to core
        app.load_vtables(&system_vtable, &font_vtable, &graphics_vtable);
        mac_vars.log_string = app.get_logger();

        // NOTE(yuval): Init & command line parameters
        Plat_Settings plat_settings = {};
        mac_vars.base_ptr = 0;
        {
            Scratch_Block scratch(mac_vars.tctx);
            String_Const_u8 curdir = system_get_path(scratch, SystemPath_CurrentDirectory);
            curdir = string_mod_replace_character(curdir, '\\', '/');
            char **files = 0;
            i32 *file_count = 0;
            mac_vars.base_ptr = app.read_command_line(mac_vars.tctx, curdir, &plat_settings, &files, &file_count, arg_count, args);
            {
                i32 end = *file_count;
                i32 i = 0, j = 0;
                for (; i < end; ++i){
                    if (mac_file_can_be_made((u8*)files[i])){
                        files[j] = files[i];
                        ++j;
                    }
                }
                *file_count = j;
            }
        }

        // NOTE(yuval): Load custom layer
        System_Library custom_library = {};
        Custom_API custom = {};
        {
            char custom_not_found_msg[] = "Did not find a library for the custom layer.";
            char custom_fail_version_msg[] = "Failed to load custom code due to missing version information or a version mismatch.  Try rebuilding with buildsuper.";
            char custom_fail_init_apis[] = "Failed to load custom code due to missing 'init_apis' symbol.  Try rebuilding with buildsuper";

            Scratch_Block scratch(mac_vars.tctx);
            String_Const_u8 default_file_name = string_u8_litexpr("custom_4coder.so");
            String8List search_list = {};
            def_search_list_add_system_path(scratch, &search_list, SystemPath_CurrentDirectory);
            def_search_list_add_system_path(scratch, &search_list, SystemPath_UserDirectory);
            def_search_list_add_system_path(scratch, &search_list, SystemPath_Binary);

            String_Const_u8 custom_file_names[2] = {};
            i32 custom_file_count = 1;
            if (plat_settings.custom_dll != 0){
                custom_file_names[0] = SCu8(plat_settings.custom_dll);
                if (!plat_settings.custom_dll_is_strict){
                    custom_file_names[1] = default_file_name;
                    custom_file_count += 1;
                }
            }
            else{
                custom_file_names[0] = default_file_name;
            }
            String_Const_u8 custom_file_name = {};
            for (i32 i = 0; i < custom_file_count; i += 1){
                custom_file_name = def_search_get_full_path(scratch, &search_list, custom_file_names[i]);
                if (custom_file_name.size > 0){
                    break;
                }
            }
            b32 has_library = false;
            if (custom_file_name.size > 0){
                if (system_load_library(scratch, custom_file_name, &custom_library)){
                    has_library = true;
                }
            }

            if (!has_library){
                system_error_box(custom_not_found_msg);
            }
            custom.get_version = (_Get_Version_Type*)system_get_proc(custom_library, "get_version");
            if (custom.get_version == 0 || custom.get_version(MAJOR, MINOR, PATCH) == 0){
                system_error_box(custom_fail_version_msg);
            }
            custom.init_apis = (_Init_APIs_Type*)system_get_proc(custom_library, "init_apis");
            if (custom.init_apis == 0){
                system_error_box(custom_fail_init_apis);
            }
        }

        //
        // Window and Renderer Initialization
        //

        // NOTE(yuval): Create Window & Window Delegate
        i32 w;
        i32 h;
        if (plat_settings.set_window_size){
            w = plat_settings.window_w;
            h = plat_settings.window_h;
        } else{
            w = 800;
            h = 600;
        }

        NSRect screen_rect = [[NSScreen mainScreen] frame];
        NSRect initial_frame = NSMakeRect((f32)(screen_rect.size.width - w) * 0.5f, (f32)(screen_rect.size.height - h) * 0.5f, w, h);

        u32 style_mask = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskMiniaturizable | NSWindowStyleMaskResizable;

        mac_vars.window = [[NSWindow alloc] initWithContentRect:initial_frame
                           styleMask:style_mask
                           backing:NSBackingStoreBuffered
                           defer:NO];

        FCoder_Window_Delegate *window_delegate = [[FCoder_Window_Delegate alloc] init];
        [mac_vars.window setDelegate:window_delegate];

        [mac_vars.window setMinSize:NSMakeSize(100, 100)];
        [mac_vars.window setBackgroundColor:NSColor.blackColor];
        [mac_vars.window setTitle:@"GRAPHICS"];
        [mac_vars.window setAcceptsMouseMovedEvents:YES];

        NSView* content_view = [mac_vars.window contentView];

        // NOTE(yuval): Create the 4coder view
        mac_vars.view = [[FCoder_View alloc] init];
        [mac_vars.view setFrame:[content_view bounds]];
        [mac_vars.view setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
        mac_vars.view.wantsLayer = true;

        // NOTE(yuval): Display window and view
        [content_view addSubview:mac_vars.view];
        [mac_vars.window makeKeyAndOrderFront:nil];

        // NOTE(yuval): Initialize the renderer
        renderer = mac_init_renderer(MacRenderer_Metal, mac_vars.window, &target);

        mac_resize(w, h);

        //
        // NOTE(yuval): Misc System Initializations
        //

        // NOTE(yuval): Initialize clipboard
        {
            Scratch_Block scratch(mac_vars.tctx);
            mac_post_clipboard(scratch, "", 0);
            mac_vars.clipboard_change_count = mac_get_clipboard_change_count();
            mac_vars.next_clipboard_is_self = false;

            // NOTE(yuval): Start the clipboard polling timer
            [NSTimer scheduledTimerWithTimeInterval: 0.5
             target:mac_vars.view
             selector:@selector(check_clipboard)
             userInfo:nil repeats:YES];
        }

        // NOTE(yuval): Initialize the virtul keycodes table
        mac_keycode_init();

        // NOTE(yuval): Initialize cursors
        {
            mac_vars.cursor_show = MouseCursorShow_Always;
            mac_vars.prev_cursor_show = MouseCursorShow_Always;

            mac_vars.cursor_arrow = [NSCursor arrowCursor];
            mac_vars.cursor_ibeam = [NSCursor IBeamCursor];
            mac_vars.cursor_leftright = [NSCursor resizeLeftRightCursor];
            mac_vars.cursor_updown = [NSCursor resizeUpDownCursor];
        }

        // NOTE(yuval): Get the timebase info
        mach_timebase_info(&mac_vars.timebase_info);

        //
        // App init
        //

        {
            Scratch_Block scratch(mac_vars.tctx);
            String_Const_u8 curdir = system_get_path(scratch, SystemPath_CurrentDirectory);
            curdir = string_mod_replace_character(curdir, '\\', '/');
            app.init(mac_vars.tctx, &target, mac_vars.base_ptr, curdir, custom);
        }

        //
        // Start Main Loop
        //

        mac_vars.first = true;
        mac_vars.step_requested = false;
        mac_vars.running_cli = 0;

        if (plat_settings.fullscreen_window){
            mac_vars.do_toggle = true;
        }

        mac_vars.global_frame_mutex = system_mutex_make();

        mac_vars.timer_start = system_now_time();

        // NOTE(yuval): Start the app's run loop
        [NSApp run];
    }
}


// end --- mac_4ed.mm --- 



// begin --- mac_4ed_functions.mm --- 

/* macOS System/Graphics/Font API Implementations */

/********************/
/*    System API    */
/********************/

////////////////////////////////

function
system_get_path_sig(){
    String_Const_u8 result = {};

    switch (path_code){
        case SystemPath_CurrentDirectory:
        {
            char *working_dir = getcwd(NULL, 0);
            u64 working_dir_length = cstring_length(working_dir);

            // TODO(yuval): Maybe use push_string_copy instead
            u8 *out = push_array(arena, u8, working_dir_length);
            block_copy(out, working_dir, working_dir_length);

            free(working_dir);

            result = SCu8(out, working_dir_length);
        } break;

        case SystemPath_Binary:
        {
            local_persist b32 has_stashed_4ed_path = false;
            if (!has_stashed_4ed_path){
                local_const u32 binary_path_capacity = PATH_MAX;
                u8 *memory = (u8*)system_memory_allocate(binary_path_capacity, file_name_line_number_lit_u8);

                pid_t pid = getpid();
                i32 size = proc_pidpath(pid, memory, binary_path_capacity);
                Assert(size < binary_path_capacity);

                mac_vars.binary_path = SCu8(memory, size);
                mac_vars.binary_path = string_remove_last_folder(mac_vars.binary_path);
                mac_vars.binary_path.str[mac_vars.binary_path.size] = 0;

                has_stashed_4ed_path = true;
            }

            result = push_string_copy(arena, mac_vars.binary_path);
        } break;

        case SystemPath_UserDirectory:
        {
            char *home_cstr = getenv("HOME");
            if (home_cstr != 0){
                result = push_u8_stringf(arena, "%s/.4coder/", home_cstr);
            }
        }break;
    }

    return(result);
}

function
system_get_canonical_sig(){
    NSString *path_ns_str =
        [[NSString alloc] initWithBytes:name.str length:name.size encoding:NSUTF8StringEncoding];

    NSString *standardized_path_ns_str = [path_ns_str stringByStandardizingPath];
    String_Const_u8 standardized_path = SCu8((u8*)[standardized_path_ns_str UTF8String],[standardized_path_ns_str lengthOfBytesUsingEncoding:NSUTF8StringEncoding]);

    String_Const_u8 result = push_string_copy(arena, standardized_path);

    [path_ns_str release];

    return(result);
}

////////////////////////////////

function File_Attributes
mac_get_file_attributes(struct stat file_stat) {
    File_Attributes result;
    result.size = file_stat.st_size;
    result.last_write_time = file_stat.st_mtimespec.tv_sec;

    result.flags = 0;
    if (S_ISDIR(file_stat.st_mode)) {
        result.flags |= FileAttribute_IsDirectory;
    }

    return(result);
}

function inline File_Attributes
mac_file_attributes_from_path(char *path) {
    File_Attributes result = {};

    struct stat file_stat;
    if (stat(path, &file_stat) == 0){
        result = mac_get_file_attributes(file_stat);
    }

    return(result);
}

function inline File_Attributes
mac_file_attributes_from_fd(i32 fd) {
    File_Attributes result = {};

    struct stat file_stat;
    if (fstat(fd, &file_stat) == 0){
        result = mac_get_file_attributes(file_stat);
    }

    return(result);
}

function
system_get_file_list_sig(){
    File_List result = {};

    u8 *c_directory = push_array(arena, u8, directory.size + 1);
    block_copy(c_directory, directory.str, directory.size);
    c_directory[directory.size] = 0;

    DIR *dir = opendir((char*)c_directory);
    if (dir){
        File_Info* first = 0;
        File_Info* last = 0;
        i32 count = 0;

        for (struct dirent *entry = readdir(dir);
             entry;
             entry = readdir(dir)){
            char *c_file_name = entry->d_name;
            String_Const_u8 file_name = SCu8(c_file_name);

            if (string_match(file_name, string_u8_litexpr(".")) || string_match(file_name, string_u8_litexpr(".."))){
                continue;
            }

            File_Info *info = push_array(arena, File_Info, 1);
            sll_queue_push(first, last, info);
            count += 1;

            info->file_name = push_string_copy(arena, file_name);

            // NOTE(yuval): Get file attributes
            {
                Temp_Memory temp = begin_temp(arena);

                b32 append_slash = false;
                u64 file_path_size = directory.size + file_name.size;
                if (string_get_character(directory, directory.size - 1) != '/'){
                    append_slash = true;
                    file_path_size += 1;
                }

                char *file_path = push_array(arena, char, file_path_size + 1);
                char *file_path_at = file_path;

                block_copy(file_path_at, directory.str, directory.size);
                file_path_at += directory.size;

                if (append_slash){
                    *file_path_at = '/';
                    file_path_at += 1;
                }

                block_copy(file_path_at, file_name.str, file_name.size);
                file_path_at += file_name.size;

                *file_path_at = 0;

                info->attributes = mac_file_attributes_from_path(file_path);

                end_temp(temp);
            }
        }

        closedir(dir);

        result.infos = push_array(arena, File_Info*, count);
        result.count = count;

        i32 index = 0;
        for (File_Info *node = first;
             node != 0;
             node = node->next){
            result.infos[index] = node;
            index += 1;
        }
    }

    return(result);
}

function
system_quick_file_attributes_sig(){
    Temp_Memory temp = begin_temp(scratch);

    char *c_file_name = push_array(scratch, char, file_name.size + 1);
    block_copy(c_file_name, file_name.str, file_name.size);
    c_file_name[file_name.size] = 0;

    File_Attributes result = mac_file_attributes_from_path(c_file_name);

    end_temp(temp);

    return(result);
}

function inline Plat_Handle
mac_to_plat_handle(i32 fd){
    Plat_Handle result = *(Plat_Handle*)(&fd);
    return(result);
}

function inline i32
mac_to_fd(Plat_Handle handle){
    i32 result = *(i32*)(&handle);
    return(result);
}

function
system_load_handle_sig(){
    b32 result = false;

    i32 fd = open(file_name, O_RDONLY);
    if ((fd != -1) && (fd != 0)) {
        *out = mac_to_plat_handle(fd);
        result = true;
    }

    return(result);
}

function
system_load_attributes_sig(){
    i32 fd = mac_to_fd(handle);
    File_Attributes result = mac_file_attributes_from_fd(fd);

    return(result);
}

function
system_load_file_sig(){
    i32 fd = mac_to_fd(handle);

    do{
        ssize_t bytes_read = read(fd, buffer, size);
        if (bytes_read == -1){
            if (errno != EINTR){
                // NOTE(yuval): An error occured while reading from the file descriptor
                break;
            }
        } else{
            size -= bytes_read;
            buffer += bytes_read;
        }
    } while (size > 0);

    b32 result = (size == 0);
    return(result);
}

function
system_load_close_sig(){
    b32 result = true;

    i32 fd = mac_to_fd(handle);
    if (close(fd) == -1){
        // NOTE(yuval): An error occured while close the file descriptor
        result = false;
    }

    return(result);
}

function
system_save_file_sig(){
    File_Attributes result = {};

    i32 fd = open(file_name, O_WRONLY | O_TRUNC | O_CREAT, 00640);
    if (fd != -1) {
        do{
            ssize_t bytes_written = write(fd, data.str, data.size);
            if (bytes_written == -1){
                if (errno != EINTR){
                    // NOTE(yuval): An error occured while writing to the file descriptor
                    break;
                }
            } else{
                data.size -= bytes_written;
                data.str += bytes_written;
            }
        } while (data.size > 0);

        if (data.size == 0) {
            result = mac_file_attributes_from_fd(fd);
        }

        close(fd);
    }

    return(result);
}

////////////////////////////////

function inline System_Library
mac_to_system_library(void *dl_handle){
    System_Library result = *(System_Library*)(&dl_handle);
    return(result);
}

function inline void*
mac_to_dl_handle(System_Library system_lib){
    void *result = *(void**)(&system_lib);
    return(result);
}

function
system_load_library_sig(){
    b32 result = false;

    void *lib = 0;

    // NOTE(yuval): Open library handle
    {
        Temp_Memory temp = begin_temp(scratch);

        char *c_file_name = push_array(scratch, char, file_name.size + 1);
        block_copy(c_file_name, file_name.str, file_name.size);
        c_file_name[file_name.size] = 0;

        lib = dlopen(c_file_name, RTLD_LAZY | RTLD_GLOBAL);

        end_temp(temp);
    }

    if (lib){
        *out = mac_to_system_library(lib);
        result = true;
    }

    return(result);
}

function
system_release_library_sig(){
    void *lib = mac_to_dl_handle(handle);
    i32 rc = dlclose(lib);

    b32 result = (rc == 0);
    return(result);
}

function
system_get_proc_sig(){
    void *lib = mac_to_dl_handle(handle);
    Void_Func *result = (Void_Func*)dlsym(lib, proc_name);

    return(result);
}

////////////////////////////////

function
system_now_time_sig(){
    u64 now = mach_absolute_time();

    // NOTE(yuval): Now time nanoseconds conversion
    f64 now_nano = (f64)((f64)now *
                         ((f64)mac_vars.timebase_info.numer /
                          (f64)mac_vars.timebase_info.denom));

    // NOTE(yuval): Conversion to useconds
    u64 result = (u64)(now_nano * 1.0E-3);
    return(result);
}

function void
mac_date_time_from_tm(Date_Time *out, struct tm *in){
    out->year = in->tm_year + 1900;
    out->mon = in->tm_mon;
    out->day = in->tm_mday - 1;
    out->hour = in->tm_hour;
    out->min = in->tm_min;
    out->sec = in->tm_sec;
    out->msec = 0;
}

function void
mac_tm_from_date_time(struct tm *out, Date_Time *in){
    out->tm_year = in->year - 1900;
    out->tm_mon = in->mon;
    out->tm_mday = in->day + 1;
    out->tm_hour = in->hour;
    out->tm_min = in->min;
    out->tm_sec = in->sec;
}

function
system_now_date_time_universal_sig(){
    time_t now_time = time(0);
    struct tm *now_tm = gmtime(&now_time);
    Date_Time result = {};
    mac_date_time_from_tm(&result, now_tm);
    return(result);
}

function
system_local_date_time_from_universal_sig(){
    struct tm univ_tm = {};
    mac_tm_from_date_time(&univ_tm, date_time);
    time_t utc_time = timegm(&univ_tm);
    struct tm *local_tm = localtime(&utc_time);
    Date_Time result = {};
    mac_date_time_from_tm(&result, local_tm);
    return(result);
}

function
system_universal_date_time_from_local_sig(){
    struct tm local_tm = {};
    mac_tm_from_date_time(&local_tm, date_time);
    time_t loc_time = timelocal(&local_tm);
    struct tm *utc_tm = gmtime(&loc_time);
    Date_Time result = {};
    mac_date_time_from_tm(&result, utc_tm);
    return(result);
}

function
system_wake_up_timer_create_sig(){
    Mac_Object *object = mac_alloc_object(MacObjectKind_Timer);
    dll_insert(&mac_vars.timer_objects, &object->node);

    object->timer = nil;

    Plat_Handle result = mac_to_plat_handle(object);
    return(result);
}

function
system_wake_up_timer_release_sig(){
    Mac_Object *object = mac_to_object(handle);
    if (object->kind == MacObjectKind_Timer){
        if ((object->timer != nil) && [object->timer isValid]) {
            [object->timer invalidate];
            mac_free_object(object);
        }
    }
}

function
system_wake_up_timer_set_sig(){
    Mac_Object *object = mac_to_object(handle);
    if (object->kind == MacObjectKind_Timer){
        f64 time_seconds = ((f64)time_milliseconds / 1000.0);
        object->timer = [NSTimer scheduledTimerWithTimeInterval:time_seconds
                target:mac_vars.view
                selector:@selector(request_display)
                userInfo:nil repeats:NO];
    }
}

function
system_signal_step_sig(){
#if 0
    if (!mac_vars.step_requested){
        [NSTimer scheduledTimerWithTimeInterval:0.0
                target:mac_vars.view
                selector:@selector(request_display)
                userInfo:nil repeats:NO];

        mac_vars.step_requested = true;
    }
#else
    mac_vars.step_requested = true;
    dispatch_async(dispatch_get_main_queue(),
                   ^{
                        [NSTimer scheduledTimerWithTimeInterval:0.0
                         target:mac_vars.view
                         selector:@selector(request_display)
                         userInfo:nil repeats:NO];
                   });
#endif
}

function
system_sleep_sig(){
    u64 nanoseconds = (microseconds * Thousand(1));
    u64 abs_sleep_time = (u64)((f64)nanoseconds *
                               ((f64)mac_vars.timebase_info.denom /
                                (f64)mac_vars.timebase_info.numer));

    u64 now = mach_absolute_time();
    mach_wait_until(now + abs_sleep_time);
}

////////////////////////////////

function
system_cli_call_sig(){
    b32 result = false;

    int pipe_fds[2];
    if (pipe(pipe_fds) == -1){
        perror("system_cli_call: pipe");
        return(false);
    }

    pid_t child_pid = fork();
    if (child_pid == -1){
        perror("system_cli_call: fork");
        return(false);
    }

    enum { PIPE_FD_READ, PIPE_FD_WRITE };

    if (child_pid == 0){
        // NOTE(yuval): Child Process
        close(pipe_fds[PIPE_FD_READ]);
        dup2(pipe_fds[PIPE_FD_WRITE], STDOUT_FILENO);
        dup2(pipe_fds[PIPE_FD_WRITE], STDERR_FILENO);

        if (chdir(path) == -1){
            perror("system_cli_call: chdir");
            exit(1);
        }

        char* argv[] = {"sh", "-c", script, 0};

        if (execv("/bin/sh", argv) == -1){
            perror("system_cli_call: execv");
        }

        exit(1);
    } else{
        // NOTE(yuval): Parent Process
        close(pipe_fds[PIPE_FD_WRITE]);

        *(pid_t*)&cli_out->proc = child_pid;
        *(int*)&cli_out->out_read = pipe_fds[PIPE_FD_READ];
        *(int*)&cli_out->out_write = pipe_fds[PIPE_FD_WRITE];

        mac_vars.running_cli += 1;
    }

    return(true);
}

function
system_cli_begin_update_sig(){
    // NOTE(yuval): Nothing to do here.
}

function
system_cli_update_step_sig(){
    int pipe_read_fd = *(int*)&cli->out_read;

    fd_set fds;
    FD_ZERO(&fds);
    FD_SET(pipe_read_fd, &fds);

    struct timeval tv = {};

    size_t space_left = max;
    char* ptr = dest;

    while (space_left > 0 && (select(pipe_read_fd + 1, &fds, NULL, NULL, &tv) == 1)){
        ssize_t num = read(pipe_read_fd, ptr, space_left);
        if (num == -1){
            perror("system_cli_update_step: read");
        } else if (num == 0){
            // NOTE(inso): EOF
            break;
        } else{
            ptr += num;
            space_left -= num;
        }
    }

    *amount = (ptr - dest);

    b32 result = ((ptr - dest) > 0);
    return(result);
}

function
system_cli_end_update_sig(){
    b32 close_me = false;

    pid_t pid = *(pid_t*)&cli->proc;

    int status;
    if (pid && (waitpid(pid, &status, WNOHANG) > 0)){
        cli->exit = WEXITSTATUS(status);

        close(*(int*)&cli->out_read);
        close(*(int*)&cli->out_write);

        mac_vars.running_cli -= 1;

        close_me = true;
    }

    return(close_me);
}

////////////////////////////////

function
system_open_color_picker_sig(){
    NotImplemented;
}

function
system_get_screen_scale_factor_sig(){
    f32 result = mac_vars.screen_scale_factor;
    return(result);
}

////////////////////////////////

function void*
mac_thread_wrapper(void *ptr){
    Mac_Object *object = (Mac_Object*)ptr;
    Thread_Function *proc = object->thread.proc;
    void *object_ptr = object->thread.ptr;

    pthread_mutex_lock(&mac_vars.thread_launch_mutex);
    {
        mac_vars.waiting_for_launch = false;
        pthread_cond_signal(&mac_vars.thread_launch_cv);
    }
    pthread_mutex_unlock(&mac_vars.thread_launch_mutex);

    proc(object_ptr);

    return(0);
}

function
system_thread_launch_sig(){
    Mac_Object *object = mac_alloc_object(MacObjectKind_Thread);
    object->thread.proc = proc;
    object->thread.ptr = ptr;

    pthread_mutex_lock(&mac_vars.thread_launch_mutex);
    {
        mac_vars.waiting_for_launch = true;
        pthread_create(&object->thread.thread, 0, mac_thread_wrapper, object);

        while (mac_vars.waiting_for_launch){
            pthread_cond_wait(&mac_vars.thread_launch_cv, &mac_vars.thread_launch_mutex);
        }
    }
    pthread_mutex_unlock(&mac_vars.thread_launch_mutex);

    System_Thread result = mac_to_plat_handle(object);
    return(result);
}

function
system_thread_join_sig(){
    Mac_Object *object = mac_to_object(thread);
    if (object->kind == MacObjectKind_Thread){
        pthread_join(object->thread.thread, 0);
    }
}

function
system_thread_free_sig(){
    Mac_Object* object = mac_to_object(thread);
    if (object->kind == MacObjectKind_Thread){
        mac_free_object(object);
    }
}

function
system_thread_get_id_sig(){
    pthread_t id = pthread_self();
    i32 result = *(i32*)(&id);
    return(result);
}

function
system_mutex_make_sig(){
    Mac_Object *object = mac_alloc_object(MacObjectKind_Mutex);
    mac_init_recursive_mutex(&object->mutex);

    System_Mutex result = mac_to_plat_handle(object);
    return(result);
}

function
system_mutex_acquire_sig(){
    Mac_Object *object = mac_to_object(mutex);
    if (object->kind == MacObjectKind_Mutex){
        pthread_mutex_lock(&object->mutex);
    }
}

function
system_mutex_release_sig(){
    Mac_Object *object = mac_to_object(mutex);
    if (object->kind == MacObjectKind_Mutex){
        pthread_mutex_unlock(&object->mutex);
    }
}

function
system_mutex_free_sig(){
    Mac_Object *object = mac_to_object(mutex);
    if (object->kind == MacObjectKind_Mutex){
        pthread_mutex_destroy(&object->mutex);
        mac_free_object(object);
    }
}

function
system_acquire_global_frame_mutex_sig(){
    if (tctx->kind == ThreadKind_AsyncTasks ||
        tctx->kind == ThreadKind_Main){
        system_mutex_acquire(mac_vars.global_frame_mutex);
    }
}

function
system_release_global_frame_mutex_sig(){
    if (tctx->kind == ThreadKind_AsyncTasks ||
        tctx->kind == ThreadKind_Main){
        system_mutex_release(mac_vars.global_frame_mutex);
    }
}

function
system_condition_variable_make_sig(){
    Mac_Object *object = mac_alloc_object(MacObjectKind_CV);
    pthread_cond_init(&object->cv, 0);

    System_Condition_Variable result = mac_to_plat_handle(object);
    return(result);
}

function
system_condition_variable_wait_sig(){
    Mac_Object *object_cv = mac_to_object(cv);
    Mac_Object *object_mutex = mac_to_object(mutex);
    if ((object_cv->kind == MacObjectKind_CV) && (object_mutex->kind == MacObjectKind_Mutex)){
        pthread_cond_wait(&object_cv->cv, &object_mutex->mutex);
    }
}

function
system_condition_variable_signal_sig(){
    Mac_Object *object = mac_to_object(cv);
    if (object->kind == MacObjectKind_CV){
        pthread_cond_signal(&object->cv);
    }
}

function
system_condition_variable_free_sig(){
    Mac_Object *object = mac_to_object(cv);
    if (object->kind == MacObjectKind_CV){
        pthread_cond_destroy(&object->cv);
        mac_free_object(object);
    }
}

////////////////////////////////

struct Memory_Annotation_Tracker_Node{
    Memory_Annotation_Tracker_Node *next;
    Memory_Annotation_Tracker_Node *prev;
    String_Const_u8 location;
    u64 size;
};

struct Memory_Annotation_Tracker{
    Memory_Annotation_Tracker_Node *first;
    Memory_Annotation_Tracker_Node *last;
    i32 count;
};

global Memory_Annotation_Tracker memory_tracker = {};
global pthread_mutex_t memory_tracker_mutex;

global_const u64 ALLOCATION_SIZE_ADJUSTMENT = 64;

function void*
mac_memory_allocate_extended(void *base, u64 size, String_Const_u8 location){
    u64 adjusted_size = size + ALLOCATION_SIZE_ADJUSTMENT;
    void *memory = mmap(base, adjusted_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    Assert(memory != MAP_FAILED);

    Memory_Annotation_Tracker_Node *node = (Memory_Annotation_Tracker_Node*)memory;

    pthread_mutex_lock(&memory_tracker_mutex);
    {
        zdll_push_back(memory_tracker.first, memory_tracker.last, node);
        memory_tracker.count += 1;
    }
    pthread_mutex_unlock(&memory_tracker_mutex);

    node->location = location;
    node->size = size;

    void* result = (node + 1);
    return(result);
}

function void
mac_memory_free_extended(void *ptr){
    Memory_Annotation_Tracker_Node *node = (Memory_Annotation_Tracker_Node*)ptr;
    node -= 1;

    pthread_mutex_lock(&memory_tracker_mutex);
    {
        zdll_remove(memory_tracker.first, memory_tracker.last, node);
        memory_tracker.count -= 1;
    }
    pthread_mutex_unlock(&memory_tracker_mutex);

    munmap(node, node->size + ALLOCATION_SIZE_ADJUSTMENT);
}

function
system_memory_allocate_sig(){
    void* result = mac_memory_allocate_extended(0, size, location);
    return(result);
}

function
system_memory_set_protection_sig(){
    b32 result = true;

    int protect = 0;
    switch (flags & 0x7){
        case 0:
        {
            protect = PROT_NONE;
        } break;

        case MemProtect_Read:
        {
            protect = PROT_READ;
        } break;

        case MemProtect_Write:
        case MemProtect_Read | MemProtect_Write:
        {
            protect = PROT_READ | PROT_WRITE;
        } break;

        case MemProtect_Execute:
        {
            protect = PROT_EXEC;
        } break;

        case MemProtect_Execute | MemProtect_Read:
        {
            protect = PROT_READ | PROT_EXEC;
        } break;

        // NOTE(inso): some W^X protection things might be unhappy about this one
        case MemProtect_Execute | MemProtect_Write:
        case MemProtect_Execute | MemProtect_Write | MemProtect_Read:
        {
            protect = PROT_READ | PROT_WRITE | PROT_EXEC;
        } break;
    }

    Memory_Annotation_Tracker_Node *node = (Memory_Annotation_Tracker_Node*)ptr;
    node -= 1;

    if(mprotect(node, size, protect) == -1){
        result = false;
    }

    return(result);
}

function
system_memory_free_sig(){
    mac_memory_free_extended(ptr);
}

function
system_memory_annotation_sig(){
    Memory_Annotation result = {};

    pthread_mutex_lock(&memory_tracker_mutex);
    {
        for (Memory_Annotation_Tracker_Node *node = memory_tracker.first;
             node != 0;
             node = node->next){
            Memory_Annotation_Node *r_node = push_array(arena, Memory_Annotation_Node, 1);
            sll_queue_push(result.first, result.last, r_node);
            result.count += 1;

            r_node->location = node->location;
            r_node->address = node + 1;
            r_node->size = node->size;
        }

    }
    pthread_mutex_unlock(&memory_tracker_mutex);

    return(result);
}

////////////////////////////////

function
system_show_mouse_cursor_sig(){
    mac_vars.cursor_show = show;
}

function
system_set_fullscreen_sig(){
    // NOTE(yuval): Read comment in system_set_fullscreen_sig in win32_4ed.cpp
    mac_vars.do_toggle = (mac_vars.full_screen != full_screen);

    b32 success = true;
    return(success);
}

function
system_is_fullscreen_sig(){
    // NOTE(yuval): Read comment in system_is_fullscreen_sig in win32_4ed.cpp
    b32 result = (mac_vars.full_screen != mac_vars.do_toggle);
    return(result);
}

function
system_get_keyboard_modifiers_sig(){
    Input_Modifier_Set result = copy_modifier_set(arena, &mac_vars.input_chunk.pers.modifiers);
    return(result);
}

function
system_set_key_mode_sig(){
    mac_vars.key_mode = mode;
}

internal void
system_set_source_mixer(void* ctx, Audio_Mix_Sources_Function* mix_func){
    // TODO(allen): Audio on Mac
}

internal void
system_set_destination_mixer(Audio_Mix_Destination_Function* mix_func){
    // TODO(allen): Audio on Mac
}

////////////////////////////////

/**********************/
/*    Graphics API    */
/**********************/

////////////////////////////////

function
graphics_get_texture_sig(){
    u32 result = renderer->get_texture(renderer, dim, texture_kind);
    return(result);
}

function
graphics_fill_texture_sig(){
    b32 result = renderer->fill_texture(renderer, texture_kind, texture, p, dim, data);
    return(result);
}

////////////////////////////////

/******************/
/*    Font API    */
/******************/

////////////////////////////////

function
font_make_face_sig(){
    Face* result = ft__font_make_face(arena, description, scale_factor);
    return(result);
}

////////////////////////////////


// end --- mac_4ed_functions.mm --- 



// begin --- mac_4ed_metal.mm --- 

/* Mac Metal layer for 4coder */

#import "metal/4ed_metal_render.mm"

////////////////////////////////

struct Mac_Metal{
    Mac_Renderer base;

    Metal_Renderer *renderer;
    MTKView *view;
};

////////////////////////////////

function
mac_render_sig(mac_metal__render){
#if defined(FRED_INTERNAL)
    printf("Redering using Metal!\n");
#endif

    Mac_Metal *metal = (Mac_Metal*)renderer;
    [metal->view draw];
}

function
mac_get_texture_sig(mac_metal__get_texture){
    Mac_Metal *metal = (Mac_Metal*)renderer;
    u32 result = [metal->renderer get_texture_of_dim:dim
            kind:texture_kind];

    return(result);
}

function
mac_fill_texture_sig(mac_metal__fill_texture){
    Mac_Metal *metal = (Mac_Metal*)renderer;
    b32 result = [metal->renderer fill_texture:texture
            kind:texture_kind
            pos:p
            dim:dim
            data:data];

    return(result);
}

function Mac_Metal*
mac_metal__init(NSWindow *window, Render_Target *target){
    // NOTE(yuval): Create the Mac Metal rendere
    Mac_Metal *metal = (Mac_Metal*)system_memory_allocate(sizeof(Mac_Metal),
                                                          file_name_line_number_lit_u8);
    metal->base.render = mac_metal__render;
    metal->base.get_texture = mac_metal__get_texture;
    metal->base.fill_texture = mac_metal__fill_texture;

    // NOTE(yuval): Create the Metal view
    NSView *content_view = [window contentView];

    metal->view = [[MTKView alloc] initWithFrame:[content_view bounds]];
    [metal->view setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
    [metal->view setPaused:YES];
    [metal->view setEnableSetNeedsDisplay:NO];

    metal->view.device = MTLCreateSystemDefaultDevice();

    // NOTE(yuval): Add the Metal view as a subview of the window
    [content_view addSubview:metal->view];

    // NOTE(yuval): Create the Metal renderer and set it as the Metal view's delegate
    metal->renderer = [[Metal_Renderer alloc] initWithMetalKitView:metal->view target:target];
    metal->view.delegate = metal->renderer;

    return(metal);
}

////////////////////////////////

// TODO(yuval): This function should be exported to a DLL
function
mac_load_renderer_sig(mac_load_metal_renderer){
    Mac_Renderer *renderer = (Mac_Renderer*)mac_metal__init(window, target);
    return(renderer);
}


// end --- mac_4ed_metal.mm --- 



// begin --- mac_4ed_opengl.mm --- 

/* Mac OpenGL layer for 4coder */

////////////////////////////////
#include <OpenGL/OpenGL.h>
#include <OpenGL/gl.h>

#define GL_FUNC(N,R,P) typedef R (CALL_CONVENTION N##_Function)P; N##_Function *N = 0;

////////////////////////////////

////////////////////////////////

@interface OpenGL_View : NSOpenGLView
- (void)init_gl;
- (void)render:(Render_Target*)target;
@end

////////////////////////////////

struct Mac_OpenGL{
    Mac_Renderer base;
    
    OpenGL_View *view;
};

////////////////////////////////

@implementation OpenGL_View{
    b32 gl_is_initialized;
}

- (id)init{
    self = [super init];
    if (self == nil){
        return nil;
    }
    
    gl_is_initialized = false;
    [self init_gl];
    
    return self;
}

- (void)dealloc{
    [super dealloc];
}

- (void)prepareOpenGL{
    [super prepareOpenGL];
    
    [[self openGLContext] makeCurrentContext];
    
    // NOTE(yuval): Setup vsync
    GLint swap_int = 1;
    [[self openGLContext] setValues:&swap_int forParameter:NSOpenGLCPSwapInterval];
}

- (void)awakeFromNib{
    [self init_gl];
}

- (void)reshape{
    [super reshape];
    
	[[self openGLContext] makeCurrentContext];
	[[self openGLContext] update];
}

- (void)init_gl{
    if (gl_is_initialized){
        return;
    }
    
    // NOTE(yuval): Setup OpenGL
    NSOpenGLPixelFormatAttribute opengl_attrs[] = {
        NSOpenGLPFAOpenGLProfile, NSOpenGLProfileVersion3_2Core,
        NSOpenGLPFAAccelerated,
        NSOpenGLPFADoubleBuffer,
        NSOpenGLPFAColorSize, 32,
        NSOpenGLPFAAlphaSize, 8,
        NSOpenGLPFADepthSize, 24,
        0
    };
    
    NSOpenGLPixelFormat *pixel_format = [[NSOpenGLPixelFormat alloc] initWithAttributes:opengl_attrs];
    if (pixel_format == nil){
        fprintf(stderr, "Error creating OpenGLPixelFormat\n");
        exit(1);
    }
    
    NSOpenGLContext *context = [[NSOpenGLContext alloc] initWithFormat:pixel_format shareContext:nil];
    
    [self setPixelFormat:pixel_format];
    [self setOpenGLContext:context];
    
    [context makeCurrentContext];
    
    [pixel_format release];
    
    gl_is_initialized = true;
}

- (void)render:(Render_Target*)target{
    Assert(gl_is_initialized);
    
    CGLLockContext([[self openGLContext] CGLContextObj]);
    [[self openGLContext] makeCurrentContext];
    
    gl_render(target);
    
    [[self openGLContext] flushBuffer];
    CGLUnlockContext([[self openGLContext] CGLContextObj]);
}
@end

////////////////////////////////

function
mac_render_sig(mac_gl__render){
#if defined(FRED_INTERNAL)
    printf("Redering using OpenGL!\n");
#endif
    
    Mac_OpenGL *gl = (Mac_OpenGL*)renderer;
    [gl->view render:target];
}

function
mac_get_texture_sig(mac_gl__get_texture){
    u32 result = gl__get_texture(dim, texture_kind);
    return(result);
}

function
mac_fill_texture_sig(mac_gl__fill_texture){
    b32 result = gl__fill_texture(texture_kind, texture, p, dim, data);
    return(result);
}

function Mac_OpenGL*
mac_gl__init(NSWindow *window, Render_Target *target){
    // NOTE(yuval): Create the Mac OpenGL Renderer
    Mac_OpenGL *gl = (Mac_OpenGL*)system_memory_allocate(sizeof(Mac_OpenGL),
                                                         file_name_line_number_lit_u8);
    gl->base.render = mac_gl__render;
    gl->base.get_texture = mac_gl__get_texture;
    gl->base.fill_texture = mac_gl__fill_texture;
    
    // NOTE(yuval): Create the OpenGL view
    NSView *content_view = [window contentView];
    
    gl->view = [[OpenGL_View alloc] init];
    [gl->view setFrame:[content_view bounds]];
    [gl->view setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
    [gl->view setWantsBestResolutionOpenGLSurface:YES];
    
    // NOTE(yuval): Add the OpenGL view as a subview of the window
    [content_view addSubview:gl->view];
    
    // NOTE(yuval): Load gl functions
    void *gl_image = dlopen("/System/Library/Frameworks/OpenGL.framework/Versions/Current/OpenGL", RTLD_LAZY);
    
#define GL_FUNC(f,R,P) ((f) = (f##_Function*)dlsym(gl_image, #f));
    
    return(gl);
}

////////////////////////////////

// TODO(yuval): This function should be exported to a DLL
function
mac_load_renderer_sig(mac_load_opengl_renderer){
    Mac_Renderer *renderer = (Mac_Renderer*)mac_gl__init(window, target);
    return(renderer);
}


// end --- mac_4ed_opengl.mm --- 



// begin --- mac_4ed_renderer.mm --- 

/* Mac Renderer Abstraction Implementation */

// TODO(yuval): This should NOT be included here once the renderer is exported to a DLL
#import "mac_4ed_opengl.mm"
#import "mac_4ed_metal.mm"

// TODO(yuval): Replace this array with an array of the paths to the renderer dlls
global mac_load_renderer_type *mac_renderer_load_functions[MacRenderer_COUNT] = {
    mac_load_opengl_renderer,
    mac_load_metal_renderer
};

function Mac_Renderer*
mac_init_renderer(Mac_Renderer_Kind kind, NSWindow *window, Render_Target *target){
    // TODO(yuval): Import renderer load function from a DLL instead of using an array of the load functions. This would allow us to switch the renderer backend and implemented new backends with ease.
    
    mac_load_renderer_type *load_renderer = mac_renderer_load_functions[kind];
    Mac_Renderer *result = load_renderer(window, target);
    
    if (!result){
        system_error_box("Unable to initialize the renderer!");
    }
    
    return result;
}



// end --- mac_4ed_renderer.mm --- 

